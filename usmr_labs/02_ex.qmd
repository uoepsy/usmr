---
title: "Week 2 Exercises: More R; Estimates & Intervals"
reference-location: margin
citation-location: margin
params: 
    SHOW_SOLS: FALSE
    TOGGLE: TRUE
---

```{r setup, include=FALSE}
source('assets/setup.R')
library(xaringanExtra)
xaringanExtra::use_panelset()
```


:::frame
In the last couple of years during welcome week, we have asked students of the statistics courses in the Psychology department to fill out a little survey.  
Anonymised data are available at [https://uoepsy.github.io/data/surveydata_allcourse22.csv](https://uoepsy.github.io/data/surveydata_allcourse22.csv).  
:::

# Data manipulation & visualisation


`r qbegin(1)`
Create a new variable in the dataset which indicates whether people are taller than 6 foot (182cm).

:::hints
You might want to use `mutate()`. Remember to make the changes apply to the objects in your environment, rather than just printing it out.  
`data <- data %>% mutate(...)`  
(see [2A #tidyverse-and-pipes](02a_measurement.html#tidyverse-and-pipes){target="_blank"})

:::
`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`
```{r}
library(tidyverse)
surveydata <- read_csv("https://uoepsy.github.io/data/surveydata_allcourse22.csv")

surveydata <- surveydata %>%
  mutate(
    over6ft = height > 182
  )
```

`r solend()`

`r qbegin(2)`
What percentage of respondents to the survey are greater than 6 foot tall?

:::hints
Try `table()`, and then think about how we can convert the counts to percentages (what does `sum()` of the table give you?).  
See also [2A #categorical](02a_measurement.html#categorical){target="_blank"}.
:::
`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`
We can divide the table by the `sum` of the table
```{r}
table(surveydata$over6ft) / sum(table(surveydata$over6ft))
```
We can also use `prop.table()`
```{r}
prop.table(table(surveydata$over6ft))
```
`r solend()`


`r qbegin(3)`
how many of USMR students in `r paste0(as.numeric(substr(Sys.Date(),1,4)),"/",as.numeric(substr(Sys.Date(),3,4))+1)` are born in the same month as you? 

:::hints
This will involve `filter`ing your data to current USMR students first.  
In tidyverse you can make a table using `... %>% select(variable) %>% table()`  
You can also try `... %>% count(variable)` to get the same information.  
:::

`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`
```{r}
surveydata %>% 
  filter(course == "usmr", year=="2022") %>%
  count(birthmonth)
```

`r solend()`


`r qbegin(4)`
Calculate the mean and standard deviation of heights of all respondents to the survey.  

Can you (also) do this using the tidyverse syntax?

:::hints
We can do it with `mean(data$variable)`, but it will be useful to practice tidyverse style. You'll want to `summarise()` the data.  
We're likely to have missing data in here, so `na.rm=TRUE` will be handy (see [2A #numeric](02a_measurement.html#numeric){target="_blank"})
:::
`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`
This returns us NA:
```{r}
mean(surveydata$height)
```
So we need to make sure we use `na.rm = TRUE` (we can use `T` as a shorthand for `TRUE`).  
```{r}
mean(surveydata$height, na.rm = T)
sd(surveydata$height, na.rm = T)

surveydata %>% 
  summarise(
    meanheight = mean(height, na.rm = T),
    sdheight = sd(height, na.rm = T)
  )
```
`r solend()`

`r qbegin(5)`
Plot the distribution of heights of all respondents. 
Try to make it 'publication ready'.  

:::hints
`hist()` won't cut it here, we're going to want **ggplot**, which was introduced in [2A #ggplot](02a_measurement.html#ggplot){target="_blank"}.  
:::
`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`
```{r}
ggplot(surveydata, aes(x=height)) + 
  geom_histogram(binwidth = 5) + 
  labs(x = "Height (cm)", 
       y = "Frequency", 
       title = "Heights of respondents to the survey") + 
  theme_minimal()
```
`r solend()`


`r qbegin(6)`
For respondents _from each of the different courses_, calculate the mean and standard deviation of heights.  

:::hints
This is just like question 4 - we want to `summarise` our data.   Only this time we need to `group_by` something else first.   
:::
`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`
We're using the same code as we did for question 4, but we've added in one new line using `group_by()`.  
```{r}
surveydata %>% 
  group_by(course) %>%
  summarise(
    meanheight = mean(height, na.rm = T),
    sdheight = sd(height, na.rm = T)
  )
```

`r solend()`

`r qbegin(7)`
Plot the distributions of heights for each course.  
Based on your answer to the previous question, can you picture what the distributions are going to look like _before_ you plot them?  

:::hints
Try looking up the documentation for `?facet_wrap`. It is an incredibly useful extension of ggplot which allows you to create the same plot for different groups.  

You might also want to add an extra `aesthetic` mapping from the `course` variable to some feature of your plot (e.g. 'colour' or 'fill').  
:::
`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`
```{r}
ggplot(surveydata, aes(x=height, fill = course)) + 
  geom_histogram(binwidth = 5) + 
  facet_wrap(~course) + 
  labs(x = "Height (cm)", 
       y = "Frequency", 
       title = "Heights of respondents to the survey") + 
  guides(fill = "none") + 
  theme_minimal()
```

`r solend()`


`r qbegin(8)`
What proportion of respondents to the survey are taller than you?  

:::hints
Remember that we can `sum()` a condition as a quick way of counting.   
`sum(data$variable == "thing")` adds up all the TRUE responses.  
We can actually use this logic inside tidyverse functions like `summarise` and `count` too.  

:::
`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`

There are this _many_ people who are taller than me. 
We need to ignore the NAs again:  
```{r}
sum(surveydata$height > 177, na.rm = T)
```

And if we divide that by the total number of respondents, we get the proportion:  
```{r}
sum(surveydata$height > 177, na.rm = T) / nrow(surveydata)
```

`r solend()`


<div class="divider div-transparent div-dot"></div>

# Estimates & Intervals

For these next exercises we are going to be focusing on self-perceived sleep quality ratings. Our survey contains a set of respondents who completed the question below. We're going to use this sample to get an estimate of the sleep quality rating in the wider population.   
```{r}
#| echo: false
knitr::include_graphics("images/sleepquestion.png")
```

`r qbegin(9)`
We only asked the sleep quality rating question to students in USMR in the 2022/23 academic year, so to make things easier, let's create a subset of the dataset which includes only those students. 

:::hints
This will need some `filter`ing, and assigning (`usmrdata <-`) to a new name.
:::
`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`
```{r}
usmrdata <- surveydata %>% 
  filter(course == "usmr", year == "2022")
dim(usmrdata)
```
`r solend()`


`r qbegin(10)`
For the USMR students in the 2022/23 academic cohort, calculate the following: 

- mean Sleep-Quality rating
- standard deviation of Sleep-Quality ratings
- number of respondents who completed Sleep-Quality rating

:::hints
You can do this with things like `mean(data$variable)`, or you can do it all in tidyverse (see the example of `summarise` in the intro to tidyverse: [2A #tidyverse-and-pipes](02a_measurement.html#tidyverse-and-pipes){target="_blank"}).  

To find out how many in a variable are not NAs, we might need to use `is.na()`. 
A little example for you to play with:  
```{r}
mynumbers <- c(1,5,NA,3,6,NA)
# for each number, TRUE if it's an NA, otherwise FALSE
is.na(mynumbers)
# ! means "not", so this is asking if each number is "not" an NA
!is.na(mynumbers)
# how many non-NAs are there? 
sum(!is.na(mynumbers))
```

:::
`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`
```{r}
usmrdata %>% 
  summarise(
    m_sleep = mean(sleeprating, na.rm = TRUE),
    sd_sleep = mean(sleeprating, na.rm = TRUE),
    n_sleep = sum(!is.na(sleeprating)), 
    n_total = n() # n() will give the total count
  )
```

`r solend()`

`r qbegin(11)`
Using your answers to the previous question, construct a 95% confidence interval for the average Sleep-Quality rating.  

Why might it be a _bad_ idea to use this as an estimate of the average Sleep-Quality  rating of the general population?  

:::hints
The previous question gives you all the pieces that you need. You'll just need to put them together in the way seen in [2B #confidence-intervals](02b_sampling.html#confidence-intervals){target="_blank"}.  

Think about who makes up the sample (e.g. USMR students). Are they _representative_ of the population we are trying to generalise to?  
:::

`r qend()`
`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`

```{r}
#| echo: false
mu = mean(usmrdata$sleeprating, na.rm = TRUE)
su = sd(usmrdata$sleeprating, na.rm = TRUE)
m = round(mean(usmrdata$sleeprating, na.rm = TRUE),2)
s = round(sd(usmrdata$sleeprating, na.rm = TRUE),2)
n = sum(!is.na(usmrdata$sleeprating))
se = round(su/sqrt(n),2)
```

So we have our estimate, which is the mean sleep quality rating in our sample: $\bar x = `r m`$. And we have a standard deviation of our sleep quality ratings: $s = `r s`$. While our sample has `r nrow(usmrdata)` students in it, only `r n` responded to the sleep question, so really our $n$ for this calculation is `r n`.  

We can calculate our standard error as $SE = \frac{s}{\sqrt{n}}$, which is $\frac{`r s`}{\sqrt{`r n`}} = `r se`$.

This tells us that _if_ we were to collect lots of samples of size `r n`, we would expect their mean sleep quality ratings to be normally distributed around `r m` with a standard deviation of `r se`. So we can expect that 95% of the samples we _could_ take would have means between $1.96 \times `r se`$ above and below `r m`. Those are our confidence intervals!  

$$
\begin{align}
\text{Mean = }& `r m` \\
\text{95\% CI = }& `r m` \pm 1.96 \times `r se` \\
&[`r round(m-(1.96*se),2)`, `r round(m+(1.96*se),2)`]
\end{align}
$$




`r solend()`
`
