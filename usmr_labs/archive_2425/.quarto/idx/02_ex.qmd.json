{"title":"Exercises: More R; Estimates & Intervals","markdown":{"yaml":{"title":"Exercises: More R; Estimates & Intervals","params":{"SHOW_SOLS":false,"TOGGLE":true}},"headingText":"Data manipulation & visualisation","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nxaringanExtra::use_panelset()\nqcounter <- function(){\n  if(!exists(\"qcounter_i\")){\n    qcounter_i <<- 1\n  }else{\n    qcounter_i <<- qcounter_i + 1\n  }\n  qcounter_i\n}\n```\n\n\n`r qbegin(0)`\nNow that you've had a little bit of playing around in R, we're going to ask you to change some of RStudio's global settings.  \n\nThere was a section in reading [01A #useful-settings](01a_R.html#useful-settings){target=\"_blank\"} that showed a couple of settings that are very useful. Please change these now.  \n\nWhile you're at it - pick your favourite colour scheme for RStudio and change that too!\n\nIt might also be useful to find a font which differentiates 1 from l, and 0 from O.  \n`r qend()`\n\n\n\n\n:::frame\n__Data: Past Surveys__  \nIn the last few years, we have asked students of the statistics courses in the Psychology department to fill out a little survey.  \nAnonymised data are available at [https://uoepsy.github.io/data/surveydata_historical.csv](https://uoepsy.github.io/data/surveydata_historical.csv).  \n\n__Note:__ this does _not_ contain the responses from this year. \n:::\n\n\n`r qbegin(qcounter())`\nRead in the data, giving it a name to store it in your environment.  \n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n```{r}\nlibrary(tidyverse)\n\nsurveydata <- read_csv(\"https://uoepsy.github.io/data/surveydata_historical.csv\")\n\n```\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nHow many previous **USMR** students are born in the same month as you? \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints   \n\n- The data contains students from some of the other statistics courses we teach, so this will involve `filter`ing your data to USMR students first. \n- In tidyverse you can make a table using `... |> select(variable) |> table()`  \n- You can also try `... |> count(variable)` to get the same information.  \n\n:::\n\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nsurveydata |> \n  filter(course == \"usmr\") |>\n  count(birthmonth)\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nCreate a new variable in the dataset which indicates whether people were taller than 6 foot (182cm).\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nYou might want to use `mutate()`. Remember to make the changes apply to the objects in your environment, rather than just printing it out.  \n`data <- data |> mutate(...)`  \n(see [2A #advances-in-r](02a_measurement.html#advances-in-r){target=\"_blank\"})\n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nsurveydata <- surveydata |>\n  mutate(\n    over6ft = height > 182\n  )\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nWhat percentage of respondents to the survey (for whom we have data on their height) are greater than 6 foot tall?\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \n\n- Try `table()`, and then think about how we can convert the counts to percentages (what does `sum()` of the table give you?).  \n  - `table()` will actually by default count only those values which _aren't_ missing, so this means you don't have to do anything extra here (if you wanted it to also count the missing values, we can use `table(data$variable, useNA = \"ifany\")`)\n- See also [2A #categorical](02a_measurement.html#categorical){target=\"_blank\"}.  \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nWe can divide the table by the `sum` of the table\n```{r}\ntable(surveydata$over6ft) / sum(table(surveydata$over6ft))\n```\nWe can also use `prop.table()`\n```{r}\nprop.table(table(surveydata$over6ft))\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nCalculate the mean and standard deviation of heights of all respondents to the survey.  \n\nCan you also do this using the tidyverse syntax?\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \n\n- We can do it with `mean(data$variable)`, but it will be useful to practice tidyverse style. You'll probably want to `summarise()` the data.  \n- We're likely to have missing data in here, so `na.rm=TRUE` will be handy (see [2A #numeric](02a_measurement.html#numeric){target=\"_blank\"})\n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThis returns us NA:\n```{r}\nmean(surveydata$height)\n```\nSo we need to make sure we use `na.rm = TRUE` (we can use `T` as a shorthand for `TRUE`).  \n```{r}\nmean(surveydata$height, na.rm = T)\nsd(surveydata$height, na.rm = T)\n```\n\nor in tidyverse:\n```{r}\nsurveydata |> \n  summarise(\n    meanheight = mean(height, na.rm = T),\n    sdheight = sd(height, na.rm = T)\n  )\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nPlot the distribution of heights of all respondents. \nTry to make it 'publication ready'.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nif we want a histogram, then `hist()` won't cut it here, we're going to want to use **ggplot** to make a lovely pretty histogram, (ggplot was introduced in [2A #ggplot](02a_measurement.html#ggplot){target=\"_blank\"}).  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nggplot(surveydata, aes(x=height)) + \n  geom_histogram(binwidth = 5) + \n  labs(x = \"Height (cm)\", \n       y = \"Frequency\", \n       title = \"Heights of respondents to the survey\") + \n  theme_minimal()\n```\n`r solend()`\n\n\n`r qbegin(qcounter())`\nFor respondents _from each of the different courses_, calculate the mean and standard deviation of heights.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints   \nThis is just like when we did it for all the respondents - we want to `summarise` our data.   Only this time we need to `group_by` something else first.   \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nWe're using the same code as we did before, but we've added in one new line using `group_by()`.  \n```{r}\nsurveydata |> \n  group_by(course) |>\n  summarise(\n    meanheight = mean(height, na.rm = T),\n    sdheight = sd(height, na.rm = T)\n  )\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nBased on your answer to the previous question, can you picture what the distributions are going to look like?  \n\nPlot the distributions of heights for each course to see if you're correct.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nTry looking up the documentation for `?facet_wrap`. It is an incredibly useful extension of ggplot which allows you to create the same plot for different groups.  \n\nYou might also want to add an extra `aesthetic` mapping from the `course` variable to some feature of your plot (e.g. 'colour' or 'fill').  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nThey're all going to look pretty similar - the center will be at around 167 and the majority of the distribution will lie within about 15cm either side (2 times the standard deviation of about 7.5).  \nNote that the USMR students have a very very slightly higher mean as well as a slightly bigger standard deviation. So this plot will be slightly shifted to the right, and will be slightly more spread out. It might be hard to see these differences just by looking at the plots though.  \n\n```{r}\nggplot(surveydata, aes(x=height, fill = course)) + \n  geom_histogram(binwidth = 5) + \n  facet_wrap(~course) + \n  labs(x = \"Height (cm)\", \n       y = \"Frequency\", \n       title = \"Heights of respondents to the survey\") + \n  guides(fill = \"none\") + \n  theme_minimal()\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\n\nHow many people in the survey do we have height data for? (i.e. how many are not missing?)   \nTo find this out we might need to use `is.na()` (see below for a little example for you to play with).  \n\n::: {.callout-note collapse=\"true\"}\n#### `is.na()`  \n\nThe `is.na(x)` function is a bit like asking `x == NA`. It is necessary because NA is a special thing in R, which means we can't ask questions like `3 == NA` (because we don't know what that `NA` is - it _could_ be 3 for all we know!).  \n```{r}\nmynumbers <- c(1,5,NA,3,6,NA)\nmynumbers == 5\nmynumbers == NA\n```\n\nInstead, we can use `is.na()` to ask \"is this thing an NA?\"  \n```{r}\n# for each number, TRUE if it's an NA, otherwise FALSE\nis.na(mynumbers)\n# ! means \"not\", so this is asking if each number is \"not\" an NA\n!is.na(mynumbers)\n# how many non-NAs are there? \nsum(!is.na(mynumbers))\n```\n:::\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\nTo get the number of respondents with height data, we can sum the non-NA values:\n```{r}\nsum(!is.na(surveydata$height))\n```\nand we have this many missing:\n```{r}\nsum(is.na(surveydata$height))\n```\nwhich makes sense because we have this many entries in the data:\n```{r}\nnrow(surveydata)\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\n\nJust like finding out how many people were over 6 foot, we can quickly work out how many respondents are taller than *\\<insert your height here\\>*, by using `table()`.  \nFor instance, here is a table of how many people are taller than me (Josiah):  \n\n```{r}\ntable(surveydata$height > 177)\n```\n\nHowever, as a learning exercise, let's make sure we can recreate these numbers by doing the calculations manually.  \n\n__Without__ using `table()` or `prop.table()`, find out:  \n\na) How many respondents are taller than you?  \nb) What proportion of respondents (with valid height data) are taller than you?  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \n\n- Remember that we can `sum()` a condition as a quick way of counting: `sum(data$variable == \"thing\")` adds up all the TRUE responses.  \n  - We're going to need to make sure we tell `sum()` to ignore the missing values (`na.rm=TRUE` will come in handy again).  \n- Our denominator (bit on the bottom) for calculating the proportion $\\frac{\\text{nr people taller than me}}{\\text{total nr of people}}$, is the total number of people _for whom we have height data_. We just calculated that in the previous question!   \n- Can you also do this in tidyverse syntax? (most of it can be done inside `summarise()`).  \n  \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nThere are this _many_ people who are taller than me. \nWe need to ignore the NAs again:  \n```{r}\nsum(surveydata$height > 177, na.rm = T)\n```\n\nTo get the total number of respondents with height data, we can sum the non-NA values:\n```{r}\nsum(!is.na(surveydata$height))\n```\n\nAnd if we divide the number who are taller than me by the total number of respondents, we get the proportion:  \n```{r}\nsum(surveydata$height > 177, na.rm = T) / sum(!is.na(surveydata$height))\n```\n\nWe can do all this inside tidyverse too! \n\n```{r}\nsurveydata |> \n  summarise(\n    n_taller = sum(height > 177, na.rm = T),\n    n_heights = sum(!is.na(height)),\n    prop_taller = n_taller / n_heights\n  )\n```\n\n`r solend()`\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Estimates & Intervals\n\nFor these next exercises we are going to be focusing on self-perceived sleep quality ratings. Our survey contains a set of respondents who completed the question below. We're going to use this sample to get an estimate of the sleep quality rating in the wider population.   \n```{r}\n#| echo: false\nknitr::include_graphics(\"images/sleepquestion.png\")\n```\n\n`r qbegin(qcounter())`\nWe only asked the sleep quality rating question to students in USMR since 2022, so to make things easier, let's create a subset of the dataset which includes only those students from 2022 onwards. \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nThis will need some `filter`ing, and assigning (e.g. `usmr2022 <-`) to a new name.\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nusmr2022 <- surveydata |> \n  filter(course == \"usmr\", year >= 2022)\ndim(usmr2022)\n```\n`r solend()`\n\n\n`r qbegin(qcounter())`\nFor the USMR students in the 2022+ academic cohorts, calculate the following: \n\n- mean Sleep-Quality rating\n- standard deviation of Sleep-Quality ratings\n- number of respondents who completed Sleep-Quality rating\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nYou can do this with things like `mean(data$variable)`, or you can do it all in tidyverse (see the example of `summarise` in the intro to tidyverse: [2A #advances-in-r](02a_measurement.html#advances-in-r){target=\"_blank\"}).  \n\n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nusmr2022 |> \n  summarise(\n    m_sleep = mean(sleeprating, na.rm = TRUE),\n    sd_sleep = sd(sleeprating, na.rm = TRUE),\n    n_sleep = sum(!is.na(sleeprating)), \n    n_total = n() # n() will give the total count\n  )\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nUsing your answers to the previous question, construct a 95% confidence interval for the average Sleep-Quality rating.  \nWhy might it be a _bad_ idea to use this as an estimate of the average Sleep-Quality  rating of the global population?  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \n\n- The previous question gives you all the pieces that you need. You'll just need to put them together in the way seen in [2B #confidence-intervals](02b_sampling.html#confidence-intervals){target=\"_blank\"}.  \n- Think about who makes up the sample (e.g. USMR students). Are they _representative_ of the population we are trying to generalise to?  \n\n:::\n\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\n```{r}\n#| echo: false\nmu = mean(usmr2022$sleeprating, na.rm = TRUE)\nsu = sd(usmr2022$sleeprating, na.rm = TRUE)\nm = round(mean(usmr2022$sleeprating, na.rm = TRUE),2)\ns = round(sd(usmr2022$sleeprating, na.rm = TRUE),2)\nn = sum(!is.na(usmr2022$sleeprating))\nse = round(su/sqrt(n),2)\n```\n\nSo we have our estimate, which is the mean sleep quality rating in our sample: $\\bar x = `r m`$. And we have a standard deviation of our sleep quality ratings: $s = `r s`$. While our sample has `r nrow(usmr2022)` students in it, only `r n` responded to the sleep question, so really our $n$ for this calculation is `r n`.  \n\nWe can calculate our standard error as $SE = \\frac{s}{\\sqrt{n}}$, which is $\\frac{`r s`}{\\sqrt{`r n`}} = `r se`$.\n\nThis tells us that _if_ we were to collect lots of samples of size `r n`, we would expect their mean sleep quality ratings to be normally distributed around `r m` with a standard deviation of `r se`. So we can expect that 95% of the samples we _could_ take would have means between $1.96 \\times `r se`$ above and below `r m`. Those are our confidence intervals!  \n\n$$\n\\begin{align}\n\\text{Mean = }& `r m` \\\\\n\\text{95\\% CI = }& `r m` \\pm 1.96 \\times `r se` \\\\\n&[`r round(m-(1.96*se),2)`, `r round(m+(1.96*se),2)`]\n\\end{align}\n$$\n\nHow well does our sample represent the global population? Well, for one thing, they're all university students, and while there will be many students from across the globe, it's highly likely that our sample is biased towards certain countries or continents. Additionally, we're going to have a lot of people in our sample in a fairly narrow age range. It might be that sleep quality changes a lot as people age, in which case our results are probably not going to generalise very well to, for instance, people who are 70 years old. It's also important to remember that this is a snapshot taken at a certain point in time, and might not generalise to other times. There are lots more ways in which our sample might be biased - you can find a nice little 1 page article at [https://www.nature.com/articles/466029a](https://www.nature.com/articles/466029a){target=\"_blank\"} to get you thinking.  \n\n\n`r solend()`\n\n## Optional Extras  \n`r qbegin(qlabel = FALSE, \"Optional Extra\")`\nNote that the confidence interval from the previous question is concerned with describing the abstract and _theoretical_ distribution of \"what the mean sleep quality rating would look like from all possible samples of this size that I _could_ take\". In order to do this we used a formula to describe the spread of this distribution, and in doing so had to assume that the standard deviation of our sample is a good approximation of the standard deviation of the population, and that the population is normally distributed.  \n\nWe can also avoid ever using the standard deviation of our sample (`sd(usmr2022$sleeprating)`), and instead approximate the sampling distribution of the mean by \"bootstrapping\" - taking repeated _resamples_ with replacement from the original sample (see [2B#standard-error](02b_sampling.html#standard-error-in-practice){target=\"_blank\"}.  \n\n```{r}\n#| eval: false\nbootstrap_means <- replicate(1000, mean(sample(observed_sample, replace = TRUE)))\n```\n\n1. Create an object that contains the 10,000 means from 10,000 resamples of our sleep ratings.  \n2. The distribution of resample means is the 'bootstrap distribution'. Plot a histogram of it. What is the standard deviation? How does it compare to the standard error you calculated in the previous question with the formula?  \n3. At what values does the middle 95% of the bootstrap distribution fall?  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nFor 3, look up `quantile()`. We saw this in [2B #confidence-intervals](02b_sampling.html#confidence-intervals){target=\"_blank\"}.  \n\n:::\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n:::panelset\n:::panel\n#### Resample means  \n\nHere is our sample of sleep ratings: \n```{r}\nsleeprates <- usmr2022$sleeprating\n```\nAnd we can get rid of the NA's: \n```{r}\nsleeprates <- sleeprates[!is.na(sleeprates)]\n```\n\nWe can resample with replacement from this set of numbers by using the `replace = TRUE` argument in the `sample()` function.  \nNote, we're leaving `size = ` blank, which means it will stop at the same length as the original vector we give it. \n```{r}\n#| eval: false\nsample(sleeprates, replace = TRUE)\n```\nand the mean of a given resample is calculated by wrapping `mean()` around the above code: \n```{r}\nmean(sample(sleeprates, replace = TRUE))\n```\n\nfinally, we'll do it lots and lots of times, using `replicate()`: \n```{r}\nBSmeans <- replicate(10000, mean(sample(sleeprates, replace = TRUE)))\n```\n\n:::\n:::panel\n#### Bootstrap Distribution\n\nHere's the histogram of the bootstrap distribution:\n```{r}\nhist(BSmeans)\n```\n\nAnd here's the standard deviation of that distribution. This is a bootstrapped estimate of the standard error.  \n\n```{r}\nsd(BSmeans)\n```\n\nRecall our standard error calculated using $\\frac{s}{\\sqrt{n}}$ from the previous question was `r se`\n\n:::\n:::panel\n#### Percentiles\n\nWe can get the 2.5% and 97.5% percentiles (i.e. getting the middle 95%), using the code below. Recall our confidence intervals that we computed analytically were `r round(m-(1.96*se),2)` and `r round(m+(1.96*se),2)`.  \n```{r}\nquantile(BSmeans, c(.025,.975))\n```\n\n:::\n:::\n\n<br><br>\n\n::: {.callout-caution collapse=\"true\"}\n#### bootstraps\n\nBootstrapping is a great way to learn about sampling variability because it allows us to actually plot, summarise and describe what would otherwise be an abstract conceptual distribution.  \n\nIt can also be a useful tool in practice, but it doesn't come without its own problems/complexities. One important thing to note is that it often works _worse_ than traditional methods for small samples, especially skewed samples (i.e. bootstrapping a \"95% CI\" for a small sample will often be too narrow and <95%).  \n\n:::\n\n\n`r solend()`\n\n\n\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nxaringanExtra::use_panelset()\nqcounter <- function(){\n  if(!exists(\"qcounter_i\")){\n    qcounter_i <<- 1\n  }else{\n    qcounter_i <<- qcounter_i + 1\n  }\n  qcounter_i\n}\n```\n\n\n`r qbegin(0)`\nNow that you've had a little bit of playing around in R, we're going to ask you to change some of RStudio's global settings.  \n\nThere was a section in reading [01A #useful-settings](01a_R.html#useful-settings){target=\"_blank\"} that showed a couple of settings that are very useful. Please change these now.  \n\nWhile you're at it - pick your favourite colour scheme for RStudio and change that too!\n\nIt might also be useful to find a font which differentiates 1 from l, and 0 from O.  \n`r qend()`\n\n\n\n# Data manipulation & visualisation\n\n:::frame\n__Data: Past Surveys__  \nIn the last few years, we have asked students of the statistics courses in the Psychology department to fill out a little survey.  \nAnonymised data are available at [https://uoepsy.github.io/data/surveydata_historical.csv](https://uoepsy.github.io/data/surveydata_historical.csv).  \n\n__Note:__ this does _not_ contain the responses from this year. \n:::\n\n\n`r qbegin(qcounter())`\nRead in the data, giving it a name to store it in your environment.  \n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n```{r}\nlibrary(tidyverse)\n\nsurveydata <- read_csv(\"https://uoepsy.github.io/data/surveydata_historical.csv\")\n\n```\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nHow many previous **USMR** students are born in the same month as you? \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints   \n\n- The data contains students from some of the other statistics courses we teach, so this will involve `filter`ing your data to USMR students first. \n- In tidyverse you can make a table using `... |> select(variable) |> table()`  \n- You can also try `... |> count(variable)` to get the same information.  \n\n:::\n\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nsurveydata |> \n  filter(course == \"usmr\") |>\n  count(birthmonth)\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nCreate a new variable in the dataset which indicates whether people were taller than 6 foot (182cm).\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nYou might want to use `mutate()`. Remember to make the changes apply to the objects in your environment, rather than just printing it out.  \n`data <- data |> mutate(...)`  \n(see [2A #advances-in-r](02a_measurement.html#advances-in-r){target=\"_blank\"})\n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nsurveydata <- surveydata |>\n  mutate(\n    over6ft = height > 182\n  )\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nWhat percentage of respondents to the survey (for whom we have data on their height) are greater than 6 foot tall?\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \n\n- Try `table()`, and then think about how we can convert the counts to percentages (what does `sum()` of the table give you?).  \n  - `table()` will actually by default count only those values which _aren't_ missing, so this means you don't have to do anything extra here (if you wanted it to also count the missing values, we can use `table(data$variable, useNA = \"ifany\")`)\n- See also [2A #categorical](02a_measurement.html#categorical){target=\"_blank\"}.  \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nWe can divide the table by the `sum` of the table\n```{r}\ntable(surveydata$over6ft) / sum(table(surveydata$over6ft))\n```\nWe can also use `prop.table()`\n```{r}\nprop.table(table(surveydata$over6ft))\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nCalculate the mean and standard deviation of heights of all respondents to the survey.  \n\nCan you also do this using the tidyverse syntax?\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \n\n- We can do it with `mean(data$variable)`, but it will be useful to practice tidyverse style. You'll probably want to `summarise()` the data.  \n- We're likely to have missing data in here, so `na.rm=TRUE` will be handy (see [2A #numeric](02a_measurement.html#numeric){target=\"_blank\"})\n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThis returns us NA:\n```{r}\nmean(surveydata$height)\n```\nSo we need to make sure we use `na.rm = TRUE` (we can use `T` as a shorthand for `TRUE`).  \n```{r}\nmean(surveydata$height, na.rm = T)\nsd(surveydata$height, na.rm = T)\n```\n\nor in tidyverse:\n```{r}\nsurveydata |> \n  summarise(\n    meanheight = mean(height, na.rm = T),\n    sdheight = sd(height, na.rm = T)\n  )\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nPlot the distribution of heights of all respondents. \nTry to make it 'publication ready'.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nif we want a histogram, then `hist()` won't cut it here, we're going to want to use **ggplot** to make a lovely pretty histogram, (ggplot was introduced in [2A #ggplot](02a_measurement.html#ggplot){target=\"_blank\"}).  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nggplot(surveydata, aes(x=height)) + \n  geom_histogram(binwidth = 5) + \n  labs(x = \"Height (cm)\", \n       y = \"Frequency\", \n       title = \"Heights of respondents to the survey\") + \n  theme_minimal()\n```\n`r solend()`\n\n\n`r qbegin(qcounter())`\nFor respondents _from each of the different courses_, calculate the mean and standard deviation of heights.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints   \nThis is just like when we did it for all the respondents - we want to `summarise` our data.   Only this time we need to `group_by` something else first.   \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nWe're using the same code as we did before, but we've added in one new line using `group_by()`.  \n```{r}\nsurveydata |> \n  group_by(course) |>\n  summarise(\n    meanheight = mean(height, na.rm = T),\n    sdheight = sd(height, na.rm = T)\n  )\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nBased on your answer to the previous question, can you picture what the distributions are going to look like?  \n\nPlot the distributions of heights for each course to see if you're correct.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nTry looking up the documentation for `?facet_wrap`. It is an incredibly useful extension of ggplot which allows you to create the same plot for different groups.  \n\nYou might also want to add an extra `aesthetic` mapping from the `course` variable to some feature of your plot (e.g. 'colour' or 'fill').  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nThey're all going to look pretty similar - the center will be at around 167 and the majority of the distribution will lie within about 15cm either side (2 times the standard deviation of about 7.5).  \nNote that the USMR students have a very very slightly higher mean as well as a slightly bigger standard deviation. So this plot will be slightly shifted to the right, and will be slightly more spread out. It might be hard to see these differences just by looking at the plots though.  \n\n```{r}\nggplot(surveydata, aes(x=height, fill = course)) + \n  geom_histogram(binwidth = 5) + \n  facet_wrap(~course) + \n  labs(x = \"Height (cm)\", \n       y = \"Frequency\", \n       title = \"Heights of respondents to the survey\") + \n  guides(fill = \"none\") + \n  theme_minimal()\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\n\nHow many people in the survey do we have height data for? (i.e. how many are not missing?)   \nTo find this out we might need to use `is.na()` (see below for a little example for you to play with).  \n\n::: {.callout-note collapse=\"true\"}\n#### `is.na()`  \n\nThe `is.na(x)` function is a bit like asking `x == NA`. It is necessary because NA is a special thing in R, which means we can't ask questions like `3 == NA` (because we don't know what that `NA` is - it _could_ be 3 for all we know!).  \n```{r}\nmynumbers <- c(1,5,NA,3,6,NA)\nmynumbers == 5\nmynumbers == NA\n```\n\nInstead, we can use `is.na()` to ask \"is this thing an NA?\"  \n```{r}\n# for each number, TRUE if it's an NA, otherwise FALSE\nis.na(mynumbers)\n# ! means \"not\", so this is asking if each number is \"not\" an NA\n!is.na(mynumbers)\n# how many non-NAs are there? \nsum(!is.na(mynumbers))\n```\n:::\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\nTo get the number of respondents with height data, we can sum the non-NA values:\n```{r}\nsum(!is.na(surveydata$height))\n```\nand we have this many missing:\n```{r}\nsum(is.na(surveydata$height))\n```\nwhich makes sense because we have this many entries in the data:\n```{r}\nnrow(surveydata)\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\n\nJust like finding out how many people were over 6 foot, we can quickly work out how many respondents are taller than *\\<insert your height here\\>*, by using `table()`.  \nFor instance, here is a table of how many people are taller than me (Josiah):  \n\n```{r}\ntable(surveydata$height > 177)\n```\n\nHowever, as a learning exercise, let's make sure we can recreate these numbers by doing the calculations manually.  \n\n__Without__ using `table()` or `prop.table()`, find out:  \n\na) How many respondents are taller than you?  \nb) What proportion of respondents (with valid height data) are taller than you?  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \n\n- Remember that we can `sum()` a condition as a quick way of counting: `sum(data$variable == \"thing\")` adds up all the TRUE responses.  \n  - We're going to need to make sure we tell `sum()` to ignore the missing values (`na.rm=TRUE` will come in handy again).  \n- Our denominator (bit on the bottom) for calculating the proportion $\\frac{\\text{nr people taller than me}}{\\text{total nr of people}}$, is the total number of people _for whom we have height data_. We just calculated that in the previous question!   \n- Can you also do this in tidyverse syntax? (most of it can be done inside `summarise()`).  \n  \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nThere are this _many_ people who are taller than me. \nWe need to ignore the NAs again:  \n```{r}\nsum(surveydata$height > 177, na.rm = T)\n```\n\nTo get the total number of respondents with height data, we can sum the non-NA values:\n```{r}\nsum(!is.na(surveydata$height))\n```\n\nAnd if we divide the number who are taller than me by the total number of respondents, we get the proportion:  \n```{r}\nsum(surveydata$height > 177, na.rm = T) / sum(!is.na(surveydata$height))\n```\n\nWe can do all this inside tidyverse too! \n\n```{r}\nsurveydata |> \n  summarise(\n    n_taller = sum(height > 177, na.rm = T),\n    n_heights = sum(!is.na(height)),\n    prop_taller = n_taller / n_heights\n  )\n```\n\n`r solend()`\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Estimates & Intervals\n\nFor these next exercises we are going to be focusing on self-perceived sleep quality ratings. Our survey contains a set of respondents who completed the question below. We're going to use this sample to get an estimate of the sleep quality rating in the wider population.   \n```{r}\n#| echo: false\nknitr::include_graphics(\"images/sleepquestion.png\")\n```\n\n`r qbegin(qcounter())`\nWe only asked the sleep quality rating question to students in USMR since 2022, so to make things easier, let's create a subset of the dataset which includes only those students from 2022 onwards. \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nThis will need some `filter`ing, and assigning (e.g. `usmr2022 <-`) to a new name.\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nusmr2022 <- surveydata |> \n  filter(course == \"usmr\", year >= 2022)\ndim(usmr2022)\n```\n`r solend()`\n\n\n`r qbegin(qcounter())`\nFor the USMR students in the 2022+ academic cohorts, calculate the following: \n\n- mean Sleep-Quality rating\n- standard deviation of Sleep-Quality ratings\n- number of respondents who completed Sleep-Quality rating\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nYou can do this with things like `mean(data$variable)`, or you can do it all in tidyverse (see the example of `summarise` in the intro to tidyverse: [2A #advances-in-r](02a_measurement.html#advances-in-r){target=\"_blank\"}).  \n\n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nusmr2022 |> \n  summarise(\n    m_sleep = mean(sleeprating, na.rm = TRUE),\n    sd_sleep = sd(sleeprating, na.rm = TRUE),\n    n_sleep = sum(!is.na(sleeprating)), \n    n_total = n() # n() will give the total count\n  )\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nUsing your answers to the previous question, construct a 95% confidence interval for the average Sleep-Quality rating.  \nWhy might it be a _bad_ idea to use this as an estimate of the average Sleep-Quality  rating of the global population?  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \n\n- The previous question gives you all the pieces that you need. You'll just need to put them together in the way seen in [2B #confidence-intervals](02b_sampling.html#confidence-intervals){target=\"_blank\"}.  \n- Think about who makes up the sample (e.g. USMR students). Are they _representative_ of the population we are trying to generalise to?  \n\n:::\n\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\n```{r}\n#| echo: false\nmu = mean(usmr2022$sleeprating, na.rm = TRUE)\nsu = sd(usmr2022$sleeprating, na.rm = TRUE)\nm = round(mean(usmr2022$sleeprating, na.rm = TRUE),2)\ns = round(sd(usmr2022$sleeprating, na.rm = TRUE),2)\nn = sum(!is.na(usmr2022$sleeprating))\nse = round(su/sqrt(n),2)\n```\n\nSo we have our estimate, which is the mean sleep quality rating in our sample: $\\bar x = `r m`$. And we have a standard deviation of our sleep quality ratings: $s = `r s`$. While our sample has `r nrow(usmr2022)` students in it, only `r n` responded to the sleep question, so really our $n$ for this calculation is `r n`.  \n\nWe can calculate our standard error as $SE = \\frac{s}{\\sqrt{n}}$, which is $\\frac{`r s`}{\\sqrt{`r n`}} = `r se`$.\n\nThis tells us that _if_ we were to collect lots of samples of size `r n`, we would expect their mean sleep quality ratings to be normally distributed around `r m` with a standard deviation of `r se`. So we can expect that 95% of the samples we _could_ take would have means between $1.96 \\times `r se`$ above and below `r m`. Those are our confidence intervals!  \n\n$$\n\\begin{align}\n\\text{Mean = }& `r m` \\\\\n\\text{95\\% CI = }& `r m` \\pm 1.96 \\times `r se` \\\\\n&[`r round(m-(1.96*se),2)`, `r round(m+(1.96*se),2)`]\n\\end{align}\n$$\n\nHow well does our sample represent the global population? Well, for one thing, they're all university students, and while there will be many students from across the globe, it's highly likely that our sample is biased towards certain countries or continents. Additionally, we're going to have a lot of people in our sample in a fairly narrow age range. It might be that sleep quality changes a lot as people age, in which case our results are probably not going to generalise very well to, for instance, people who are 70 years old. It's also important to remember that this is a snapshot taken at a certain point in time, and might not generalise to other times. There are lots more ways in which our sample might be biased - you can find a nice little 1 page article at [https://www.nature.com/articles/466029a](https://www.nature.com/articles/466029a){target=\"_blank\"} to get you thinking.  \n\n\n`r solend()`\n\n## Optional Extras  \n`r qbegin(qlabel = FALSE, \"Optional Extra\")`\nNote that the confidence interval from the previous question is concerned with describing the abstract and _theoretical_ distribution of \"what the mean sleep quality rating would look like from all possible samples of this size that I _could_ take\". In order to do this we used a formula to describe the spread of this distribution, and in doing so had to assume that the standard deviation of our sample is a good approximation of the standard deviation of the population, and that the population is normally distributed.  \n\nWe can also avoid ever using the standard deviation of our sample (`sd(usmr2022$sleeprating)`), and instead approximate the sampling distribution of the mean by \"bootstrapping\" - taking repeated _resamples_ with replacement from the original sample (see [2B#standard-error](02b_sampling.html#standard-error-in-practice){target=\"_blank\"}.  \n\n```{r}\n#| eval: false\nbootstrap_means <- replicate(1000, mean(sample(observed_sample, replace = TRUE)))\n```\n\n1. Create an object that contains the 10,000 means from 10,000 resamples of our sleep ratings.  \n2. The distribution of resample means is the 'bootstrap distribution'. Plot a histogram of it. What is the standard deviation? How does it compare to the standard error you calculated in the previous question with the formula?  \n3. At what values does the middle 95% of the bootstrap distribution fall?  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nFor 3, look up `quantile()`. We saw this in [2B #confidence-intervals](02b_sampling.html#confidence-intervals){target=\"_blank\"}.  \n\n:::\n\n\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n:::panelset\n:::panel\n#### Resample means  \n\nHere is our sample of sleep ratings: \n```{r}\nsleeprates <- usmr2022$sleeprating\n```\nAnd we can get rid of the NA's: \n```{r}\nsleeprates <- sleeprates[!is.na(sleeprates)]\n```\n\nWe can resample with replacement from this set of numbers by using the `replace = TRUE` argument in the `sample()` function.  \nNote, we're leaving `size = ` blank, which means it will stop at the same length as the original vector we give it. \n```{r}\n#| eval: false\nsample(sleeprates, replace = TRUE)\n```\nand the mean of a given resample is calculated by wrapping `mean()` around the above code: \n```{r}\nmean(sample(sleeprates, replace = TRUE))\n```\n\nfinally, we'll do it lots and lots of times, using `replicate()`: \n```{r}\nBSmeans <- replicate(10000, mean(sample(sleeprates, replace = TRUE)))\n```\n\n:::\n:::panel\n#### Bootstrap Distribution\n\nHere's the histogram of the bootstrap distribution:\n```{r}\nhist(BSmeans)\n```\n\nAnd here's the standard deviation of that distribution. This is a bootstrapped estimate of the standard error.  \n\n```{r}\nsd(BSmeans)\n```\n\nRecall our standard error calculated using $\\frac{s}{\\sqrt{n}}$ from the previous question was `r se`\n\n:::\n:::panel\n#### Percentiles\n\nWe can get the 2.5% and 97.5% percentiles (i.e. getting the middle 95%), using the code below. Recall our confidence intervals that we computed analytically were `r round(m-(1.96*se),2)` and `r round(m+(1.96*se),2)`.  \n```{r}\nquantile(BSmeans, c(.025,.975))\n```\n\n:::\n:::\n\n<br><br>\n\n::: {.callout-caution collapse=\"true\"}\n#### bootstraps\n\nBootstrapping is a great way to learn about sampling variability because it allows us to actually plot, summarise and describe what would otherwise be an abstract conceptual distribution.  \n\nIt can also be a useful tool in practice, but it doesn't come without its own problems/complexities. One important thing to note is that it often works _worse_ than traditional methods for small samples, especially skewed samples (i.e. bootstrapping a \"95% CI\" for a small sample will often be too narrow and <95%).  \n\n:::\n\n\n`r solend()`\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":["assets/toggling.html",{"text":"<link rel=\"stylesheet\" href=\"https://uoepsy.github.io/assets/css/ccfooter.css\" />\n"}],"number-sections":false,"output-file":"02_ex.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","toc_float":true,"code-annotations":"hover","link-citations":true,"theme":["united","assets/style-labs.scss"],"title":"Exercises: More R; Estimates & Intervals","params":{"SHOW_SOLS":false,"TOGGLE":true}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}