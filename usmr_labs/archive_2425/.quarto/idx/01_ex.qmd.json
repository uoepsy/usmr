{"title":"Exercises: Intro R","markdown":{"yaml":{"title":"Exercises: Intro R","params":{"SHOW_SOLS":false,"TOGGLE":true}},"headingText":"First things","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nxaringanExtra::use_panelset()\nqcounter <- function(){\n  if(!exists(\"qcounter_i\")){\n    qcounter_i <<- 1\n  }else{\n    qcounter_i <<- qcounter_i + 1\n  }\n  qcounter_i\n}\n```\n\n\nThe very first things to do are to open RStudio and get a blank script ready for writing your code!\n\n:::column-margin\nOur recommendation is that you have an R project for this course, and use a new script for each week of work. See [the tip about \"R projects\" in Section 1A](01a_R.html#the-four-rstudio-panes){target=\"_blank\"}.  \n:::\n\n# Pet Data\n\n:::frame\nWe're going to play with some data on a sample of licensed pets from the city of Seattle, USA. It can be downloaded (or read directly into R) from [https://uoepsy.github.io/data/pets_seattle.csv](https://uoepsy.github.io/data/pets_seattle.csv). It contains information on the license ID, year of issue, as well as the species, breeds and weights of each pet. You can find a data dictionary in @tbl-petdict  \n\n```{r}\n#| label: tbl-petdict\n#| tbl-cap: \"Seattle Pets: Data dictionary\"\n#| echo: false\nlibrary(tidyverse)\npetdata<-read_csv(\"https://uoepsy.github.io/data/pets_seattle.csv\")\n\ndict = tibble(\n  Variable = names(petdata),\n  Description = c(\"Year in which license was issued\",\n                  \"Unique license ID number\",\n                  \"Full name of pet\",\n                  \"Species of pet\",\n                  \"Primary breed of pet\",\n                  \"Secondary breed of pet\",\n                  \"Weight in kilograms\"\n                  )\n)\nknitr::kable(dict)\n```\n:::\n\n\n`r qbegin(qcounter())`\nWrite a line of code that reads in the data to your R session. Then examine the dimensions of the dataset, and take a look at the first few lines.\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nYou'll need the `read.csv()` function. Remember to assign it a name to store it in your environment.  \n[1B #basic-data-wrangling](01b_data.html#basic-data-wrangling){target=\"_blank\"} contains an example of reading in data from a URL. \nYou'll then want to play with functions like `dim()` and `head()`.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nWe're going to call it `petdata` in our environment here. Don't forget the quotation marks around the url (otherwise R will look for an object in your environment called `https://...`, which isn't there). \n```{r}\npetdata<-read.csv(\"https://uoepsy.github.io/data/pets_seattle.csv\")\ndim(petdata)\n```\nWe can see there are `r nrow(petdata)` rows and `r ncol(petdata)` columns.  \nAnd we can see the first few rows here:  \n```{r}\nhead(petdata)\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nWhat are the names of the 47th and the 200th animals in the dataset? (use R code to find out)   \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nYou'll probably want to make use of the square brackets `data[rows, columns]`.\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThere are lots of different ways to do this. \nWe can get out the entire rows, either individually:\n```{r}\n#| eval: false\npetdata[47,]\npetdata[200,]\n```\nOr together:\n```{r}\npetdata[c(47,200),]\n```\n\nOr we can extract the names only:\n```{r}\n#| eval: false\n# These all do the same\npetdata[c(47,200),\"animals_name\"]\npetdata[c(47,200),3]\npetdata$animals_name[c(47,200)]\n```\nThe will all give us these names:  \n```{r}\n#| echo: false\npetdata$animals_name[c(47,200)]\n```\nIn the last one, we use the `$` to access the `animals_name` variable. In this case, we don't need to specify `[rows, columns]` inside the square brackets, because it's a single variable - there are no columns.  \n\n- `dataframe[rows, columns]`  \n- `variable[entries]`  \n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nSubset the data to only the animals which are _dogs_, and store this subset as another named object in your environment.   \nDo the same for the _cats._ \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nYou'll want to think about how we access data via asking for those entries that meet a specific _condition_ (see [1B #accessing-by-a-condition](01b_data.html#accessing-by-a-condition){target=\"_blank\"})  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nWe can ask \"which entries of species variable are equal to 'Dog'?\" by using `pet$species==\"Dog\"`.  \nThis will give us a TRUE for each dog, and a FALSE for each non-dog.   \nWe can then use this set of TRUEs and FALSEs to access those rows for which it is TRUE in our data:\n\n```{r}\ndogdata <- petdata[petdata$species==\"Dog\", ]\ncatdata <- petdata[petdata$species==\"Cat\", ]\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nFind the name and weight of the heaviest cat, and of the lightest dog.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nYou could do this using the original data you read in from question 1, or use the subsets you created in question 3. You'll again want to supply a condition within square brackets `data[?==?]`. That condition may well have something to do with being equal to the `min()` or the `max()` of some variable.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nWe can use `min()` and `max()` to return the minimum and maximum of a variable: \n```{r}\nmin(dogdata$weight_kg)\nmax(catdata$weight_kg)\n```\n\nWe could then ask for each entry \"is this cat's weight the maximum cat's weight?\" with `catdata$weight_kg == max(catdata$weight_kg)` and then use that condition to access the rows in our dataset where the `weight_kg` variable is at its maximum:\n\n```{r}\ncatdata[catdata$weight_kg == max(catdata$weight_kg), ]\ndogdata[dogdata$weight_kg == min(dogdata$weight_kg), ]\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nDoes the original dataset contain _only_ dogs and cats?  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nGiven what you did in question 3, you might be able to answer this by just looking at your environment.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nIn the environment, we can see that the entire dataset has `r nrow(petdata)` observations, the Dog's data frame has `r nrow(dogdata)`, and the Cat's has `r nrow(catdata)`.  \nSo there are `r nrow(petdata) - (nrow(dogdata) + nrow(catdata))` missing!  \n`r solend()`\n\n`r qbegin(qcounter())`\nExtract the entries of the original dataset for which the species is neither \"Dog\" nor \"Cat\"?  \nWhat are the names and species of these animals? \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nThis is a slightly complex one. [1B #more-complex-conditions](01b_data.html#more-complex-conditions){target=\"_blank\"} might help you here.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nAs always, there are lots of different ways.  \nHere are three:  \n\n::::panelset\n\n:::panel\n#### \"not a dog AND not a cat\"\nWe can ask if something is not a dog by using `petdata$species != \"Dog\"`. But we want the rows where the species is not a dog _and_ it's not a cat.  So it's two conditions:  \n\n```{r}\npetdata[petdata$species != \"Cat\" & petdata$species != \"Dog\", ]\n```\n:::\n:::panel\n#### \"not (dog OR cat)\"\nWe could also do this in other ways, such as asking for all the entries which are _either_ \"Dog\" _or_ \"Cat\", and then negating them: \n\n```{r}\npetdata[!(petdata$species == \"Cat\" | petdata$species == \"Dog\"), ]\n```\n:::\n:::panel\n#### \"not one of [Dog, Cat]\"\n\nAnother clever little operator is the `%in%` operator, which asks whether something is _in_ a set of things. Unfortunately, we can't use `!%in%` to mean \"not in\", so we need to put the `!` right at the start of the condition:  \n\n```{r}\npetdata[!petdata$species %in% c(\"Cat\",\"Dog\"), ]\n```\n:::\n::::\n\n`r solend()`\n\n`r qbegin(qcounter())`\nCreate a new variable in the data, which contains the weights of all the animals, but rounded to the nearest kg. \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nTry looking up the help documentation for the function `round()`. Try playing with it in the console, e.g. `round(c(3.5, 4.257, 1.1111))`. You may find it helpful to look back at [1B #adding/changing-a-variable](01b_data.html#addingchanging-a-variable){target=\"_blank\"}.  \n\n- \"to the nearest kg\" would mean we want no decimal points. Note that `round()` has a _digits_ argument. e.g. `round(22.324, digits = 2)` and `round(22.324, digits = 1)` do different things.  \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nWe're wanting this variable as a new column in the data, so don't forget the `dataframe$newvariable <- ......` bit.  \n```{r}\npetdata$weight_rounded <- round(petdata$weight_kg)\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nTry giving the dataset to the function `summary()`. You'll get out some information on each of the variables. It is likely that you'll get more useful information for the variables containing information on the animal's weights than for those containing their names, breeds etc because these variables are vectors of \"characters\". We'll start to look more about different types of data next week.  \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nEasy to do!  \n```{r}\nsummary(petdata)\n```\n`r solend()`\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Simulating Dice\n\n`r qbegin(qcounter())`\nCopy the code from the lecture which creates a custom function called `dice()` (copied below).  \nBe sure to *run* the code (highlight it all with your cursor, and hit \"run\" in the top right, or press Ctrl/Cmd+Enter).  \n```{r}\ndice <- function(num = 1) {\n  sum(sample(1:6, num, replace=TRUE))\n}\n```\n\n`r qend()`\n\n<div style=\"border-radius: 5px; padding: 20px 20px 10px 20px; margin-top: 20px; margin-bottom: 20px; border: 1px solid #333333 !important;\">\n**What did that code do?**\n\nIn a sense, this code does *nothing*:  It won't give you any output when you run it.  What it is actually doing, though, is defining a *function* called `dice()`.  If you look at your *environment* panel (top right), you'll see `dice` appear when you run the code.\n  \nTo produce some output, we have to *call* the function `dice()` (by writing it into code:  `dice(4)`, for example).  `dice()` wants to be supplied with some information (in the *argument* `num`).  If no information is supplied, num will take a *default value* of `1`.  (So writing `dice()` is equivalent to writing `dice(1)`).\n\nWhat does `dice()` do with `num`?  It calls another function, `sample()`, with *3* arguments.  We didn't write `sample()`:  it's a function that's \"supplied with\" R.  To find out more about what `sample()` does:\n\n* click inside the brackets just after `sample()` in your R script;\n\n* press `TAB` (`⇥`), then `F1`\n\n* you should see some help appear in the bottom right-hand panel of RStudio.\n\nYou will find that \"`sample()` takes a sample ... from the elements of `x` ...\"  If you compare the code in RStudio to the code under \"Usage\" you'll see that where the help has `x`, we have `1:6`.  So what does `1:6` mean?  One way to find out is to open the **console** in RStudio (bottom left) and just type stuff in.  What happens when you type `1:6`?  What about `2:17`?  (What about `6:1`?)\n\n__Remember:__ The console is the place to \"try stuff out\" (don't worry, you can't break it). \n\nWhat you will discover is that `1:6` creates a *vector* (list of similar things, in this case numbers) of the numbers 1-6. The next bit of the `sample()` function is `size`. In the `dice()` function, the `num` passes down to the `size` of the `sample()`: Looking through the help, `size` is the number of items to choose.  So `sample(1:6, 1)` would choose one number from the numbers 1-6 at random; `sample(1:6, 3)` would choose 3, and so on.  The last argument, `replace=TRUE`, tells `sample()` what to do with a number once it's been picked:  Does it go 'back into the bag' to be picked again (`TRUE`) or not? (`FALSE`)?  \n\nAround the outside is `sum()` which simply sums the numbers on however many (`num`) dice you \"rolled\".  \n\nPutting it all together, our `dice()` function \"throws `num` dice\" by `sample()`ing from the numbers 1-6 `num` times, `replace`ing each number when it's been picked, and sums the numbers of all the dice.  \n\n</div>\n\n`r qbegin(qcounter())`\nUse the function you just made to 'roll a die' a few times. Check that it works like you expect.  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nYou just need to run `dice()` a few times. A single die means `num = 1`, which is the default.  \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\ndice()\ndice()\ndice()\ndice()\n```\n\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nLook up the function `replicate()`. We can use it to do something in R lots of times! For instance, `replicate(20, 1+1)` will evaluate `1+1` twenty times.  \n\nUse `replicate()` to simulate 20 rolls of a single die, and store the results in an object in your environment. Give it an easily identifiable name.  \nWhat does each value in this object represent?  \n\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nrolls20 <- replicate(20, dice(num = 1))\nrolls20\n```\nEach value in `rolls20` represents the simulated roll of a single die. We roll our die, and get a `r rolls20[1]`, we roll it again and get `r rolls20[2]`, the third roll we get `r rolls20[3]`, and so on.. \n`r solend()`\n\n`r qbegin(qcounter())`\nCreate a barplot showing the frequency with which each number was landed on in the 20 rolls.\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nThe functions `table()` and `barplot()` were used to do this in the lecture.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nYour plots will look slightly different to these, because all of our dice are random!\n```{r}\n# We can get the frequency table using table()\ntable(rolls20)\n# Which we can then pass to the barplot() function:\nbarplot(table(rolls20))\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nDo the same for 100 rolls, and then for 1,000. What do you notice?   \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nmorerolls <- replicate(100, dice(1))\nbarplot(table(morerolls))\n\nmorerolls2 <- replicate(1000, dice(1))\nbarplot(table(morerolls2))\n```\nThe more rolls we do of the dice, the flatter the graph becomes. This is because there is an equal probability of the die landing on any of the responses - there is a uniform probability.  \n`r solend()`\n\n\n`r qbegin(qcounter())`\nCopy the code below into your script and run it. It creates a new function called `wdice()` which simulates the rolling of `num` dice which are slightly weighted.  \n  \nRoll a single weighted die 20 times and plot the frequency distribution. Do the same for 100 and 1,000 rolls of a single die. Does a pattern emerge? At how many rolls?  \n```{r}\nwdice <- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n```\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n`r set.seed(38)`\n```{r}\nwdice <- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n\nwd <- replicate(20, wdice(1))\nbarplot(table(wd))\n\nwd <- replicate(1000, wdice(1))\nbarplot(table(wd))\n\nwd <- replicate(10000, wdice(1))\nbarplot(table(wd))\n```\n\nThe die is clearly weighted towards landing on 6. \nHowever, is 20 rolls enough to reliably observe this? In _our_ 20 rolls above, it landed on 3 quite a bit too (yours will be different)! The pattern becomes clearer after 1000 rolls.  \n\n`r solend()`\n\n`r qbegin(qcounter())`\nRemember, `wdice()` and `dice()` are really just relying on different functions, like `sample()`. Try playing around with `sample()` in the console again - what does the `prob = c(....)` bit do?   \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThe prob bit is defining the probabilities of observing each outcome - i.e. there is a 25% chance of rolling a 6.  \n`r solend()`\n\n`r qbegin(qcounter())`\nLet's try to modify the `wdice()` function. Edit the code for `wdice()` so that 50% of the time it lands on number 6.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints \n\n- To test out your modified function, you will need to re-run the code which defines the function. When we use `wdice()` we use the function which is in our environment. If we want to edit the function, we need to then overwrite (or \"replace\"/\"reassign\") the object in our environment.  \n- We need to be careful to remember that the probability of different outcomes should sum to 1 (i.e., it's not possible to \"50% of the time land on 6\" as well as \"70% of the time land on 5\"!). \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nwdice <- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.1,0.1,0.1,0.1,0.1,0.5)))\n}\n```\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nCan you observe the weighting in your new die (the one which 50% of the time lands on number 6) in only 20 rolls?  \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nwd <- replicate(20, wdice(1))\nbarplot(table(wd))\n```\nThe die is very clearly weighted to land on 6. We can see this in just 20 rolls. Presumably it will become even clearer if we increased how many times we roll it.  \n\n`r solend()`\n\n  \n`r qbegin(qcounter())`\nConceptually, what can we learn from this toy example?    \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThe more highly weighted a die is, the less we have to roll it in order to observe that weighting.  \n`r solend()`\n\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nxaringanExtra::use_panelset()\nqcounter <- function(){\n  if(!exists(\"qcounter_i\")){\n    qcounter_i <<- 1\n  }else{\n    qcounter_i <<- qcounter_i + 1\n  }\n  qcounter_i\n}\n```\n\n# First things\n\nThe very first things to do are to open RStudio and get a blank script ready for writing your code!\n\n:::column-margin\nOur recommendation is that you have an R project for this course, and use a new script for each week of work. See [the tip about \"R projects\" in Section 1A](01a_R.html#the-four-rstudio-panes){target=\"_blank\"}.  \n:::\n\n# Pet Data\n\n:::frame\nWe're going to play with some data on a sample of licensed pets from the city of Seattle, USA. It can be downloaded (or read directly into R) from [https://uoepsy.github.io/data/pets_seattle.csv](https://uoepsy.github.io/data/pets_seattle.csv). It contains information on the license ID, year of issue, as well as the species, breeds and weights of each pet. You can find a data dictionary in @tbl-petdict  \n\n```{r}\n#| label: tbl-petdict\n#| tbl-cap: \"Seattle Pets: Data dictionary\"\n#| echo: false\nlibrary(tidyverse)\npetdata<-read_csv(\"https://uoepsy.github.io/data/pets_seattle.csv\")\n\ndict = tibble(\n  Variable = names(petdata),\n  Description = c(\"Year in which license was issued\",\n                  \"Unique license ID number\",\n                  \"Full name of pet\",\n                  \"Species of pet\",\n                  \"Primary breed of pet\",\n                  \"Secondary breed of pet\",\n                  \"Weight in kilograms\"\n                  )\n)\nknitr::kable(dict)\n```\n:::\n\n\n`r qbegin(qcounter())`\nWrite a line of code that reads in the data to your R session. Then examine the dimensions of the dataset, and take a look at the first few lines.\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nYou'll need the `read.csv()` function. Remember to assign it a name to store it in your environment.  \n[1B #basic-data-wrangling](01b_data.html#basic-data-wrangling){target=\"_blank\"} contains an example of reading in data from a URL. \nYou'll then want to play with functions like `dim()` and `head()`.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nWe're going to call it `petdata` in our environment here. Don't forget the quotation marks around the url (otherwise R will look for an object in your environment called `https://...`, which isn't there). \n```{r}\npetdata<-read.csv(\"https://uoepsy.github.io/data/pets_seattle.csv\")\ndim(petdata)\n```\nWe can see there are `r nrow(petdata)` rows and `r ncol(petdata)` columns.  \nAnd we can see the first few rows here:  \n```{r}\nhead(petdata)\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nWhat are the names of the 47th and the 200th animals in the dataset? (use R code to find out)   \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints  \nYou'll probably want to make use of the square brackets `data[rows, columns]`.\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThere are lots of different ways to do this. \nWe can get out the entire rows, either individually:\n```{r}\n#| eval: false\npetdata[47,]\npetdata[200,]\n```\nOr together:\n```{r}\npetdata[c(47,200),]\n```\n\nOr we can extract the names only:\n```{r}\n#| eval: false\n# These all do the same\npetdata[c(47,200),\"animals_name\"]\npetdata[c(47,200),3]\npetdata$animals_name[c(47,200)]\n```\nThe will all give us these names:  \n```{r}\n#| echo: false\npetdata$animals_name[c(47,200)]\n```\nIn the last one, we use the `$` to access the `animals_name` variable. In this case, we don't need to specify `[rows, columns]` inside the square brackets, because it's a single variable - there are no columns.  \n\n- `dataframe[rows, columns]`  \n- `variable[entries]`  \n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nSubset the data to only the animals which are _dogs_, and store this subset as another named object in your environment.   \nDo the same for the _cats._ \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nYou'll want to think about how we access data via asking for those entries that meet a specific _condition_ (see [1B #accessing-by-a-condition](01b_data.html#accessing-by-a-condition){target=\"_blank\"})  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nWe can ask \"which entries of species variable are equal to 'Dog'?\" by using `pet$species==\"Dog\"`.  \nThis will give us a TRUE for each dog, and a FALSE for each non-dog.   \nWe can then use this set of TRUEs and FALSEs to access those rows for which it is TRUE in our data:\n\n```{r}\ndogdata <- petdata[petdata$species==\"Dog\", ]\ncatdata <- petdata[petdata$species==\"Cat\", ]\n```\n\n`r solend()`\n\n`r qbegin(qcounter())`\nFind the name and weight of the heaviest cat, and of the lightest dog.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nYou could do this using the original data you read in from question 1, or use the subsets you created in question 3. You'll again want to supply a condition within square brackets `data[?==?]`. That condition may well have something to do with being equal to the `min()` or the `max()` of some variable.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nWe can use `min()` and `max()` to return the minimum and maximum of a variable: \n```{r}\nmin(dogdata$weight_kg)\nmax(catdata$weight_kg)\n```\n\nWe could then ask for each entry \"is this cat's weight the maximum cat's weight?\" with `catdata$weight_kg == max(catdata$weight_kg)` and then use that condition to access the rows in our dataset where the `weight_kg` variable is at its maximum:\n\n```{r}\ncatdata[catdata$weight_kg == max(catdata$weight_kg), ]\ndogdata[dogdata$weight_kg == min(dogdata$weight_kg), ]\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nDoes the original dataset contain _only_ dogs and cats?  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nGiven what you did in question 3, you might be able to answer this by just looking at your environment.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nIn the environment, we can see that the entire dataset has `r nrow(petdata)` observations, the Dog's data frame has `r nrow(dogdata)`, and the Cat's has `r nrow(catdata)`.  \nSo there are `r nrow(petdata) - (nrow(dogdata) + nrow(catdata))` missing!  \n`r solend()`\n\n`r qbegin(qcounter())`\nExtract the entries of the original dataset for which the species is neither \"Dog\" nor \"Cat\"?  \nWhat are the names and species of these animals? \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nThis is a slightly complex one. [1B #more-complex-conditions](01b_data.html#more-complex-conditions){target=\"_blank\"} might help you here.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nAs always, there are lots of different ways.  \nHere are three:  \n\n::::panelset\n\n:::panel\n#### \"not a dog AND not a cat\"\nWe can ask if something is not a dog by using `petdata$species != \"Dog\"`. But we want the rows where the species is not a dog _and_ it's not a cat.  So it's two conditions:  \n\n```{r}\npetdata[petdata$species != \"Cat\" & petdata$species != \"Dog\", ]\n```\n:::\n:::panel\n#### \"not (dog OR cat)\"\nWe could also do this in other ways, such as asking for all the entries which are _either_ \"Dog\" _or_ \"Cat\", and then negating them: \n\n```{r}\npetdata[!(petdata$species == \"Cat\" | petdata$species == \"Dog\"), ]\n```\n:::\n:::panel\n#### \"not one of [Dog, Cat]\"\n\nAnother clever little operator is the `%in%` operator, which asks whether something is _in_ a set of things. Unfortunately, we can't use `!%in%` to mean \"not in\", so we need to put the `!` right at the start of the condition:  \n\n```{r}\npetdata[!petdata$species %in% c(\"Cat\",\"Dog\"), ]\n```\n:::\n::::\n\n`r solend()`\n\n`r qbegin(qcounter())`\nCreate a new variable in the data, which contains the weights of all the animals, but rounded to the nearest kg. \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nTry looking up the help documentation for the function `round()`. Try playing with it in the console, e.g. `round(c(3.5, 4.257, 1.1111))`. You may find it helpful to look back at [1B #adding/changing-a-variable](01b_data.html#addingchanging-a-variable){target=\"_blank\"}.  \n\n- \"to the nearest kg\" would mean we want no decimal points. Note that `round()` has a _digits_ argument. e.g. `round(22.324, digits = 2)` and `round(22.324, digits = 1)` do different things.  \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n\nWe're wanting this variable as a new column in the data, so don't forget the `dataframe$newvariable <- ......` bit.  \n```{r}\npetdata$weight_rounded <- round(petdata$weight_kg)\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nTry giving the dataset to the function `summary()`. You'll get out some information on each of the variables. It is likely that you'll get more useful information for the variables containing information on the animal's weights than for those containing their names, breeds etc because these variables are vectors of \"characters\". We'll start to look more about different types of data next week.  \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nEasy to do!  \n```{r}\nsummary(petdata)\n```\n`r solend()`\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Simulating Dice\n\n`r qbegin(qcounter())`\nCopy the code from the lecture which creates a custom function called `dice()` (copied below).  \nBe sure to *run* the code (highlight it all with your cursor, and hit \"run\" in the top right, or press Ctrl/Cmd+Enter).  \n```{r}\ndice <- function(num = 1) {\n  sum(sample(1:6, num, replace=TRUE))\n}\n```\n\n`r qend()`\n\n<div style=\"border-radius: 5px; padding: 20px 20px 10px 20px; margin-top: 20px; margin-bottom: 20px; border: 1px solid #333333 !important;\">\n**What did that code do?**\n\nIn a sense, this code does *nothing*:  It won't give you any output when you run it.  What it is actually doing, though, is defining a *function* called `dice()`.  If you look at your *environment* panel (top right), you'll see `dice` appear when you run the code.\n  \nTo produce some output, we have to *call* the function `dice()` (by writing it into code:  `dice(4)`, for example).  `dice()` wants to be supplied with some information (in the *argument* `num`).  If no information is supplied, num will take a *default value* of `1`.  (So writing `dice()` is equivalent to writing `dice(1)`).\n\nWhat does `dice()` do with `num`?  It calls another function, `sample()`, with *3* arguments.  We didn't write `sample()`:  it's a function that's \"supplied with\" R.  To find out more about what `sample()` does:\n\n* click inside the brackets just after `sample()` in your R script;\n\n* press `TAB` (`⇥`), then `F1`\n\n* you should see some help appear in the bottom right-hand panel of RStudio.\n\nYou will find that \"`sample()` takes a sample ... from the elements of `x` ...\"  If you compare the code in RStudio to the code under \"Usage\" you'll see that where the help has `x`, we have `1:6`.  So what does `1:6` mean?  One way to find out is to open the **console** in RStudio (bottom left) and just type stuff in.  What happens when you type `1:6`?  What about `2:17`?  (What about `6:1`?)\n\n__Remember:__ The console is the place to \"try stuff out\" (don't worry, you can't break it). \n\nWhat you will discover is that `1:6` creates a *vector* (list of similar things, in this case numbers) of the numbers 1-6. The next bit of the `sample()` function is `size`. In the `dice()` function, the `num` passes down to the `size` of the `sample()`: Looking through the help, `size` is the number of items to choose.  So `sample(1:6, 1)` would choose one number from the numbers 1-6 at random; `sample(1:6, 3)` would choose 3, and so on.  The last argument, `replace=TRUE`, tells `sample()` what to do with a number once it's been picked:  Does it go 'back into the bag' to be picked again (`TRUE`) or not? (`FALSE`)?  \n\nAround the outside is `sum()` which simply sums the numbers on however many (`num`) dice you \"rolled\".  \n\nPutting it all together, our `dice()` function \"throws `num` dice\" by `sample()`ing from the numbers 1-6 `num` times, `replace`ing each number when it's been picked, and sums the numbers of all the dice.  \n\n</div>\n\n`r qbegin(qcounter())`\nUse the function you just made to 'roll a die' a few times. Check that it works like you expect.  \n\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\n\nYou just need to run `dice()` a few times. A single die means `num = 1`, which is the default.  \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW_SOLS, toggle=params$TOGGLE)`\n\n```{r}\ndice()\ndice()\ndice()\ndice()\n```\n\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nLook up the function `replicate()`. We can use it to do something in R lots of times! For instance, `replicate(20, 1+1)` will evaluate `1+1` twenty times.  \n\nUse `replicate()` to simulate 20 rolls of a single die, and store the results in an object in your environment. Give it an easily identifiable name.  \nWhat does each value in this object represent?  \n\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nrolls20 <- replicate(20, dice(num = 1))\nrolls20\n```\nEach value in `rolls20` represents the simulated roll of a single die. We roll our die, and get a `r rolls20[1]`, we roll it again and get `r rolls20[2]`, the third roll we get `r rolls20[3]`, and so on.. \n`r solend()`\n\n`r qbegin(qcounter())`\nCreate a barplot showing the frequency with which each number was landed on in the 20 rolls.\n\n::: {.callout-tip collapse=\"true\"}\n#### Hints\nThe functions `table()` and `barplot()` were used to do this in the lecture.  \n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nYour plots will look slightly different to these, because all of our dice are random!\n```{r}\n# We can get the frequency table using table()\ntable(rolls20)\n# Which we can then pass to the barplot() function:\nbarplot(table(rolls20))\n```\n`r solend()`\n\n`r qbegin(qcounter())`\nDo the same for 100 rolls, and then for 1,000. What do you notice?   \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nmorerolls <- replicate(100, dice(1))\nbarplot(table(morerolls))\n\nmorerolls2 <- replicate(1000, dice(1))\nbarplot(table(morerolls2))\n```\nThe more rolls we do of the dice, the flatter the graph becomes. This is because there is an equal probability of the die landing on any of the responses - there is a uniform probability.  \n`r solend()`\n\n\n`r qbegin(qcounter())`\nCopy the code below into your script and run it. It creates a new function called `wdice()` which simulates the rolling of `num` dice which are slightly weighted.  \n  \nRoll a single weighted die 20 times and plot the frequency distribution. Do the same for 100 and 1,000 rolls of a single die. Does a pattern emerge? At how many rolls?  \n```{r}\nwdice <- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n```\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n`r set.seed(38)`\n```{r}\nwdice <- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n\nwd <- replicate(20, wdice(1))\nbarplot(table(wd))\n\nwd <- replicate(1000, wdice(1))\nbarplot(table(wd))\n\nwd <- replicate(10000, wdice(1))\nbarplot(table(wd))\n```\n\nThe die is clearly weighted towards landing on 6. \nHowever, is 20 rolls enough to reliably observe this? In _our_ 20 rolls above, it landed on 3 quite a bit too (yours will be different)! The pattern becomes clearer after 1000 rolls.  \n\n`r solend()`\n\n`r qbegin(qcounter())`\nRemember, `wdice()` and `dice()` are really just relying on different functions, like `sample()`. Try playing around with `sample()` in the console again - what does the `prob = c(....)` bit do?   \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThe prob bit is defining the probabilities of observing each outcome - i.e. there is a 25% chance of rolling a 6.  \n`r solend()`\n\n`r qbegin(qcounter())`\nLet's try to modify the `wdice()` function. Edit the code for `wdice()` so that 50% of the time it lands on number 6.  \n\n::: {.callout-tip collapse=\"true\"}\n#### Hints \n\n- To test out your modified function, you will need to re-run the code which defines the function. When we use `wdice()` we use the function which is in our environment. If we want to edit the function, we need to then overwrite (or \"replace\"/\"reassign\") the object in our environment.  \n- We need to be careful to remember that the probability of different outcomes should sum to 1 (i.e., it's not possible to \"50% of the time land on 6\" as well as \"70% of the time land on 5\"!). \n\n:::\n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nwdice <- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.1,0.1,0.1,0.1,0.1,0.5)))\n}\n```\n\n`r solend()`\n\n\n`r qbegin(qcounter())`\nCan you observe the weighting in your new die (the one which 50% of the time lands on number 6) in only 20 rolls?  \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\n```{r}\nwd <- replicate(20, wdice(1))\nbarplot(table(wd))\n```\nThe die is very clearly weighted to land on 6. We can see this in just 20 rolls. Presumably it will become even clearer if we increased how many times we roll it.  \n\n`r solend()`\n\n  \n`r qbegin(qcounter())`\nConceptually, what can we learn from this toy example?    \n`r qend()`\n`r solbegin(show=params$SHOW, toggle=params$TOGGLE)`\nThe more highly weighted a die is, the less we have to roll it in order to observe that weighting.  \n`r solend()`\n\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>\n\n\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":["assets/toggling.html",{"text":"<link rel=\"stylesheet\" href=\"https://uoepsy.github.io/assets/css/ccfooter.css\" />\n"}],"number-sections":false,"output-file":"01_ex.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","toc_float":true,"code-annotations":"hover","link-citations":true,"theme":["united","assets/style-labs.scss"],"title":"Exercises: Intro R","params":{"SHOW_SOLS":false,"TOGGLE":true}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}