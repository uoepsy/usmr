{"title":"1B: More R - Basic Data Skills","markdown":{"yaml":{"title":"1B: More R - Basic Data Skills","link-citations":true,"params":{"SHOW_SOLS":true,"TOGGLE":true}},"headingText":"Vectors","containsRefs":false,"markdown":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nxaringanExtra::use_panelset()\n```\n\n<!-- __Reading time: 25 minutes__   -->\n\n:::lo\nThis reading:  \n\n- How does R store data?  \n- What can R _do_ with data?  \n- How can we use R to access and manipulate data?  \n\n:::\n\n\n\nWe've already seen how to assign a value to a name/symbol using `<-`. However, we've only seen how to assign a single number, e.g:   \n```{r}\nx <- 5 # assign the value 5 to the name \"x\"\nx # print the object named \"x\"\n```\n\nIn almost all cases, the data we are working with will be more than just an individual number. We might have measured the IQ of 20 different people, in which case we have 20 numbers representing IQ scores. More commonly, we work with 2-Dimensional arrays of numbers, e.g. each row is an observation, and each column represents something we have measured.  \n\nTo store a sequence of numbers into R, we can _combine_ the values using `c()` and give the sequence a name. A sequence of elements all of the same type is called a **vector**.  \nAs before, to view the stored content, we simply type the name of the vector:   \n\n```{r}\nmyfirstvector <- c(1, 5, 3, 7)\nmyfirstvector\n```\n\nWe can perform arithmetic operations on each value of the vector.  \nFor example, to add five to each entry:\n```{r}\nmyfirstvector + 5\n```\n\nTo reiterate, vectors are sequences of elements **all of the same type**. \nA vectors does not have to be a sequence of numbers, it could be a sequence of words, such as the names of different types of animals.  \nWords need to be written inside quotations, e.g. \"anything\", and instead of being of numeric type, we say they are characters.\n\n```{r}\nwordsvector <- c(\"cat\", \"dog\", \"parrot\", \"peppapig\")\nwordsvector\n```\n\n:::rtip\nYou can use either double-quote or single-quote:\n```{r}\nc(\"cat\", \"dog\", \"parrot\", \"horse\")\nc('cat', 'dog', 'parrot', 'horse')\n```\n:::\n\nIt does not make sense to add a number to words, hence some operations like addition and multiplication are only defined on vectors of numeric type. If you make a mistake, R will warn you with a red error message.\n\n```{r}\n#| eval: false\nwordsvector + 5\n```\n<p style=\"color:red\">\nError in wordsvector + 5 : non-numeric argument to binary operator\n</p>\n\nFinally, it is important to notice that if you combine together in a vector a number and a word, R will transform all elements to be of the same type. \nWhy? Recall: vectors are sequences of elements **all of the same type**.\nTypically, R chooses the most general type between the two. \nIn the example below, it makes everything a __character__ (letters) (note the `\"` around the 4), as it is unclear how to transform \"cat\" into a number! \n\n```{r}\nmysecondvector <- c(4, \"cat\")\nmysecondvector\n```\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Dataframes\n\nNow we have seen how we can store a set of values into a vector in R, we can move to thinking about data in a more intuitive way.  \n\nTypically, when we imagine \"collecting data\", we imagine asking a sample of people a bunch of questions (e.g. we might ask them their height, age, hair colour etc). So we could have a vector of heights, another vector of ages, and another of hair colours. \n\nRather than storing all of these as separate objects, it makes a lot more sense to organise them in two dimensions, very much like a spreadsheet. In R, a collection of vectors is termed a \"dataframe\"\n\n:::sticky\n**Dataframes** are simply collections of vectors of the same length.   \n\nTypically, all vectors are ordered to ensure that a given row represents the characteristics of a single observation\n\n![](images/installing_intro/dataframe.jpg)\n:::\n\nFor instance, we could imagine a dataframe containing information on the name and birth year of each member of The Beatles. The easiest way to think of this would be to have a row for each Beatle, and a column for each of their names and their birth-years. Note that each vector contains all the same type of information (the names are all strings of characters, and the birth years are all numbers).  \n\n:::rtip\nWe _can_, if we want to, create a dataframe inside R, by giving it a collection of vectors:  \n```{r}\ndata.frame(\n  name = c(\"john\",\"paul\",\"george\",\"ringo\"),\n  birth_year = c(1940,1942,1943,1940)\n)\n```\n:::\n\nWhile we can manually create data like above, more often we will need to _import_ into R some data which has been created elsewhere (like in excel, or by some software which is used to present participants with experiments, or collect responses to questionnaires).  \n\nLet's suppose we have instead entered data in something like Microsoft Excel, or LibreOffice Calc, or whatever spreadsheet software we have available (@fig-excel).  \n```{r}\n#| label: fig-excel\n#| echo: false\n#| fig-cap: \"Data entered in spreadsheet software like Microsoft Excel\"\n#| out-width: \"49%\"\nknitr::include_graphics(\"images/installing_intro/create_data.png\")\n```\nWe can then save that data as a __.csv__ file. Although R can read data when it's saved in Microsoft/LibreOffice formats, the simplest, and most universal way to save data is as simple text, with the values separated by some character. The __.csv__ format stands for __comma separated values.__^[To save as .csv in Microsoft Excel, we go to __File > Save as__, and then in the Save as Type box, choose to save the file as __CSV (Comma delimited)__]  \n\nBack in RStudio, we need to have a way of getting the information contained in that file _into_ R's environment, so that we can do things with it. We can do this by using the `read.csv()` function, and directing it to the file you just saved.  \n\n:::hints\n_note: if you are using RStudio on a server - i.e. accessing it via a web-browser - then you will need to upload the file you just saved to the server (see the \"upload\" button in the Files tab in the bottom right pane of R)._\n:::\n\n```{r}\n#| eval: false\nread.csv(\"data_from_excel.csv\")\n```\n```{r}\n#| echo: false\nread.csv(\"https://uoepsy.github.io/data/data_from_excel.csv\")\n```\n\n:::rtip\n__Helpful tip__   \n\nIf you have your text-cursor inside the quotation marks, and press the tab key on your keyboard, it will show you the files inside your project. You can then use the arrow keys to choose between them and press Enter to add the code.  \n\n:::\n\n\nThere's one more thing that we need to do, and that is to actually store this information in our environment. Currently, it is just printing out the data. We need to assign it a name:  \n```{r}\n#| echo: false\nbeatles <- read.csv(\"https://uoepsy.github.io/data/data_from_excel.csv\")\n```\n```{r}\n#| eval: false\nbeatles <- read.csv(\"data_from_excel.csv\")\n```\n\nWe should now have something called \"beatles\" which is visible in the _environment_ pane of RStudio (top right).  \n\nAnd we can print it out by simply invoking its name:  \n```{r}\nbeatles\n```\n\nAnd we can do things such as ask R how many rows and columns there are (asking for the \"dimensions\" using `dim()`):\n```{r}\ndim(beatles)\n```\n\nThis says that there are 4 members of the Beatles, and for each we have 2 measurements (name and birth-year).\n\nTo get more insight into what the data actually are, you can either use `str()` to see the structure:\n```{r}\nstr(beatles)\n```\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Functions  \n\nWe've just seen some use of `c()`, `read.csv()`, `dim()` and `str()`.  \n\nThere's something that all these things have in common - they are __functions.__  \n\n:::sticky\n__Functions__ perform specific operations / transformations in computer programming.  \n  \nThey can have __inputs__ and __outputs__. For example, `dim()` takes some data you have stored in R as its __input__, and gives the dimensions of the data as its __output__.\n:::\n\n\nThere are loads and loads of functions in R. This is really where the power lies. Here is a demonstration of a couple of basic ones. Hopefully you can guess what they are doing?    \n```{r}\nmyfirstvector <- c(1, 5, 3, 7)\nsum(myfirstvector)\nmean(myfirstvector)\n```\n\n:::rtip\n__Getting Help on Functions__\n\nAlmost all functions in R will have associated documentation describing what they do. If we don't know what a function does, we can read the help docs by typing a question mark and then the function name, and running it in R. `?mean` will bring up a little help page in the bottom-right pane of RStudio\n\n:::\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# R Packages\n\nAlongside the basic installation of R and RStudio, there are many add-on packages which the R community create and maintain. The thousands of packages are part of what makes R such a powerful and useful tool - there is a package for almost everything you could want to do in R.  \n\n:::sticky\n__Packages__ are bundles of functions, code, data, documentation, etc.  \n\nTo install a package onto our computer we use `install.packages(\"package name\")`.  \nThen, any time that we want to use that package we just need to load it into our current R session with `library(package name)`.   \n\n```{r}\n#| label: fig-libraries\n#| echo: false\n#| out.width: \"60%\"\n#| fig-cap: \"Source: [@visnut](https://twitter.com/visnut/status/1248087845589274624)\"\nknitr::include_graphics(\"images/installing_intro/libraries.jpeg\")\n```\n:::\n\n:::frame\n<center>__Example: Installing and using a package__</center>    \n\nHere we're going to install a silly package called __cowsay__:  \n\nWrite this code **directly into the console** and run it:  \n```{r}\n#| eval: false\ninstall.packages(\"cowsay\")\n```\nThis spits out a lot of messages, before (hopefully) ending with something similar to: \n\n<p style=\"color:red;margin-left:30px;\">\n...<br>\n...<br>\n\\* DONE (cowsay)<br>\n<br>\nThe downloaded source packages are in<br>\n\t\\‘/tmp/RtmpIRbMnh/downloaded_packages\\’\n</p>\n<span style=\"color:blue;margin-left:30px;\">\\></span>\n\nNow that we've installed it, to use it we just need to load it into our R session, by using `library()`.  \n**Back in your script**, use this code to load the package:\n```{r}\nlibrary(cowsay)\n```\n\nWhich enables us to now use some of the functionality that is in that package, such as the `say()` function, which makes some silly art out of punctuation symbols:  \n```{r}\nsay(\"Welcome to the USMR course!\", by = \"owl\")\n```\n\n\n:::\n\n\n<div style=\"max-width:49%;display:inline-block;vertical-align:middle\">\nIt's good practice to have all the packages you use for an analysis loaded at the top of your script.  \n  \nA typical structure for an R script is to:  \n\n1. load all the required packages\n2. read in the data\n3. conduct your analysis    \n\n</div><div style=\"max-width:49%;display:inline-block;vertical-align:top\">\n```{r}  \n#| label: fig-packload\n#| echo: false\n#| fig-cap: \"Typical script layout\"\nknitr::include_graphics(\"images/installing_intro/packload.png\")\n```\n</div>\n\n:::rtip\n\nWe will be using these packages quite a lot in this course, so you might want to install them now, by writing `install.packages(\"PACKAGE_NAME\")` in your console:  \n\n- tidyverse\n- patchwork\n\nIt might take a few minutes for them to install, so just sit back and take a breather. \n\n\n:::\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Checkpoint - where are you writing your code?  \n\nHopefully, if you are following along with us, you are writing almost all of your code in a script, and not in the console. __Remember: Code that you write in the console is *not* saved__.  \n\nHowever, when we installed packages above, we suggested you write directly into the console.  \nWhy? Because sometimes, for certain things, we don't want to keep a record of that bit of code. We only ever want to install a package __once__, because after that first time it's going to be installed on our computer, so we're not going to need to run `install.packages(\"cowsay\")` again. \n\nConsider the example code below. The 2nd, 3rd, and 5th lines do absolutely nothing to our computations with x and y. They are just for our own workings. Because lines like this have no consequences on code below, our R script will have the same end-point with and without those line.  \n```{r}\n#| eval: false\nx <- 4\nx\n4*33\ny <- 6/100\n?mean\nanswer <- x*y\n```\n\nIn general, the vast majority of the code you write will be in the script, and you will only use the console occasionally for quick commands that aren't doing anything to change our analysis. For example, we don't want to keep **re-**installing packages over and over again (each time we run a script), so we'll tend to use `install.packages()` in the console. Similarly, when we look up the help documentation for a function (e.g. by running `?mean`), we type that into the console, and not a script.  \n\nThis will become second nature as you use R more and more, but it's helpful to get into good habits early on.   \n\n:::sticky\n__Rules of thumb__  \n\n- If a line of code changes something in the environment, then that code should be written in the script.  \n- If you clear your environment, restart R, and run your script all at once (see the section on ['Good Habits' in Section 1A](01a_R.html#Good_Habits){target=\"_blank\"}), it shouldn't produce errors and should get you back to your current place  \n\nIf we don't follow the above suggestions, then our work will not be **reproducible** (e.g. you send your script to someone and they will get a different answer from you when they run it). \n:::\n\n\n\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Basic Data Wrangling   \n\n\n\nNow that we've started to learn about vectors and dataframes, we're going to look at reading in a bigger dataset, exploring some of the variables, and the syntax we can use to access and edit certain bits of the data.    \n\nFirst we'll read in our data:  \n```{r}\nstarwars2 <- read.csv(\"https://uoepsy.github.io/data/starwars2.csv\")\n```\n\n:::rtip\n__Reading data from a URL__ \n\nNote that when you have a url for some data (e.g. [this](https://raw.githubusercontent.com/uoepsy/data/master/starwars2.csv)) you can read it in directly by giving functions like `read.csv()` the url inside quotation marks. \n:::\n\nThe data contains information on various characteristics of characters from Star Wars. \nWe can print out the top of the data by using the `head()` function which displays the first six rows of the data by default. You could change this by saying, for example, `head(data, n = 10)`:\n```{r}\nhead(starwars2, n = 10)\n```\n\n_(Don't worry about the_ NAs _for now, they are just how R tells you an entry is missing, i.e. Not Available.)_  \n\n:::rtip\nTry clicking on the data in your __environment__ (the top right window of RStudio). It will open the data in a tab in the editor window - this is another way of looking at the data, more like you would in spreadsheet software like Microsoft Excel.  \n\nThis can be time-consuming and awkward if your data file is big (i.e. lots of columns, or lots of rows, or both!).\n:::\n\nWe can take a look at how big the data is (the dimensions), using `dim()`\n```{r}\ndim(starwars2)\n```\n\nWe can see that there are `r nrow(starwars2)` rows and `r ncol(starwars2)` columns. In this dataset, each Star Wars character is an __observational unit__, and there are 6 __variables__ (things which vary between units) such as their _height_, _species_, _homeworld_, etc.  \n\n:::sticky\n__observations and variables__\n\nThe individual entities on which data are collected are called __observational units__ or __cases__. Often (but not always), these equate to the rows of a dataset.  \n\nA __variable__ is any characteristic that varies from observational unit to observational unit (these are often the columns of the dataset)\n:::\n\n## Accessing subsets of data\n\nWhat if we want to extract certain subsections of our dataset, such as specific observational units or variables? \nThis is where we learn about two important bits of R code used to access parts of data - the dollar sign `$`, and the square brackets `[]`.  \n\n:::rtip\n__The dollar sign $__  \n  \nThe dollar sign allows us to extract a specific variable from a dataframe.\nFor instance, we can pull out the variable named \"eye_color\" in the data, by using `$eye_color` after the name that we gave our dataframe.  \n\nRemember that each variable in a dataframe is a vector (a set of values). Once extracted, we will have a vector and not a dataframe.  \n```{r}\nstarwars2$eye_color\n```\n:::\n\n\n\n:::rtip\n__The square brackets []__  \n  \nSquare brackets are used to do what is known as __indexing__ (finding specific entries in your data).  \nWe can retrieve bits of data by identifying the $i^{th}$ entry(s) inside the square brackets, for instance: \n\n```{r}\n# assign the numbers 10, 20 ... 100 to the name \"somevalues\"\nsomevalues <- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)\n\n# pull out the 3rd entry\nsomevalues[3]\n```\n\nIn the above example, we have a __vector__ (a single sequence of values), and so we can retrieve entries with the syntax:\n<center> \n**vector[entry]**\n</center>\n<br>\nIn a __dataframe__ we have an extra dimension - we have rows _and_ columns. Using square brackets with a dataframe needs us to specify both:  \n<center>\n**dataframe[rows, columns]**\n</center>\n:::\n\nLet's look at some examples: \n\n::: {.panelset}\n\n::: {.panel}\n#### Examples of Indexing\n\n1. Specifying row number and column number:  \n```{r}\n#| eval: false\n\n# first row, fourth column\nstarwars2[1, 4]\n# tenth row, first column\nstarwars2[10, 1]\n```\n2. If we leave either rows or columns blank, then we will get out __all__ of them:\n```{r}\n#| eval: false\n# tenth row, all columns\nstarwars2[10, ]\n# all rows, 2nd column\nstarwars2[ , 2]\n```\n3. There are is another way to identify column - we can use the name in quotation marks:  \n```{r}\n#| eval: false\n# first row, \"species\" column\nstarwars2[1, \"species\"]\n```\n4. We can also ask for multiple rows, or multiple columns, or both! To do that, we use `c()`:\n```{r}\n#| eval: false\n# the 1st AND the 6th rows, and the 1st AND 3rd columns\nstarwars2[c(1,6), c(1,3)] \n```\n5. And we can specify a sequence using the colon, `from:to`: ^[The colon operator, `from:to`, creates a vector from the value `from` to the value `to` in steps of 1.  \nFor instance, `1:6` is the same as `c(1,2,3,4,5,6)`.]\n\n```{r}\n#| eval: false\n# FROM the 1st TO the 6th row, all columns\nstarwars2[1:6, ] \n```\n\n6. We can even use the two accessors in combination:^[Note: When we do this, we don't have the comma inside the square brackets.  \nWhen we use the `$` to pull out a variable, such as `starwars2$name`, we no longer have a dataframe.  \n`starwars2$name` doesn't have rows and columns, it just has a series of values - _it's a vector!_  \nSo when you are using `[]` with a __vector__ (1 dimension) rather than a __dataframe__ (2 dimensions), you don't specify `[rows, columns]`, but simply `[entry]`.] \n```{r}\n#| eval: false\n# extract the variable called \"name\" and show the 20th entry\nstarwars2$name[20]  \n```\n\n\n:::\n::: {.panel}\n#### Show me the output\n\n1. Specifying row number and column number:  \n```{r}\n# first row, fourth column\nstarwars2[1, 4]\n# tenth row, first column\nstarwars2[10, 1]\n```\n2. If we leave either rows or columns blank, then we will get out __all__ of them:\n```{r}\n# tenth row, all columns\nstarwars2[10, ]\n# all rows, 2nd column\nstarwars2[ , 2]\n```\n3. There are is another way to identify column - we can use the name in quotation marks:  \n```{r}\n# first row, \"species\" column\nstarwars2[1, \"species\"]\n```\n4. We can also ask for multiple rows, or multiple columns, or both! To do that, we use `c()`:\n```{r}\n# the 1st AND the 6th rows, and the 1st AND 3rd columns\nstarwars2[c(1,6), c(1,3)] \n```\n5. And we can specify a sequence using the colon, `from:to`:  \n```{r}\n# FROM the 1st TO the 6th row, all columns\nstarwars2[1:6, ] \n```\n6. We can even use the two accessors in combination: \n```{r}\n# extract the variable called \"name\" and show the 20th entry\nstarwars2$name[20]  \n```\n:::\n    \n:::\n\n:::sticky\n__The dollar sign $__ \n\nUsed to extract a variable from a dataframe:   \n\n+ `dataframe$variable`\n\n__The square brackets []__\n\nUsed to extract parts of an R object by identifying rows and/or columns, or more generally, \"entries\". Left blank will return all. \n\n+ `vector[entries]`\n+ `dataframe[rows, columns]`\n:::\n\n## Accessing by a condition \n\nWe can also do something really useful, which is to access all the entries in the data for which _a specific condition_ is true.  \n\nLet's take a simple example to start:\n```{r}\nsomevalues <- c(10, 10, 0, 20, 15, 40, 10, 40, 50, 35)\n```\n\nTo only select values which are greater than 20, we can use:\n```{r}\nsomevalues[somevalues > 20]\n```\n\n:::frame\n__Unpacking:__ `somevalues[somevalues > 20]`  \n<br>\nFirst, let's look at what `somevalues > 20` does. It returns TRUE for the entries of `somevalues` which are greater than 20, and FALSE for the entries of `somevalues` that are not (that is, which are less than, or equal to, 20. \n\nThis statement `somevalues > 20` is called the __condition__.    \n```{r}\nsomevalues > 20\n```\n\nNow consider putting that sequence of TRUEs and FALSEs inside the square brackets in `somevalues[]`.\nThis returns only the entries of `somevalues` for which the condition is `TRUE`.  \n```{r}\nsomevalues[c(FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE)]\n```\n\nSo what we're doing is using a __condition__ inside the square brackets to return all the values for which that condition is TRUE.\n\nAnd we're being super efficient, because we don't want to write out TRUEs and FALSEs all day, so we just give the conditional question inside the brackets directly:  \n```{r}\nsomevalues[somevalues > 20]\n```\n\n:::\n\n<br>\nWe can extend this same logic to a dataframe.\nLet's suppose we want to access all the entries in our Star Wars data who have the value \"Droid\" in the _species_ variable.\nTo work out how to do this, we first need a line of code which defines our __condition__ - one which returns `TRUE` for each entry of the _species_ variable which is \"Droid\", and `FALSE` for those that are not \"Droid\".  \n\nWe can use the dollar sign to pull out the _species_ variable: \n```{r}\nstarwars2$species\n```\n\nAnd we can ask R whether each value __is equal to__ \"Droid\"  \n\n:::hints\n*Remember:* in R, we ask whether something __is equal to__ something else by using a double-equals, `==`. A single equal sign would be wrong, as it denotes assignment.\n:::\n\n```{r}\nstarwars2$species == \"Droid\"\n```\n\nFinally, we can use this condition inside our square brackets to access the entries of the data for which this condition is TRUE:\n```{r}\n# I would read the code below as: \n# \"In the starwars2 dataframe, give me all the rows \n# for which the condition starwars2$species==\"Droid\"\n# is TRUE, and give me all the columns.\"\n\nstarwars2[starwars2$species == \"Droid\", ]\n```\n\n<!-- `r optbegin('Optional: with().', FALSE)` -->\n<!-- A useful function is `with()`. This creates a \"container\" where the variables of the dataframe are available to R within the `with()` parentheses without the need to use `$`: -->\n<!-- ```{r} -->\n<!-- with(starwars2, starwars2[species == \"Droid\", ]) -->\n<!-- ``` -->\n<!-- `r optend()` -->\n\n## More complex conditions\n\nThinking back to Reading 1A when we first introduced R, we [talked briefly about \"logical operators\"](01a_R.html#R_is_a_calculator){target=\"_blank\"}. Specifically, the operators `&`, `|`, and `!` (for \"and\", \"or\",\" and \"not\"), will come in handy now.  \n\nFor instance, we can now extract all those in the dataset which are humans _and_ taller than 190cm:  \n```{r}\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$species==\"Human\" AND starwars2$height > 190 are TRUE, \n# and give me all the columns.\"\nstarwars2[starwars2$species == \"Human\" & starwars2$height > 190, ]\n```\nOr we can extract all those in the dataset which are _either_ droids _or_ ewoks: \n```{r}\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$species==\"Droid\" OR starwars2$species==\"Ewok\" is TRUE, \n# and give me all the columns.\"\nstarwars2[starwars2$species == \"Droid\" | starwars2$species == \"Ewok\", ]\n```\n \n\n## Editing specific entries {-}  \n\nNow that we've seen a few ways of _accessing_ sections of data, we can learn how to edit them! \nOne of the most common reasons you will need to modify entries in your data is in __data cleaning__. This is the process of identifying incorrect / incomplete / irrelevant data, and replacing / modifying / deleting them. \n\nAbove, we looked at the subsection of the data where the _species_ variable had the entry \"Droid\". Some of you may have noticed earlier that we had some data on C3PO. Are they not also a droid? \n\n<center>\n![](images/categorical/c3po.png)  \n</center>\n\n(Looks pretty Droid-y to me! _disclaimer: I know nothing about Star Wars_ &#128578; )\n\nJust as we saw above how to _access_ specific entries, e.g.: \n```{r}\n# 2nd row, all columns\nstarwars2[2, ]\n# 2nd row, 6th column (the \"species\" column)\nstarwars2[2,6]\n```\n\nWe can change these by __assigning them a new value__ (remember the `<-` symbol). In doing so, we _overwrite_^[you could think of this as _replacing_ / _overwriting_ / _reassigning_ the entry] the entry in the 2nd row and 6th column of the data (`starwars2[2,6]`) with the value \"Droid\". \n```{r}\n# C3PO is a droid, not a human\nstarwars2[2,6] <- \"Droid\"\n# Look at the 2nd row now -\n# the entry in the \"species\" column has changed:\nstarwars2[2, ]\n```\n\n## Editing entries via a condition {-}  \n\nWe saw above how to access parts of data by means of a __condition__, with code such as:\n\n```{r}\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$homeworld==\"Naboo\" is TRUE, and give me all the columns.\"\nstarwars2[starwars2$homeworld==\"Naboo\", ]\n```\n\nWhat if we wanted to modify it so that every character from \"Naboo\" was actually of species \"Nabooian\"?  \n\nWe can do that in a number of ways, all of which do the same thing - namely, they access parts of the data and assign them the new value \"Nabooian\".  \n\nThe lines of code below all do exactly that, in different ways. We've also tried to give a way of interepreting each line. \n\n```{r}\n# In the starwars2 data, give the rows for which condition \n# starwars2$homeworld==\"Naboo\" is TRUE, and select only the \"species\" column. \n# Assign to these selected entries the value \"Nabooian\".\nstarwars2[starwars2$homeworld==\"Naboo\", \"species\"] <- \"Nabooian\"\n```\n\n```{r}\n# In the starwars2 data, give the rows for which condition \n# starwars2$homeworld==\"Naboo\" is TRUE, and select only the 6th column. \n# Assign to these selected entries the value \"Nabooian\".\nstarwars2[starwars2$homeworld==\"Naboo\", 6] <- \"Nabooian\"\n```\n\n```{r}\n# Extract the species variable from the starwars2 data (it's a vector).\n# Pick the entries for which the condition starwars2$homeworld==\"Naboo\" is TRUE.\n# Assign to these selected entries the value \"Nabooian\".\nstarwars2$species[starwars2$homeworld==\"Naboo\"] <- \"Nabooian\"\n```\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: a little extra... \nIn a similar way, we could have changed C-3PO to a Droid without ever having to know what row of the data they were in! \n```{r}\n# for the row(s) where the name variable in starwars2\n# is equal to \"C-3PO\", in the species variable we assign\n# that entry to be \"Droid\"\nstarwars2[starwars2$name==\"C-3PO\", \"species\"] <- \"Droid\"\n```\n:::\n\n## Adding/Changing a variable\n\nAnother thing we might want to do is change a whole variable (a whole column) in some way.  \nThe logic is exactly the same, for instance, we can take the variable \"height\" from the dataframe \"starwars2\", dividing it by 100 via `starwars2$height / 100`, and then assign the result to the same variable name in the data, i.e. we overwrite the column: \n```{r}\nstarwars2$height <- starwars2$height / 100\n```\n\nWe could instead have added a _new column_ named \"height_m\" with those values if we did not want to overwrite \"height\":\n```{r}\n#| eval: false\nstarwars2$height_m <- starwars2$height / 100\n```\nThis would have left the \"height\" variable as-is, and created a new one called \"height2\" which was the values in \"height\" divided by 100. \n\n\n## Removing rows or columns\n\nLastly, we might want to change the data by removing a row or a column.\nAgain, the logic remains the same, in that we use `<-` to assign the edited data to a name (either a new name, thus creating a new object, or an existing name, thereby _overwriting_ that object).  \n  \nFor instance, notice that the 35th and 75th rows of our data probably aren't a valid observation - I'm reasonably sure that Marge and Homer Simpson never appeared in Star Wars:\n```{r}\nstarwars2[c(35,75), ]\n```\n\nWe can remove a certain row(s) by using a minus sign `-` inside the square brackets \n```{r}\n#| eval: false\n# everything minus the 75th row\nstarwars2[-75, ]\n# everything minus the (35th and 75th rows)\nstarwars2[-c(35, 75), ]\n```\n\nAnd we can simply _re-use_ the name \"starwars2\" to overwrite the data and make this change take effect (rather than just print out the result, which the code above did):\n```{r}\nstarwars2 <- starwars2[-c(35, 75), ]\n```\n(now, in the __environment__ pane of Rstudio, the object named \"starwars2\" will say 73 observations, rather than 75, which it had before - we've removed the 2 rows)   \n\n<br>\nThe same logic applies for columns:\n```{r}\n# Create a new object called \"anonymous_starwars2\" and assign it \n# to the values which are the \"starwars2\" dataframe minus the \n# 1st column (the \"name\" column):\nanonymous_starwars2 <- starwars2[, -1]\n# dimensions of our initial data\ndim(starwars2)\n# the data we just assigned has one fewer columns\ndim(anonymous_starwars2)\n```\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>\n\n\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>\n","srcMarkdownNoYaml":"\n\n```{r}\n#| label: setup\n#| include: false\nsource('assets/setup.R')\nlibrary(xaringanExtra)\nxaringanExtra::use_panelset()\n```\n\n<!-- __Reading time: 25 minutes__   -->\n\n:::lo\nThis reading:  \n\n- How does R store data?  \n- What can R _do_ with data?  \n- How can we use R to access and manipulate data?  \n\n:::\n\n\n# Vectors  \n\nWe've already seen how to assign a value to a name/symbol using `<-`. However, we've only seen how to assign a single number, e.g:   \n```{r}\nx <- 5 # assign the value 5 to the name \"x\"\nx # print the object named \"x\"\n```\n\nIn almost all cases, the data we are working with will be more than just an individual number. We might have measured the IQ of 20 different people, in which case we have 20 numbers representing IQ scores. More commonly, we work with 2-Dimensional arrays of numbers, e.g. each row is an observation, and each column represents something we have measured.  \n\nTo store a sequence of numbers into R, we can _combine_ the values using `c()` and give the sequence a name. A sequence of elements all of the same type is called a **vector**.  \nAs before, to view the stored content, we simply type the name of the vector:   \n\n```{r}\nmyfirstvector <- c(1, 5, 3, 7)\nmyfirstvector\n```\n\nWe can perform arithmetic operations on each value of the vector.  \nFor example, to add five to each entry:\n```{r}\nmyfirstvector + 5\n```\n\nTo reiterate, vectors are sequences of elements **all of the same type**. \nA vectors does not have to be a sequence of numbers, it could be a sequence of words, such as the names of different types of animals.  \nWords need to be written inside quotations, e.g. \"anything\", and instead of being of numeric type, we say they are characters.\n\n```{r}\nwordsvector <- c(\"cat\", \"dog\", \"parrot\", \"peppapig\")\nwordsvector\n```\n\n:::rtip\nYou can use either double-quote or single-quote:\n```{r}\nc(\"cat\", \"dog\", \"parrot\", \"horse\")\nc('cat', 'dog', 'parrot', 'horse')\n```\n:::\n\nIt does not make sense to add a number to words, hence some operations like addition and multiplication are only defined on vectors of numeric type. If you make a mistake, R will warn you with a red error message.\n\n```{r}\n#| eval: false\nwordsvector + 5\n```\n<p style=\"color:red\">\nError in wordsvector + 5 : non-numeric argument to binary operator\n</p>\n\nFinally, it is important to notice that if you combine together in a vector a number and a word, R will transform all elements to be of the same type. \nWhy? Recall: vectors are sequences of elements **all of the same type**.\nTypically, R chooses the most general type between the two. \nIn the example below, it makes everything a __character__ (letters) (note the `\"` around the 4), as it is unclear how to transform \"cat\" into a number! \n\n```{r}\nmysecondvector <- c(4, \"cat\")\nmysecondvector\n```\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Dataframes\n\nNow we have seen how we can store a set of values into a vector in R, we can move to thinking about data in a more intuitive way.  \n\nTypically, when we imagine \"collecting data\", we imagine asking a sample of people a bunch of questions (e.g. we might ask them their height, age, hair colour etc). So we could have a vector of heights, another vector of ages, and another of hair colours. \n\nRather than storing all of these as separate objects, it makes a lot more sense to organise them in two dimensions, very much like a spreadsheet. In R, a collection of vectors is termed a \"dataframe\"\n\n:::sticky\n**Dataframes** are simply collections of vectors of the same length.   \n\nTypically, all vectors are ordered to ensure that a given row represents the characteristics of a single observation\n\n![](images/installing_intro/dataframe.jpg)\n:::\n\nFor instance, we could imagine a dataframe containing information on the name and birth year of each member of The Beatles. The easiest way to think of this would be to have a row for each Beatle, and a column for each of their names and their birth-years. Note that each vector contains all the same type of information (the names are all strings of characters, and the birth years are all numbers).  \n\n:::rtip\nWe _can_, if we want to, create a dataframe inside R, by giving it a collection of vectors:  \n```{r}\ndata.frame(\n  name = c(\"john\",\"paul\",\"george\",\"ringo\"),\n  birth_year = c(1940,1942,1943,1940)\n)\n```\n:::\n\nWhile we can manually create data like above, more often we will need to _import_ into R some data which has been created elsewhere (like in excel, or by some software which is used to present participants with experiments, or collect responses to questionnaires).  \n\nLet's suppose we have instead entered data in something like Microsoft Excel, or LibreOffice Calc, or whatever spreadsheet software we have available (@fig-excel).  \n```{r}\n#| label: fig-excel\n#| echo: false\n#| fig-cap: \"Data entered in spreadsheet software like Microsoft Excel\"\n#| out-width: \"49%\"\nknitr::include_graphics(\"images/installing_intro/create_data.png\")\n```\nWe can then save that data as a __.csv__ file. Although R can read data when it's saved in Microsoft/LibreOffice formats, the simplest, and most universal way to save data is as simple text, with the values separated by some character. The __.csv__ format stands for __comma separated values.__^[To save as .csv in Microsoft Excel, we go to __File > Save as__, and then in the Save as Type box, choose to save the file as __CSV (Comma delimited)__]  \n\nBack in RStudio, we need to have a way of getting the information contained in that file _into_ R's environment, so that we can do things with it. We can do this by using the `read.csv()` function, and directing it to the file you just saved.  \n\n:::hints\n_note: if you are using RStudio on a server - i.e. accessing it via a web-browser - then you will need to upload the file you just saved to the server (see the \"upload\" button in the Files tab in the bottom right pane of R)._\n:::\n\n```{r}\n#| eval: false\nread.csv(\"data_from_excel.csv\")\n```\n```{r}\n#| echo: false\nread.csv(\"https://uoepsy.github.io/data/data_from_excel.csv\")\n```\n\n:::rtip\n__Helpful tip__   \n\nIf you have your text-cursor inside the quotation marks, and press the tab key on your keyboard, it will show you the files inside your project. You can then use the arrow keys to choose between them and press Enter to add the code.  \n\n:::\n\n\nThere's one more thing that we need to do, and that is to actually store this information in our environment. Currently, it is just printing out the data. We need to assign it a name:  \n```{r}\n#| echo: false\nbeatles <- read.csv(\"https://uoepsy.github.io/data/data_from_excel.csv\")\n```\n```{r}\n#| eval: false\nbeatles <- read.csv(\"data_from_excel.csv\")\n```\n\nWe should now have something called \"beatles\" which is visible in the _environment_ pane of RStudio (top right).  \n\nAnd we can print it out by simply invoking its name:  \n```{r}\nbeatles\n```\n\nAnd we can do things such as ask R how many rows and columns there are (asking for the \"dimensions\" using `dim()`):\n```{r}\ndim(beatles)\n```\n\nThis says that there are 4 members of the Beatles, and for each we have 2 measurements (name and birth-year).\n\nTo get more insight into what the data actually are, you can either use `str()` to see the structure:\n```{r}\nstr(beatles)\n```\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Functions  \n\nWe've just seen some use of `c()`, `read.csv()`, `dim()` and `str()`.  \n\nThere's something that all these things have in common - they are __functions.__  \n\n:::sticky\n__Functions__ perform specific operations / transformations in computer programming.  \n  \nThey can have __inputs__ and __outputs__. For example, `dim()` takes some data you have stored in R as its __input__, and gives the dimensions of the data as its __output__.\n:::\n\n\nThere are loads and loads of functions in R. This is really where the power lies. Here is a demonstration of a couple of basic ones. Hopefully you can guess what they are doing?    \n```{r}\nmyfirstvector <- c(1, 5, 3, 7)\nsum(myfirstvector)\nmean(myfirstvector)\n```\n\n:::rtip\n__Getting Help on Functions__\n\nAlmost all functions in R will have associated documentation describing what they do. If we don't know what a function does, we can read the help docs by typing a question mark and then the function name, and running it in R. `?mean` will bring up a little help page in the bottom-right pane of RStudio\n\n:::\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# R Packages\n\nAlongside the basic installation of R and RStudio, there are many add-on packages which the R community create and maintain. The thousands of packages are part of what makes R such a powerful and useful tool - there is a package for almost everything you could want to do in R.  \n\n:::sticky\n__Packages__ are bundles of functions, code, data, documentation, etc.  \n\nTo install a package onto our computer we use `install.packages(\"package name\")`.  \nThen, any time that we want to use that package we just need to load it into our current R session with `library(package name)`.   \n\n```{r}\n#| label: fig-libraries\n#| echo: false\n#| out.width: \"60%\"\n#| fig-cap: \"Source: [@visnut](https://twitter.com/visnut/status/1248087845589274624)\"\nknitr::include_graphics(\"images/installing_intro/libraries.jpeg\")\n```\n:::\n\n:::frame\n<center>__Example: Installing and using a package__</center>    \n\nHere we're going to install a silly package called __cowsay__:  \n\nWrite this code **directly into the console** and run it:  \n```{r}\n#| eval: false\ninstall.packages(\"cowsay\")\n```\nThis spits out a lot of messages, before (hopefully) ending with something similar to: \n\n<p style=\"color:red;margin-left:30px;\">\n...<br>\n...<br>\n\\* DONE (cowsay)<br>\n<br>\nThe downloaded source packages are in<br>\n\t\\‘/tmp/RtmpIRbMnh/downloaded_packages\\’\n</p>\n<span style=\"color:blue;margin-left:30px;\">\\></span>\n\nNow that we've installed it, to use it we just need to load it into our R session, by using `library()`.  \n**Back in your script**, use this code to load the package:\n```{r}\nlibrary(cowsay)\n```\n\nWhich enables us to now use some of the functionality that is in that package, such as the `say()` function, which makes some silly art out of punctuation symbols:  \n```{r}\nsay(\"Welcome to the USMR course!\", by = \"owl\")\n```\n\n\n:::\n\n\n<div style=\"max-width:49%;display:inline-block;vertical-align:middle\">\nIt's good practice to have all the packages you use for an analysis loaded at the top of your script.  \n  \nA typical structure for an R script is to:  \n\n1. load all the required packages\n2. read in the data\n3. conduct your analysis    \n\n</div><div style=\"max-width:49%;display:inline-block;vertical-align:top\">\n```{r}  \n#| label: fig-packload\n#| echo: false\n#| fig-cap: \"Typical script layout\"\nknitr::include_graphics(\"images/installing_intro/packload.png\")\n```\n</div>\n\n:::rtip\n\nWe will be using these packages quite a lot in this course, so you might want to install them now, by writing `install.packages(\"PACKAGE_NAME\")` in your console:  \n\n- tidyverse\n- patchwork\n\nIt might take a few minutes for them to install, so just sit back and take a breather. \n\n\n:::\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Checkpoint - where are you writing your code?  \n\nHopefully, if you are following along with us, you are writing almost all of your code in a script, and not in the console. __Remember: Code that you write in the console is *not* saved__.  \n\nHowever, when we installed packages above, we suggested you write directly into the console.  \nWhy? Because sometimes, for certain things, we don't want to keep a record of that bit of code. We only ever want to install a package __once__, because after that first time it's going to be installed on our computer, so we're not going to need to run `install.packages(\"cowsay\")` again. \n\nConsider the example code below. The 2nd, 3rd, and 5th lines do absolutely nothing to our computations with x and y. They are just for our own workings. Because lines like this have no consequences on code below, our R script will have the same end-point with and without those line.  \n```{r}\n#| eval: false\nx <- 4\nx\n4*33\ny <- 6/100\n?mean\nanswer <- x*y\n```\n\nIn general, the vast majority of the code you write will be in the script, and you will only use the console occasionally for quick commands that aren't doing anything to change our analysis. For example, we don't want to keep **re-**installing packages over and over again (each time we run a script), so we'll tend to use `install.packages()` in the console. Similarly, when we look up the help documentation for a function (e.g. by running `?mean`), we type that into the console, and not a script.  \n\nThis will become second nature as you use R more and more, but it's helpful to get into good habits early on.   \n\n:::sticky\n__Rules of thumb__  \n\n- If a line of code changes something in the environment, then that code should be written in the script.  \n- If you clear your environment, restart R, and run your script all at once (see the section on ['Good Habits' in Section 1A](01a_R.html#Good_Habits){target=\"_blank\"}), it shouldn't produce errors and should get you back to your current place  \n\nIf we don't follow the above suggestions, then our work will not be **reproducible** (e.g. you send your script to someone and they will get a different answer from you when they run it). \n:::\n\n\n\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Basic Data Wrangling   \n\n\n\nNow that we've started to learn about vectors and dataframes, we're going to look at reading in a bigger dataset, exploring some of the variables, and the syntax we can use to access and edit certain bits of the data.    \n\nFirst we'll read in our data:  \n```{r}\nstarwars2 <- read.csv(\"https://uoepsy.github.io/data/starwars2.csv\")\n```\n\n:::rtip\n__Reading data from a URL__ \n\nNote that when you have a url for some data (e.g. [this](https://raw.githubusercontent.com/uoepsy/data/master/starwars2.csv)) you can read it in directly by giving functions like `read.csv()` the url inside quotation marks. \n:::\n\nThe data contains information on various characteristics of characters from Star Wars. \nWe can print out the top of the data by using the `head()` function which displays the first six rows of the data by default. You could change this by saying, for example, `head(data, n = 10)`:\n```{r}\nhead(starwars2, n = 10)\n```\n\n_(Don't worry about the_ NAs _for now, they are just how R tells you an entry is missing, i.e. Not Available.)_  \n\n:::rtip\nTry clicking on the data in your __environment__ (the top right window of RStudio). It will open the data in a tab in the editor window - this is another way of looking at the data, more like you would in spreadsheet software like Microsoft Excel.  \n\nThis can be time-consuming and awkward if your data file is big (i.e. lots of columns, or lots of rows, or both!).\n:::\n\nWe can take a look at how big the data is (the dimensions), using `dim()`\n```{r}\ndim(starwars2)\n```\n\nWe can see that there are `r nrow(starwars2)` rows and `r ncol(starwars2)` columns. In this dataset, each Star Wars character is an __observational unit__, and there are 6 __variables__ (things which vary between units) such as their _height_, _species_, _homeworld_, etc.  \n\n:::sticky\n__observations and variables__\n\nThe individual entities on which data are collected are called __observational units__ or __cases__. Often (but not always), these equate to the rows of a dataset.  \n\nA __variable__ is any characteristic that varies from observational unit to observational unit (these are often the columns of the dataset)\n:::\n\n## Accessing subsets of data\n\nWhat if we want to extract certain subsections of our dataset, such as specific observational units or variables? \nThis is where we learn about two important bits of R code used to access parts of data - the dollar sign `$`, and the square brackets `[]`.  \n\n:::rtip\n__The dollar sign $__  \n  \nThe dollar sign allows us to extract a specific variable from a dataframe.\nFor instance, we can pull out the variable named \"eye_color\" in the data, by using `$eye_color` after the name that we gave our dataframe.  \n\nRemember that each variable in a dataframe is a vector (a set of values). Once extracted, we will have a vector and not a dataframe.  \n```{r}\nstarwars2$eye_color\n```\n:::\n\n\n\n:::rtip\n__The square brackets []__  \n  \nSquare brackets are used to do what is known as __indexing__ (finding specific entries in your data).  \nWe can retrieve bits of data by identifying the $i^{th}$ entry(s) inside the square brackets, for instance: \n\n```{r}\n# assign the numbers 10, 20 ... 100 to the name \"somevalues\"\nsomevalues <- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)\n\n# pull out the 3rd entry\nsomevalues[3]\n```\n\nIn the above example, we have a __vector__ (a single sequence of values), and so we can retrieve entries with the syntax:\n<center> \n**vector[entry]**\n</center>\n<br>\nIn a __dataframe__ we have an extra dimension - we have rows _and_ columns. Using square brackets with a dataframe needs us to specify both:  \n<center>\n**dataframe[rows, columns]**\n</center>\n:::\n\nLet's look at some examples: \n\n::: {.panelset}\n\n::: {.panel}\n#### Examples of Indexing\n\n1. Specifying row number and column number:  \n```{r}\n#| eval: false\n\n# first row, fourth column\nstarwars2[1, 4]\n# tenth row, first column\nstarwars2[10, 1]\n```\n2. If we leave either rows or columns blank, then we will get out __all__ of them:\n```{r}\n#| eval: false\n# tenth row, all columns\nstarwars2[10, ]\n# all rows, 2nd column\nstarwars2[ , 2]\n```\n3. There are is another way to identify column - we can use the name in quotation marks:  \n```{r}\n#| eval: false\n# first row, \"species\" column\nstarwars2[1, \"species\"]\n```\n4. We can also ask for multiple rows, or multiple columns, or both! To do that, we use `c()`:\n```{r}\n#| eval: false\n# the 1st AND the 6th rows, and the 1st AND 3rd columns\nstarwars2[c(1,6), c(1,3)] \n```\n5. And we can specify a sequence using the colon, `from:to`: ^[The colon operator, `from:to`, creates a vector from the value `from` to the value `to` in steps of 1.  \nFor instance, `1:6` is the same as `c(1,2,3,4,5,6)`.]\n\n```{r}\n#| eval: false\n# FROM the 1st TO the 6th row, all columns\nstarwars2[1:6, ] \n```\n\n6. We can even use the two accessors in combination:^[Note: When we do this, we don't have the comma inside the square brackets.  \nWhen we use the `$` to pull out a variable, such as `starwars2$name`, we no longer have a dataframe.  \n`starwars2$name` doesn't have rows and columns, it just has a series of values - _it's a vector!_  \nSo when you are using `[]` with a __vector__ (1 dimension) rather than a __dataframe__ (2 dimensions), you don't specify `[rows, columns]`, but simply `[entry]`.] \n```{r}\n#| eval: false\n# extract the variable called \"name\" and show the 20th entry\nstarwars2$name[20]  \n```\n\n\n:::\n::: {.panel}\n#### Show me the output\n\n1. Specifying row number and column number:  \n```{r}\n# first row, fourth column\nstarwars2[1, 4]\n# tenth row, first column\nstarwars2[10, 1]\n```\n2. If we leave either rows or columns blank, then we will get out __all__ of them:\n```{r}\n# tenth row, all columns\nstarwars2[10, ]\n# all rows, 2nd column\nstarwars2[ , 2]\n```\n3. There are is another way to identify column - we can use the name in quotation marks:  \n```{r}\n# first row, \"species\" column\nstarwars2[1, \"species\"]\n```\n4. We can also ask for multiple rows, or multiple columns, or both! To do that, we use `c()`:\n```{r}\n# the 1st AND the 6th rows, and the 1st AND 3rd columns\nstarwars2[c(1,6), c(1,3)] \n```\n5. And we can specify a sequence using the colon, `from:to`:  \n```{r}\n# FROM the 1st TO the 6th row, all columns\nstarwars2[1:6, ] \n```\n6. We can even use the two accessors in combination: \n```{r}\n# extract the variable called \"name\" and show the 20th entry\nstarwars2$name[20]  \n```\n:::\n    \n:::\n\n:::sticky\n__The dollar sign $__ \n\nUsed to extract a variable from a dataframe:   \n\n+ `dataframe$variable`\n\n__The square brackets []__\n\nUsed to extract parts of an R object by identifying rows and/or columns, or more generally, \"entries\". Left blank will return all. \n\n+ `vector[entries]`\n+ `dataframe[rows, columns]`\n:::\n\n## Accessing by a condition \n\nWe can also do something really useful, which is to access all the entries in the data for which _a specific condition_ is true.  \n\nLet's take a simple example to start:\n```{r}\nsomevalues <- c(10, 10, 0, 20, 15, 40, 10, 40, 50, 35)\n```\n\nTo only select values which are greater than 20, we can use:\n```{r}\nsomevalues[somevalues > 20]\n```\n\n:::frame\n__Unpacking:__ `somevalues[somevalues > 20]`  \n<br>\nFirst, let's look at what `somevalues > 20` does. It returns TRUE for the entries of `somevalues` which are greater than 20, and FALSE for the entries of `somevalues` that are not (that is, which are less than, or equal to, 20. \n\nThis statement `somevalues > 20` is called the __condition__.    \n```{r}\nsomevalues > 20\n```\n\nNow consider putting that sequence of TRUEs and FALSEs inside the square brackets in `somevalues[]`.\nThis returns only the entries of `somevalues` for which the condition is `TRUE`.  \n```{r}\nsomevalues[c(FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE)]\n```\n\nSo what we're doing is using a __condition__ inside the square brackets to return all the values for which that condition is TRUE.\n\nAnd we're being super efficient, because we don't want to write out TRUEs and FALSEs all day, so we just give the conditional question inside the brackets directly:  \n```{r}\nsomevalues[somevalues > 20]\n```\n\n:::\n\n<br>\nWe can extend this same logic to a dataframe.\nLet's suppose we want to access all the entries in our Star Wars data who have the value \"Droid\" in the _species_ variable.\nTo work out how to do this, we first need a line of code which defines our __condition__ - one which returns `TRUE` for each entry of the _species_ variable which is \"Droid\", and `FALSE` for those that are not \"Droid\".  \n\nWe can use the dollar sign to pull out the _species_ variable: \n```{r}\nstarwars2$species\n```\n\nAnd we can ask R whether each value __is equal to__ \"Droid\"  \n\n:::hints\n*Remember:* in R, we ask whether something __is equal to__ something else by using a double-equals, `==`. A single equal sign would be wrong, as it denotes assignment.\n:::\n\n```{r}\nstarwars2$species == \"Droid\"\n```\n\nFinally, we can use this condition inside our square brackets to access the entries of the data for which this condition is TRUE:\n```{r}\n# I would read the code below as: \n# \"In the starwars2 dataframe, give me all the rows \n# for which the condition starwars2$species==\"Droid\"\n# is TRUE, and give me all the columns.\"\n\nstarwars2[starwars2$species == \"Droid\", ]\n```\n\n<!-- `r optbegin('Optional: with().', FALSE)` -->\n<!-- A useful function is `with()`. This creates a \"container\" where the variables of the dataframe are available to R within the `with()` parentheses without the need to use `$`: -->\n<!-- ```{r} -->\n<!-- with(starwars2, starwars2[species == \"Droid\", ]) -->\n<!-- ``` -->\n<!-- `r optend()` -->\n\n## More complex conditions\n\nThinking back to Reading 1A when we first introduced R, we [talked briefly about \"logical operators\"](01a_R.html#R_is_a_calculator){target=\"_blank\"}. Specifically, the operators `&`, `|`, and `!` (for \"and\", \"or\",\" and \"not\"), will come in handy now.  \n\nFor instance, we can now extract all those in the dataset which are humans _and_ taller than 190cm:  \n```{r}\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$species==\"Human\" AND starwars2$height > 190 are TRUE, \n# and give me all the columns.\"\nstarwars2[starwars2$species == \"Human\" & starwars2$height > 190, ]\n```\nOr we can extract all those in the dataset which are _either_ droids _or_ ewoks: \n```{r}\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$species==\"Droid\" OR starwars2$species==\"Ewok\" is TRUE, \n# and give me all the columns.\"\nstarwars2[starwars2$species == \"Droid\" | starwars2$species == \"Ewok\", ]\n```\n \n\n## Editing specific entries {-}  \n\nNow that we've seen a few ways of _accessing_ sections of data, we can learn how to edit them! \nOne of the most common reasons you will need to modify entries in your data is in __data cleaning__. This is the process of identifying incorrect / incomplete / irrelevant data, and replacing / modifying / deleting them. \n\nAbove, we looked at the subsection of the data where the _species_ variable had the entry \"Droid\". Some of you may have noticed earlier that we had some data on C3PO. Are they not also a droid? \n\n<center>\n![](images/categorical/c3po.png)  \n</center>\n\n(Looks pretty Droid-y to me! _disclaimer: I know nothing about Star Wars_ &#128578; )\n\nJust as we saw above how to _access_ specific entries, e.g.: \n```{r}\n# 2nd row, all columns\nstarwars2[2, ]\n# 2nd row, 6th column (the \"species\" column)\nstarwars2[2,6]\n```\n\nWe can change these by __assigning them a new value__ (remember the `<-` symbol). In doing so, we _overwrite_^[you could think of this as _replacing_ / _overwriting_ / _reassigning_ the entry] the entry in the 2nd row and 6th column of the data (`starwars2[2,6]`) with the value \"Droid\". \n```{r}\n# C3PO is a droid, not a human\nstarwars2[2,6] <- \"Droid\"\n# Look at the 2nd row now -\n# the entry in the \"species\" column has changed:\nstarwars2[2, ]\n```\n\n## Editing entries via a condition {-}  \n\nWe saw above how to access parts of data by means of a __condition__, with code such as:\n\n```{r}\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$homeworld==\"Naboo\" is TRUE, and give me all the columns.\"\nstarwars2[starwars2$homeworld==\"Naboo\", ]\n```\n\nWhat if we wanted to modify it so that every character from \"Naboo\" was actually of species \"Nabooian\"?  \n\nWe can do that in a number of ways, all of which do the same thing - namely, they access parts of the data and assign them the new value \"Nabooian\".  \n\nThe lines of code below all do exactly that, in different ways. We've also tried to give a way of interepreting each line. \n\n```{r}\n# In the starwars2 data, give the rows for which condition \n# starwars2$homeworld==\"Naboo\" is TRUE, and select only the \"species\" column. \n# Assign to these selected entries the value \"Nabooian\".\nstarwars2[starwars2$homeworld==\"Naboo\", \"species\"] <- \"Nabooian\"\n```\n\n```{r}\n# In the starwars2 data, give the rows for which condition \n# starwars2$homeworld==\"Naboo\" is TRUE, and select only the 6th column. \n# Assign to these selected entries the value \"Nabooian\".\nstarwars2[starwars2$homeworld==\"Naboo\", 6] <- \"Nabooian\"\n```\n\n```{r}\n# Extract the species variable from the starwars2 data (it's a vector).\n# Pick the entries for which the condition starwars2$homeworld==\"Naboo\" is TRUE.\n# Assign to these selected entries the value \"Nabooian\".\nstarwars2$species[starwars2$homeworld==\"Naboo\"] <- \"Nabooian\"\n```\n\n::: {.callout-caution collapse=\"true\"}\n#### optional: a little extra... \nIn a similar way, we could have changed C-3PO to a Droid without ever having to know what row of the data they were in! \n```{r}\n# for the row(s) where the name variable in starwars2\n# is equal to \"C-3PO\", in the species variable we assign\n# that entry to be \"Droid\"\nstarwars2[starwars2$name==\"C-3PO\", \"species\"] <- \"Droid\"\n```\n:::\n\n## Adding/Changing a variable\n\nAnother thing we might want to do is change a whole variable (a whole column) in some way.  \nThe logic is exactly the same, for instance, we can take the variable \"height\" from the dataframe \"starwars2\", dividing it by 100 via `starwars2$height / 100`, and then assign the result to the same variable name in the data, i.e. we overwrite the column: \n```{r}\nstarwars2$height <- starwars2$height / 100\n```\n\nWe could instead have added a _new column_ named \"height_m\" with those values if we did not want to overwrite \"height\":\n```{r}\n#| eval: false\nstarwars2$height_m <- starwars2$height / 100\n```\nThis would have left the \"height\" variable as-is, and created a new one called \"height2\" which was the values in \"height\" divided by 100. \n\n\n## Removing rows or columns\n\nLastly, we might want to change the data by removing a row or a column.\nAgain, the logic remains the same, in that we use `<-` to assign the edited data to a name (either a new name, thus creating a new object, or an existing name, thereby _overwriting_ that object).  \n  \nFor instance, notice that the 35th and 75th rows of our data probably aren't a valid observation - I'm reasonably sure that Marge and Homer Simpson never appeared in Star Wars:\n```{r}\nstarwars2[c(35,75), ]\n```\n\nWe can remove a certain row(s) by using a minus sign `-` inside the square brackets \n```{r}\n#| eval: false\n# everything minus the 75th row\nstarwars2[-75, ]\n# everything minus the (35th and 75th rows)\nstarwars2[-c(35, 75), ]\n```\n\nAnd we can simply _re-use_ the name \"starwars2\" to overwrite the data and make this change take effect (rather than just print out the result, which the code above did):\n```{r}\nstarwars2 <- starwars2[-c(35, 75), ]\n```\n(now, in the __environment__ pane of Rstudio, the object named \"starwars2\" will say 73 observations, rather than 75, which it had before - we've removed the 2 rows)   \n\n<br>\nThe same logic applies for columns:\n```{r}\n# Create a new object called \"anonymous_starwars2\" and assign it \n# to the values which are the \"starwars2\" dataframe minus the \n# 1st column (the \"name\" column):\nanonymous_starwars2 <- starwars2[, -1]\n# dimensions of our initial data\ndim(starwars2)\n# the data we just assigned has one fewer columns\ndim(anonymous_starwars2)\n```\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>\n\n\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"include-in-header":["assets/toggling.html",{"text":"<link rel=\"stylesheet\" href=\"https://uoepsy.github.io/assets/css/ccfooter.css\" />\n"}],"number-sections":false,"output-file":"01b_data.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","toc_float":true,"code-annotations":"hover","link-citations":true,"theme":["united","assets/style-labs.scss"],"title":"1B: More R - Basic Data Skills","params":{"SHOW_SOLS":true,"TOGGLE":true}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}