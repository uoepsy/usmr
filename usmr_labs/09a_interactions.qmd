---
title: "9A: Interactions"
link-citations: yes
params: 
    SHOW_SOLS: TRUE
    TOGGLE: TRUE
editor_options: 
  chunk_output_type: console
---

```{r}
library(tidyverse)
set.seed(993)
contcont <- tibble(
  x1 = rnorm(60),
  x2 = rnorm(60),
  y = .8*x1 + -2*x2 + .6*x1*x2 + rnorm(60)
)

contcat <- tibble(
  x1 = rnorm(60),
  x2 = sample(0:1,60,T),
  y = -.8*x1 + 2*x2 - .6*x1*x2 + rnorm(60)
)

catcat <- tibble(
  x1 = sample(0:1,60, T),
  x2 = sample(0:1,60, T),
  y = 2*x1 - 2*x2 -1*x1*x2 + rnorm(60)
)
```





# holding constant

plot eff for x2 = -3, 0, 3
 - effect is the same
 
what if we think the y~x1 is different depending on x2
 - examples panelset: cont cont, cont cat, cat cat. 
 - switch to eg: x1 eff is bigger the more x2 you are. 
  - how much bigger? we can model that



```{r}
fit<-lm(y~x1*x2, data=contcont)
steps=50
x1 <- with(contcont, seq(min(x1),max(x1),length=steps))
x2 <- with(contcont, seq(min(x2),max(x2),length=steps))
newdat <- expand.grid(x1=x1, x2=x2)
y <- matrix(predict(fit, newdat), steps, steps)

p <- persp(x1,x2,y, theta = -60,phi=20, col = NA)
obs <- with(contcont, trans3d(x1,x2, y, p))
pred <- with(contcont, trans3d(x1, x2, fitted(fit), p))
points(obs, col = "red", pch = 16)
#points(pred, col = "blue", pch = 16)
segments(obs$x, obs$y, pred$x, pred$y)

```

```{r}
plot(contcat$y~contcat$x1,col=ifelse(contcat$x2,"red","black"))
abline(lm(y~x1,contcat[contcat$x2==0,]))
abline(lm(y~x1,contcat[contcat$x2==1,]),col="red")
```


```{r}
library(scatterplot3d)
plt <- with(catcat,scatterplot3d(x1,x2,y, scale.y=.8,angle=-30,
                                 x.ticklabs = c(0,NA,NA,NA,NA,1), 
                                 y.ticklabs = c(0,NA,NA,NA,NA,1), 
                                 main="y~x1*x2\n(x1 and x2 are categorical)"))
fit = lm(y~x1*x2,catcat)
pp <- expand_grid(x1=seq(0,1,.1), x2=seq(0,1,.1))
pp$y <- predict(fit, pp)

pp1 <- pp[pp$x2==0,]
pp2 <- pp[pp$x2==1,]
pp3 <- pp[pp$x1==0,]
pp4 <- pp[pp$x1==1,]
plt$points(pp1$x1,pp1$x2,pp1$y,type="l")
plt$points(pp2$x1,pp2$x2,pp2$y,type="l")
plt$points(pp3$x1,pp3$x2,pp3$y,type="l")
plt$points(pp4$x1,pp4$x2,pp4$y,type="l")
```






# interactions
  
interaction as product term.  

equation

so we're saying we predict y by the amount of x1, and the amount of x2, and a little addition to eff of x1 depending on how far x2 you are. (and vice versa).  

visual intuition: 

surface >> twisty surface
two parallel lines >> two non parallel lines
cat * cat surface transp with lines at edges

rtip in R
interaction term is colon a:b
a*b is a+b+a:b

sticky
don't fit model with a:b and not a + b in it. 
think about the logic.
a:b = "effect of a depends on b" 
but by not including "a" in the first place, it's unclear what we're allowing to depend on b

# interpretation 

including the a:b means a and b become interpreted _at some specific value_.  
consider y ~ x2*x2+x3+x4

interpretation each
mention predictors not interacting stay the same as prev mlr week.   

example panelset interpretation




# presentation

refer back to visual intuition plots
we don't plot like that we

cont * cat : plot eff x1 at all levels of x2

cont * cont : plot eff x1 at some judiciously chosen values of x2 (e.g. min, mean, max, or -1sd, mean, 1sd)

cat * cat : plot the various group means, and add some dotted lines to show the non-parallelism




```{r}
fit = lm(y~x1*x2,catcat %>% mutate(across(x1:x2,factor)))
sjPlot::plot_model(fit, type="int",show.data=T)+geom_line()

# it's just viewing that cube from one side 
library(scatterplot3d)
plt <- with(catcat,scatterplot3d(x1,x2,y, scale.y=0,angle=90,
                                 x.ticklabs = c(0,NA,NA,NA,NA,1), 
                                 y.ticklabs = c(0,NA,NA,NA,NA,1), 
                                 main="y~x1*x2\n(x1 and x2 are categorical)"))
fit = lm(y~x1*x2,catcat)
pp <- expand_grid(x1=seq(0,1,.1), x2=seq(0,1,.1))
pp$y <- predict(fit, pp)

pp1 <- pp[pp$x2==0,]
pp2 <- pp[pp$x2==1,]
pp3 <- pp[pp$x1==0,]
pp4 <- pp[pp$x1==1,]
plt$points(pp1$x1,pp1$x2,pp1$y,type="l")
plt$points(pp2$x1,pp2$x2,pp2$y,type="l")
plt$points(pp3$x1,pp3$x2,pp3$y,type="l")
plt$points(pp4$x1,pp4$x2,pp4$y,type="l")
```





