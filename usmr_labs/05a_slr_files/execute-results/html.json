{
  "hash": "20b3211aa3ac7203a75cd676490dbdb0",
  "result": {
    "markdown": "---\ntitle: \"5A: Simple Linear Regression\"\nparams: \n    SHOW_SOLS: FALSE\n    TOGGLE: TRUE\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n:::lo\nThis reading:  \n\n- How can we create a model of the relationship between two variables? \n- How can we test certain parameters that define our model? \n- How can we test the model overall? \n\n:::\n\n# The Linear Model\n\n\n\n\n\nIn its simplest form, linear regression is a way to make a model of the relationship between two variables. When both variables are continuous, it is nice and intuitive to envisage this as the 'line of best fit' on a scatterplot. For instance, in @fig-lmintro we see two variables `y` and `x`, and our linear regression model is the blue line.  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![y regressed onto x.](05a_slr_files/figure-html/fig-lmintro-1.png){#fig-lmintro fig-align='center' width=80%}\n:::\n:::\n\n\nWe're going to use the data in this plot for the remainder of the reading. If you wish to play around with it yourself, it is available at [https://uoepsy.github.io/data/usmr_slr.csv](https://uoepsy.github.io/data/usmr_slr.csv), and contains a sample of 100 observations on variables `x` and `y`.   \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nmy_data <- read_csv(\"https://uoepsy.github.io/data/usmr_slr.csv\")\nhead(my_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 Ã— 2\n      x     y\n  <dbl> <dbl>\n1  3.19  4.42\n2  2.57  4.48\n3  3.91  2.72\n4  4.79  5.39\n5  4.00  3.85\n6  4.11  4.42\n```\n:::\n:::\n\n\n@fig-lmintro, above, highlights a linear relationship, where the data points are scattered around an underlying linear pattern with a roughly-constant spread as we move along `x`.  \n\nIn [4B: Covariance & Correlation](04b_covcor.html){target=\"_blank\"} we have already talked about one way to describe this relationship, by calculating either the covariance or the correlation between `x` and `y`. However, as we will see in the coming weeks, the linear model provides us with the scope to extend our analysis to many more situations - it is the building block of many more complex analytical methods.  \n\nThe simple linear regression model takes the form:  \n\n$$\n\\begin{align}\n& y = b_0 + b_1 \\ x + \\epsilon \\quad \\\\\n\\end{align}\n$$\n\n:::column-margin\nYou will see a variety of different ways of specifying the linear model form in different resources, some use $\\beta$, some use $b$. Sometimes you will see $\\alpha$ instead of $b_0$.\n:::\n\nWe typically refer to the outcome ('dependent') variable with the letter $y$ and to our predictor ('explanatory'/'independent') variables with the letter $x$. When we construct a linear model we are trying to re-express our outcome variable $y$ with some linear transformation of our predictor variable $x$.  \n\nYou can think of this in broader terms as: \n$$\n\\begin{align}\n& \\color{red}{Outcome}\\color{} = \\color{blue}{Model}\\color{black}{} + Error\\\\\n\\end{align}\n$$\n\n\n## The Model \n\nWhen we fit a simple regression model, the bit we refer to as the 'model' is the line that is defined by two numbers, an 'intercept' and a 'slope' (see @fig-slr):\n\n- the __intercept__, denoted $b_0$, is the point at which the line hits the y-axis (i.e. where $x=0$)\n- the __slope__, denoted $b_1$, is the angle of the line. It is the amount which the line increases for every 1 increase in $x$.  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Simple linear regression model, with the systematic part of the model in blue](05a_slr_files/figure-html/fig-slr-1.png){#fig-slr fig-align='center' width=80%}\n:::\n:::\n\n\nThis line implies some _predicted_ values for our observed $x$ values. For instance, we can see that when $x=3$, the model (the blue line) will predict that $y$ is approximately 4. If we take each of our datapoints, and project them up/down to the line, then we get our fitted values (@fig-slrfit). We often denote these as $\\hat y$ (or \"y hat\"), with the hat indicating that they are the model-estimated values of $y$. \n\n$$\n\\begin{align}\n\\color{red}{Outcome}\\color{black} \\qquad=\\qquad & \\color{blue}{Model}\\color{black}{} & +\\qquad Error\\\\\n\\color{red}{y}\\color{black} \\qquad = \\qquad & \\color{blue}{\\hat y}\\color{black} & +\\qquad \\epsilon \\quad \\\\\n\\color{red}{y}\\color{black} \\qquad = \\qquad & \\color{blue}{b_0 + b_1 \\ (x)}\\color{black} & +\\qquad \\epsilon \\quad \\\\\n\\end{align}\n$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Simple linear regression model, fitted values in blue](05a_slr_files/figure-html/fig-slrfit-1.png){#fig-slrfit fig-align='center' width=80%}\n:::\n:::\n\n\n\n## The Error \n\nOur model is not perfect. It is a _model_ - i.e. it is a _simplification_ of the world, and so is inherently going to be inaccurate for individuals. This inaccuracy can be seen in our plots so far - some points are higher than the model predicts, some lower. These deviations from the model (shown by the red lines in @fig-slr2) from the model are the random error component $\\hat \\epsilon$, or \"residuals\".  \n\n$$\n\\begin{align}\nError &= \\color{red}{Outcome}\\color{black}-\\color{blue}{Model} \\\\\n\\hat{\\epsilon} &= \\color{red}{y}\\color{black}- \\color{blue}{\\hat{y}}\n\\end{align}\n$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Simple linear regression model, with the systematic part of the model in blue, and residuals in red](05a_slr_files/figure-html/fig-slr2-1.png){#fig-slr2 fig-align='center' width=80%}\n:::\n:::\n\n\nIn full, we should really write our linear regression model out as: \n\n$$\n\\begin{align}\n& y = b_0 + b_1 \\ x + \\epsilon \\quad \\\\\n& \\text{where} \\\\\n& \\epsilon \\sim N(0, \\sigma) \\text{ independently}\n\\end{align}\n$$\n\nThe new bit here: \"$\\epsilon \\sim N(0, \\sigma) \\text{ independently}$\" means that the errors around the line have mean zero and constant spread as x varies (we'll read more about what this means later in this course, when we discuss the assumptions underlying regression). You can think of $\\sim N(0, \\sigma)$ as meaning \"normally distributed with a mean of zero and a standard deviation of $\\sigma$\".  \n\nThe standard deviation of the errors, denoted by $\\sigma$ is an important quantity that our model estimates. It measures how much individual data points tend to deviate above and below the regression line. A small $\\sigma$ indicates that the points hug the line closely and we should expect fairly accurate predictions, while a large $\\sigma$ suggests that, even if we estimate the line perfectly, we can expect individual values to deviate from it by substantial amounts.\n\n$\\sigma$ is estimated by essentially averaging squared residuals (giving the variance) and taking the square-root:  \n$$\n\\begin{align}\n& \\hat \\sigma = \\sqrt{\\frac{SS_{Residual}}{n - 2}} \\\\\n\\qquad \\\\\n& \\text{where} \\\\\n& SS_{Residual} = \\textrm{Sum of Squared Residuals} = \\sum_{i=1}^n{(\\epsilon_i)^2}\n\\end{align}\n$$\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Fitting Linear Models in R\n\n## lm()\n\nIn R it is very easy to fit linear models, we just need to use the `lm()` function.  \n\nThe syntax of the `lm()` function is:  \n\n```\nmodel_name <- lm(outcome ~ 1 + predictor, data = dataframe)\n```\n\nWe don't _have_ to include the `1 + ` when we specify the model, as this will be included by default, so we can also simply write: \n\n```\nmodel_name <- lm(outcome ~ predictor, data = dataframe)\n```\n\n::: {.callout-note collapse=\"true\"}\n#### What is the ~1 + doing?  \n\nThe fitted model can be written as\n$$\n\\hat y = \\hat b_0 + \\hat b_1 x\n$$\nThe predicted values for the outcome are equal to our intercept, $\\hat b_0$, plus our slope $\\hat b_1$ multiplied by the value on our explanatory variable $x$.  \nThe intercept is a _constant_. That is, we could write it as multiplied by 1:\n$$\n\\hat y = \\color{blue}{\\hat b_0}\\color{black}{}(\\color{green}{1}\\color{black}{})\\color{blue}{ + \\hat b_1 }\\color{black}{}(\\color{green}{x}\\color{black}{})\n$$\n\nWhen we specify the linear model in R, we include after the tilde sign `~` all the things which appear to the right of each of the $\\hat b$s (the bits in green in the equartion above). That's why the 1 is included. It is just saying \"we want the intercept, $b_0$, to be estimated\".   \n\n:::\n\n## Model Summary\n\nWe can then view lots of information by giving our model to the `summary()` function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_model <- lm(y ~ x, data = my_data)\nsummary(my_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x, data = my_data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.4383 -0.6593  0.1075  0.5945  2.1867 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  1.54277    0.32005   4.820 5.24e-06 ***\nx            0.77952    0.09959   7.827 5.92e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.9308 on 98 degrees of freedom\nMultiple R-squared:  0.3847,\tAdjusted R-squared:  0.3784 \nF-statistic: 61.26 on 1 and 98 DF,  p-value: 5.918e-12\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Output of lm() for a simple regression in R](images/slr/slr1.png){#fig-lmoutput fig-align='center' width=80%}\n:::\n:::\n\n\nThe __intercept__ $b_0$ is the point at which the line hits the y-axis (i.e. where $x=0$), and the __slope__ $b_1$ is the amount which the line increases for every 1 increase in $x$. We can see the estimated values of these in @fig-lmoutput, providing us with our fitted line: \n\n$$\n\\begin{align}\ny &= 1.54 + 0.78 (x) + \\varepsilon \\\\\n\\end{align}\n$$\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Simple linear regression model, estimated intercept and slope included](05a_slr_files/figure-html/fig-slrest-1.png){#fig-slrest fig-align='center' width=80%}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n#### Optional: Regression Slope vs Covariance  \n\nWith simple linear regression, the fitted line we are describing is actually a scaled version of our covariance.  \n\nRemember that covariance is the average of the products of $(x_{i}-\\bar{x})(y_{i}-\\bar{y})$, which is a bit like the average area of the rectangles in @fig-covsq. If we think about what the average __width__ of these rectangles is, it is the average of $(x_{i}-\\bar{x})$, which is actually just the variance of $x$! \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Covariance](05a_slr_files/figure-html/fig-covsq-1.png){#fig-covsq fig-align='center' width=80%}\n:::\n:::\n\n\nWe can divide the area of the average rectangle ($cov(x, y)$) by its width ($var(x)$), thereby scaling it so that the width is 1. What we're getting from our coefficient is the area of this new rectangle which has width = 1. Because width = 1, the area is also the height ($\\text{area} = \\text{width} \\times \\text{height} = 1 \\times \\text{height}$). So what we get is the amount that $y$ increases (the height) as $x$ increases by 1 (the width).  \n\nWe can see this working: \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncov(my_data$x, my_data$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6877738\n```\n:::\n\n```{.r .cell-code}\nvar(my_data$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8823097\n```\n:::\n:::\n\nThis calculation gives us the same linear regression slope of 0.78 that we see when we fit the model using `lm()`.  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncov(my_data$x, my_data$y)/var(my_data$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7795152\n```\n:::\n:::\n\n\n:::\n\n## Model Predictions\n\nFurthermore, we can get out the model predicted values for $y$, the \"y hats\" ($\\hat y$), using functions such as:  \n\n- `predict(my_model)`\n- `fitted(my_model)`\n- `fitted.values(my_model)`\n- `my_model$fitted.values`\n\nA nice package which will come in handy is the __broom__ package. It allows us to use the function `augment()`, which gives us out lots of information, such as the model predicted values, the residuals, and many more:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(broom)\naugment(my_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100 Ã— 8\n       y     x .fitted .resid   .hat .sigma  .cooksd .std.resid\n   <dbl> <dbl>   <dbl>  <dbl>  <dbl>  <dbl>    <dbl>      <dbl>\n 1  4.42  3.19    4.03  0.388 0.0102  0.935 0.000903      0.420\n 2  4.48  2.57    3.54  0.941 0.0130  0.931 0.00681       1.02 \n 3  2.72  3.91    4.59 -1.87  0.0180  0.916 0.0378       -2.03 \n 4  5.39  4.79    5.28  0.107 0.0438  0.935 0.000319      0.118\n 5  3.85  4.00    4.66 -0.809 0.0197  0.932 0.00776      -0.878\n 6  4.42  4.11    4.74 -0.327 0.0222  0.935 0.00143      -0.355\n 7  4.30  2.72    3.66  0.638 0.0114  0.933 0.00274       0.689\n 8  5.94  4.02    4.68  1.26  0.0202  0.927 0.0193        1.37 \n 9  1.70  3.05    3.92 -2.22  0.0100  0.908 0.0291       -2.40 \n10  4.79  4.58    5.11 -0.318 0.0358  0.935 0.00224      -0.348\n# â„¹ 90 more rows\n```\n:::\n:::\n\n\nWe can also compute model-predicted values for other (unobserved) data. For instance, what about for an observation where $x=10$, or $20$?  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# make a dataframe with values for the predictor:\nsome_newdata <- data.frame(x=c(10, 20))\n# model predicted values of y, for the values of x inside the 'some_newdata' object:\npredict(my_model, newdata = some_newdata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       1        2 \n 9.33792 17.13307 \n```\n:::\n:::\n\n\nGiven that our fitted model takes the form below, we can work this out ourselves as well: \n\n$$\n\\begin{align}\ny &= 1.54 + 0.78\\cdot x \\\\\ny &= 1.54 + 0.78\\cdot 10 \\\\\ny &= 1.54 + 7.80\\\\\ny &= 9.34 \\\\\n\\end{align}\n$$\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Inference for Regression Coefficients  \n\nNow that we have fitted a linear model, and we know how we interpret our coefficient estimates, we would like to be able to make a statement on whether these relationships are likely to hold in the population.  \nOur coefficients accurately describe the relationship between $y$ (outcome) and $x$ (predictor) in our sample, but we are yet to perform a statistical test. A test will enable us to discuss how likely it is that we would see this relationship in our sample, if the relationship doesn't hold for the population.  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Estimates without inference](images/slr/conv1a.png){#fig-sillyfig fig-align='center' width=80%}\n:::\n:::\n\n\nMuch like our discussion of sample means and intervals in [2B: Sampling & Curves](02b_sampling.html){target=\"_blank\"}, we have our coefficients: \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncoef(my_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)           x \n  1.5427681   0.7795152 \n```\n:::\n:::\n\n\nand to quantify the amount of uncertainty in each estimated coefficient that is due to sampling variability, we use the standard error (SE)^[Recall that a standard error gives a numerical answer to the question of how variable a statistic will be because of random sampling.] of the coefficient.\n\nThe standard errors are found in the column \"Std. Error\" of the `summary()` of a model:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(my_model)$coefficients\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Estimate Std. Error  t value     Pr(>|t|)\n(Intercept) 1.5427681 0.32004944 4.820406 5.239619e-06\nx           0.7795152 0.09959062 7.827194 5.917849e-12\n```\n:::\n:::\n\n\nIn this example the slope, 0.78, has a standard error of 0.10. One way to envision this is as a distribution. Our best guess (mean) for the slope parameter is 0.78. The standard deviation of this distribution is 0.10, which indicates the precision (uncertainty) of our estimate.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Sampling distribution of the slope coefficient. The distribution is approximately bell-shaped with a mean of 0.78 and a standard error of 0.10.](05a_slr_files/figure-html/fig-sampbeta-1.png){#fig-sampbeta fig-align='center' width=80%}\n:::\n:::\n\n\nWe can perform a test against the null hypothesis that the estimate is zero. The reference distribution in this case is a t-distribution with $n-2$ degrees of freedom^[Why $n-2$? The most intuitive answer is that we have already used up 2 pieces of information in estimating the intercept and the slope. Once these things are fixed, $n-2$ of the datapoints could be wherever they like around that line, but the remaining 2 must be placed in such a way that results in that line], where $n$ is the sample size, and our test statistic is:  \n\n$$\nt = \\frac{\\hat b_1 - 0}{SE(\\hat b_1)}\n$$\n\nThis allows us to test the hypothesis that the population slope is zero --- that is, that there is no linear association between income and education level in the population.  \n\nWe don't actually have to **do** anything for this, it's all provided for us in the `summary()` of the model! The information is contained in the row corresponding to the variable \"education\" in the output of `summary()`, which reports the t-statistic under `t value` and the p-value under `Pr(>|t|)`:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(my_model)$coefficients\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Estimate Std. Error  t value     Pr(>|t|)\n(Intercept) 1.5427681 0.32004944 4.820406 5.239619e-06\nx           0.7795152 0.09959062 7.827194 5.917849e-12\n```\n:::\n:::\n\n\n:::int\nA significant association was found between x and y ($b = 0.78$, $SE = 0.10$, $t(98)=7.83$, $p<.001$).\n:::\n:::column-margin\nRecall that the p-value `5.92-e12` in the `Pr(>|t|)` column simply means $5.92 \\times 10^{-12}$. This is a very small value, hence we will report it as <.001 following the APA guidelines.\n:::\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Conversations with statisticians](images/slr/conv2a.png){#fig-sillyfig2 fig-align='center' width=80%}\n:::\n:::\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n\n# Model Evaluation \n\n## Partitioning Variance\n\nWe might ask ourselves if the model is useful in explaining the variance in our outcome variable $y$. To quantify and assess model utility, we split the total variability of the outcome variable into two terms: the variability explained by the model plus the variability left unexplained in the residuals.\n\n$$\n\\begin{align}\n& \\qquad \\qquad \\qquad \\qquad \\text{total variability in response } =  \\\\\n& \\text{variability explained by model } + \\text{unexplained variability in residuals}\n\\end{align}\n$$\nThe illustration in @fig-sstssrssm gets at the intuition behind this: the top panel shows the total variability in the outcome variable $y$ - for each datapoint we see the distance from the mean of y. These distances can be split into the bit from the mean to the model predicted value (seen in the bottom left panel of @fig-sstssrssm), and the bit from that value to the actual value (bottom right panel). \n\nEach term can be quantified by a sum of squares:\n\n$$\n\\begin{aligned}\nSS_{Total} &= SS_{Model} + SS_{Residual} \\\\\n\\sum_{i=1}^n (y_i - \\bar y)^2 &= \\sum_{i=1}^n (\\hat y_i - \\bar y)^2 + \\sum_{i=1}^n (y_i - \\hat y_i)^2 \\\\\n\\quad \\\\\n\\text{Where:} \\\\\n& y_i = \\text{observed value} \\\\\n&\\bar{y} = \\text{mean} \\\\\n& \\hat{y}_i = \\text{model predicted value} \\\\\n\\end{aligned}\n$$\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Total Sums of Squares = Model Sums of Squares + Residual Sums of Squares](05a_slr_files/figure-html/fig-sstssrssm-1.png){#fig-sstssrssm fig-align='center' width=80%}\n:::\n:::\n\n\n\n## $R^2$\n\nA useful statistic is the $R^2$, which shows us the proportion of the total variability in the outcome (`y`) that is explained by the linear relationship with the predictor (`x`).\n\n:::sticky\nThe $R^2$ coefficient is defined as the proportion of the total variability in the outcome variable which is explained by our model:  \n$$\nR^2 = \\frac{SS_{Model}}{SS_{Total}} = 1 - \\frac{SS_{Residual}}{SS_{Total}}\n$$\n:::\n\nWe can find the $R^2$ easily in the `summary()` of the model! \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(my_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = y ~ x, data = my_data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.4383 -0.6593  0.1075  0.5945  2.1867 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  1.54277    0.32005   4.820 5.24e-06 ***\nx            0.77952    0.09959   7.827 5.92e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.9308 on 98 degrees of freedom\nMultiple R-squared:  0.3847,\tAdjusted R-squared:  0.3784 \nF-statistic: 61.26 on 1 and 98 DF,  p-value: 5.918e-12\n```\n:::\n:::\n\n\nThe output of `summary()` displays the R-squared value in the following line:\n```\nMultiple R-squared:  0.3847\n```\n:::column-margin\nFor the moment, ignore \"Adjusted R-squared\". We will come back to this later on. \n:::\n\n:::int\nApproximately 38\\% of the total variability in `y` is explained by the linear association with `x`.\n:::\n\n::: {.callout-note collapse=\"true\"}\n#### Optional: Manual calculation of R-Squared   \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_model_fitted <- my_data %>%\n  mutate(\n    y_hat = predict(my_model),\n    resid = y - y_hat\n  )\nhead(my_model_fitted)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 Ã— 4\n      x     y y_hat  resid\n  <dbl> <dbl> <dbl>  <dbl>\n1  3.19  4.42  4.03  0.388\n2  2.57  4.48  3.54  0.941\n3  3.91  2.72  4.59 -1.87 \n4  4.79  5.39  5.28  0.107\n5  4.00  3.85  4.66 -0.809\n6  4.11  4.42  4.74 -0.327\n```\n:::\n\n```{.r .cell-code}\nmy_model_fitted %>%\n  summarise(\n    SSModel = sum( (y_hat - mean(y))^2 ),\n    SSTotal = sum( (y - mean(y))^2 )\n  ) %>%\n  summarise(\n    RSquared = SSModel / SSTotal\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 Ã— 1\n  RSquared\n     <dbl>\n1    0.385\n```\n:::\n:::\n\n\n:::\n\n\n## The $F$ Statistic\n\nThis will become more relevant in coming weeks, but we can also perform a test to investigate if the model is 'useful' --- that is, a test to see if the explanatory variable is a useful predictor of the outcome.  \nWe test the following hypotheses:\n\n$$\n\\begin{aligned}\nH_0 &: \\text{the model is ineffective, } b_1 = 0 \\\\\nH_1 &: \\text{the model is effective, } b_1 \\neq 0\n\\end{aligned}\n$$\n:::sticky\nThe relevant test-statistic is the F-statistic, which uses \"Mean Squares\" (these are Sums of Squares divided by the relevant degrees of freedom)\n\n$$\n\\begin{split}\nF = \\frac{MS_{Model}}{MS_{Residual}} = \\frac{SS_{Model} / 1}{SS_{Residual} / (n-2)}\n\\end{split}\n$$\n\nwhich compares the average amount of variation in the response explained by the model to the average amount of variation explained by the residuals.\n\nThe sample F-statistic is compared to an F-distribution with $df_{1} = 1$ and $df_{2} = n - 2$ degrees of freedom.^[\n$SS_{Total}$ has $n - 1$ degrees of freedom as one degree of freedom is lost in estimating the population mean with the sample mean $\\bar{y}$.\n$SS_{Residual}$ has $n - 2$ degrees of freedom. There are $n$ residuals, but two degrees of freedom are lost in estimating the intercept and slope of the line used to obtain the $\\hat y_i$s.\nHence, by difference, $SS_{Model}$ has $n - 1 - (n - 2) = 1$ degree of freedom.\n]\n\n::: {.callout-note collapse=\"true\"}\n#### Optional: Another formula for the F-test  \n\nWith some algebra we can also show that:\n$$\nF = \\frac{R^2 / 1}{(1 - R^2) / (n - 2) } = \\frac{R^2 / df_{Model}}{(1 - R^2) / df_{Residual} }\n$$\n\nProof:\n\n$$\n\\begin{aligned}\nF = \\frac{SS_{Model} / 1}{SS_{Residual} / (n - 2)} \n= \\frac{\\frac{SS_{Model}}{SS_{Total}}}{\\frac{SS_{Residual}}{SS_{Total}} \\cdot \\frac{1}{(n - 2)}} \n= \\frac{R^2 / 1}{(1 - R^2) / (n - 2)}\n\\end{aligned}\n$$\n:::\n\n:::\n\n\n\nLike the $R^2$, the `summary()` of our model prints out the $F$-statistic, degrees of freedom, and p-value. These are right at the bottom of the summary output, printed as:  \n\n```\nF-statistic: 61.26 on 1 and 98 DF,  p-value: 5.918e-12\n```\n\n:::int\nThe F-test of model utility was significant ($F(1,98) = 61.26,\\ p <.001$) suggesting that the model is effective in explaining variance in outcome $y$. \n:::\n\nNote that the p-value here is exactly the same as the one for the coefficient. This is because in testing \"the model is (in)effective\", the \"model\" is really _only_ the relationship between the outcome and our one predictor. When we move to adding more predictors into our model, we have more $b$'s, and the $F$-test will be testing jointly whether $b_1 = b_2 =\\ ...\\ = b_k = 0$.   \n\n\n\n::: {.callout-note collapse=\"true\"}\n#### Optional: With only one predictor variable, the F-test is equivalent to the t-test of the slope  \n\n**In simple linear regression only** (where we have just __one__ predictor), the F-statistic for overall model significance is equal to the square of the t-statistic for $H_0: b_1 = 0$.\n\nYou can check that the squared t-statistic is equal, up to rounding error, to the F-statistic:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(my_model)$fstatistic['value']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   value \n61.26497 \n```\n:::\n\n```{.r .cell-code}\nsummary(my_model)$coefficients['x','t value']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7.827194\n```\n:::\n:::\n\n$$\n\\begin{align}\n& t^2 = F \\\\\n& 7.827194^2 = 61.26497\n\\end{align}\n$$\n\nHere we will show the equivalence of the F-test for model effectiveness and t-test for the slope.\n\nRecall the formula of the sum of squares due to the model. We will rewrite it in an equivalent form below:\n$$\n\\begin{aligned}\nSS_{Model} &= \\sum_i (\\hat y_i - \\bar y)^2 \\\\\n&= \\sum_i (\\hat b_0 + \\hat b_1 x_i - \\bar y)^2 \\\\\n&= \\sum_i (\\bar y - \\hat b_1 \\bar x + \\hat b_1 x_i - \\bar y)^2 \\\\\n&= \\sum_i (\\hat b_1 (x_i - \\bar x))^2 \\\\\n&= \\hat b_1^2 \\sum_i (x_i - \\bar x)^2\n\\end{aligned}\n$$\n\nThe F-statistic is given by:\n$$\n\\begin{aligned}\nF = \\frac{SS_{Model} / 1}{SS_{Residual} / (n - 2)} \n= \\frac{\\hat b_1^2 \\sum_i (x_i - \\bar x)^2}{\\hat \\sigma^2} \n= \\frac{\\hat b_1^2 }{\\hat \\sigma^2 / \\sum_i (x_i - \\bar x)^2}\n\\end{aligned}\n$$\n\nNow recall the formula of the t-statistic,\n$$\nt = \\frac{\\hat b_1}{SE(\\hat b_1)} = \\frac{\\hat b_1}{\\hat \\sigma / \\sqrt{\\sum_i (x_i - \\bar x)^2}}\n$$\n\nIt is evident that the latter is obtained as the square root of the former.\n\n:::\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n\n# Binary Predictors\n\nLet's suppose that instead of having measured $x$ so accurately, we simply had information on whether $x>3$ or not. Our predictor variable would be binary categorical (think back to our discussion of types of data in [2A: Measurement](02a_measurement.html){target=\"_blank\"}) - it would have 2 levels:    \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmy_data <- \n  my_data %>% \n  mutate(\n    x_cat = ifelse(x < 3, \"level1\",\"level2\")\n  )\n```\n:::\n\n\nWe may then plot our relationship as a boxplot. If you want to see the individual points, you could always \"jitter\" them (right-hand plot below)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my_data, aes(x = x_cat, y = y)) + \n  geom_boxplot() +\nggplot(my_data, aes(x = x_cat, y = y)) + \n  geom_jitter(height=0, width=.05)\n```\n\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-27-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::statbox\n__Binary predictors in linear regression__\n\nWe can include categorical predictors in a linear regression, but the interpretation of the coefficients is very specific. Whereas we talked about coefficients being interpreted as \"the change in $y$ associated with a 1-unit increase in $x$\", for categorical explanatory variables, coefficients can be considered to examine differences in group means. However, they are actually doing exactly the same thing - the model is simply translating the levels (like \"Level1\"/\"Level2\", or \"Yes\"/\"No\", or \"High\"/\"Low\") in to 0s and 1s!  \nSo while we may have in our dataframe a categorical predictor like the middle column \"x_cat\", below, what is inputted into our model is more like the third column, \"isLevel2\". \n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100 Ã— 3\n       y x_cat  isLevel2\n   <dbl> <chr>     <dbl>\n 1  5.90 level2        1\n 2  4.82 level2        1\n 3  5.70 level2        1\n 4  4.81 level2        1\n 5  2.42 level1        0\n 6  3.82 level1        0\n 7  3.88 level1        0\n 8  5.57 level2        1\n 9  6.25 level2        1\n10  3.51 level2        1\n# â„¹ 90 more rows\n```\n:::\n:::\n\n\nOur coefficients are just the same as before. The intercept is where our predictor equals zero, and the slope is the change in our outcome variable associated with a 1-unit change in our predictor.  \n\nHowever, \"zero\" for this predictor variable now corresponds to a whole level. This is known as the \"reference level\". So the intercept is the estimated mean of $y$ when `x_cat == \"level1\"` (it will default to alphabetical, so \"level1\" will be treated as zero). Accordingly, the 1-unit change in our predictor (the move from \"zero\" to \"one\") corresponds to the estimated change in mean of $y$ when moving from \"level1\" to \"level2\" (i.e. the difference between the two levels). \n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-29-1.png){fig-align='center' width=80%}\n:::\n:::\n\n:::  \n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Assumptions\n\nAll our work here is in aim of making **models of the world**.  \n\n- Models are models. They are simplifications. They are therefore wrong.  \n- Our residuals ( $y - \\hat{y}$ ) reflect everything that we **don't** account for in our model.  \n- In an ideal world, our model accounts for _all_ the systematic relationships. The leftovers (our residuals) are just random noise.  \n- If our model is mis-specified, or we don't measure some systematic relationship, then our residuals will reflect this.  \nWe check by examining how much \"like randomness\" the residuals appear to be (zero mean, normally distributed, constant variance, i.i.d (\"independent and identically distributed\"). These ideas tend to get referred to as our __\"assumptions\".__  \n- While we will **never** know whether our residuals contain only randomness (we can never observe everything), our ability to generalise from the model we fit on sample data to the wider population relies on these assumptions.  \n\n:::statbox\n__Assumptions in a nutshell__   \n\nIn using linear regression, we have assumptions about our model in that we assume that modelling the outcome variable as a **linear** combination of the explanatory variables is an appropriate thing to do.  \nWe also make certain assumptions about what we have _left out_ of our model - the **errors** component.    \n<!-- $$ -->\n<!-- \\color{red}{y} = \\color{blue}{\\underbrace{\\beta_0 \\cdot{} 1 + \\beta_1 \\cdot{} x_1 + ... + \\beta_k \\cdot x_k}_{X \\boldsymbol \\beta}} + \\varepsilon -->\n<!-- $$ -->\n\nSpecifically, we assume that our errors have __\"zero mean and constant variance\"__.  \n\n- mean of the residuals = zero across the predicted values on the linear predictor.  \n- spread of residuals is normally distributed and constant across the predicted values on the linear predictor.  \n\n\n::: {.callout-note collapse=\"true\"}\n#### What does it look like?  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-30-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n#### What does it <b>not</b> look like?   \n\nThings look a bit wrong (like there is something systematic that we haven't accounted for), when our residuals do not have mean zero:  \n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-31-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nOr do not have constant variance: \n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-32-1.png){fig-align='center' width=80%}\n:::\n:::\n\n:::\n\n:::\n\n:::rtip\n__Assumptions in R__  \n\nWe can get a lot of plots for this kind of thing by using __plot(model)__\n\nHere's what it looks like for a nice neat model:  \n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(my_model)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-35-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n- Top Left: For the __Residuals vs Fitted__ plot, we want the red line to be horizontal at close to zero across the plot. We don't want the residuals (the points) to be fanning in/out.  \n- Top Right: For the __Normal Q-Q__ plot, we want the residuals (the points) to follow closely to the diagonal line, indicating that they are relatively normally distributed _(QQplots plot the values against the associated percentiles of the normal distribution. So if we had ten values, it would order them lowest to highest, then plot them on the y against the 10th, 20th, 30th.. and so on percentiles of the standard normal distribution (mean 0, SD 1))_.\n- Bottom Left: For the __Scale-Location__ plot, we want the red line to be horizontal across the plot. These plots allow us to examine the extent to which the variance of the residuals changes accross the fitted values. If it is angled, we are likely to see fanning in/out of the points in the residuals vs fitted plot.\n- Bottom Right: The __Residuals vs Leverage__ plot indicates points that might be of individual interest as they may be unduly influencing the model. There are funnel-shaped lines that will appear on this plot for messier data (not visible above as the data is too neat!), ideally, the further the residual is to the right, the closer to the 0 we want it to be. We'll look at this in more depth in a future reading. \n\n:::\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n\n# Example\n\n:::frame\n> **Research Question:** Is perceptual speed associated with age?  \n\nThe data for this example contains a sample of 130 participants all of whom are over the age of 65, with ages ranging from 67 to 88. All participants completed a short task measuring Perceptual Speed and Accuracy that scores from 0 to 50.  \n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nThe data are accessible at [https://uoepsy.github.io/data/usmr_percept1.csv](https://uoepsy.github.io/data/usmr_percept1.csv).  \n\n:::\n\n:::panelset\n\n:::panel\n#### Exploring \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npercdat <- read_csv(\"https://uoepsy.github.io/data/usmr_percept1.csv\")\n```\n:::\n\n\nSome visualisations:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplt1 <- \n  ggplot(percdat, aes(x = percept)) + \n  geom_density() +\n  geom_boxplot(width = 1/300)\n\nplt2 <- \n  ggplot(percdat, aes(x = age)) + \n  geom_density() +\n  geom_boxplot(width = 1/80)\n\nplt3 <- ggplot(percdat, aes(x = age, y = percept)) + \n  geom_point()\n\nlibrary(patchwork)\n(plt1 + plt2) / plt3\n```\n\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-38-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n:::panel\n#### Fitting  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np_model <- lm(percept ~ age, data = percdat)\nsummary(p_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = percept ~ age, data = percdat)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-23.771  -7.665   1.076   6.857  25.619 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  77.2111    21.8240   3.538 0.000563 ***\nage          -0.6951     0.2820  -2.465 0.015017 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 10.93 on 128 degrees of freedom\nMultiple R-squared:  0.04533,\tAdjusted R-squared:  0.03787 \nF-statistic: 6.077 on 1 and 128 DF,  p-value: 0.01502\n```\n:::\n:::\n\n\n:::\n:::panel\n#### Checking\n\nThese plots don't look too bad to me. The Residuals vs Fitted plot looks like a random cloud of points (which is good). The residuals look relatively normally distributed (see the QQ plot), and apart from at the lower end of the fitted values, the variance is fairly constant across (see the Scale-Location plot) - this may be due to scarcity of data from younger people. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(p_model)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-41-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n:::\n:::panel\n#### Interpreting\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncoef(p_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)         age \n 77.2111245  -0.6951299 \n```\n:::\n:::\n\n\n- `(Intercept)`: For someone of age zero, the estimated average score on the Perceptual Speed task is 77.2  \n- `age`: For each additional year of age, the estimated average score on the task is -0.695 points lower. \n\nNote the intercept isn't very useful here at all. It estimates the score for a newborn (who wouldn't be able to complete the task anyway). Furthermore, it estimates a score of 77, when the task only scores up to 50. This is because these models are _linear_, so the lines just keep on going outside of the range.  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(p_model)$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.04532774\n```\n:::\n:::\n\n\n- age explains approximately 4.5% of the variance in scores of the perceptual speed task. \n\n:::\n:::panel\n#### Visualising\n\nThere are lots of ways to visualise models, and lots of packages that are designed to help us.  \nOne such useful package:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(sjPlot)\nplot_model(p_model, \n           type = \"eff\",\n           show.data = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$age\n```\n:::\n\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-44-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n#### Optional: If we want to do it manually  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npercdat %>% \n  mutate(\n    # get the fitted values\n    fit = predict(p_model),\n    # get the SE at each level of fitted values\n    se = predict(p_model, se = TRUE)$se.fit,\n    # create confidence intervals\n    # df = 128 because we have 130 observations\n    c.lwr = fit - qt(.975, df = 128) * se,\n    c.upr = fit + qt(.975, df = 128) * se\n  ) %>%\n  # plot!\n  ggplot(., aes(x = age, y = percept))+\n  geom_point()+\n  geom_ribbon(aes(ymin = c.lwr, ymax = c.upr), alpha = .2) + \n  geom_line(aes(y = fit))\n```\n\n::: {.cell-output-display}\n![](05a_slr_files/figure-html/unnamed-chunk-45-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\n:::\n:::panel\n#### Tabulating\n\nThe same package (**sjPlot**) provides some nice quick ways to create regression tables (a bit like what we get from `summary(model)`, only presented a lot more nicely!)  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(sjPlot)\ntab_model(p_model)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table style=\"border-collapse:collapse; border:none;\">\n<tr>\n<th style=\"border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm;  text-align:left; \">&nbsp;</th>\n<th colspan=\"3\" style=\"border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm; \">percept</th>\n</tr>\n<tr>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  text-align:left; \">Predictors</td>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  \">Estimates</td>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  \">CI</td>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  \">p</td>\n</tr>\n<tr>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; \">(Intercept)</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">77.21</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">34.03&nbsp;&ndash;&nbsp;120.39</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \"><strong>0.001</strong></td>\n</tr>\n<tr>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; \">age</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">&#45;0.70</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">&#45;1.25&nbsp;&ndash;&nbsp;-0.14</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \"><strong>0.015</strong></td>\n</tr>\n<tr>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm; border-top:1px solid;\">Observations</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left; border-top:1px solid;\" colspan=\"3\">130</td>\n</tr>\n<tr>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;\">R<sup>2</sup> / R<sup>2</sup> adjusted</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;\" colspan=\"3\">0.045 / 0.038</td>\n</tr>\n\n</table>\n\n`````\n:::\n:::\n\n\n:::\n:::panel\n#### Writing up\n\nA total of 130 participants were included in the analysis, with ages ranging from 67 to 88 (Mean = 77.3, sd = 3.4). On average, participants scored 23.5 (SD = 11.1) on the perceptual speed task. \n\nA simple linear regression model was fitted, with scores on the perceptual speed task regressed on to age. A significant association was found, with scores on the task decreasing by -0.7 with every year of age ($b = -0.695$, $SE = 0.28$, $t(128)=-2.47$, $p = 0.015$), suggesting that perception may get worse in older age.   \n\n:::\n\n:::\n\n<div class=\"tocify-extend-page\" data-unique=\"tocify-extend-page\" style=\"height: 0;\"></div>\n",
    "supporting": [
      "05a_slr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/panelset-0.2.6/panelset.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/panelset-0.2.6/panelset.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}