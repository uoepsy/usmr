[
  {
    "objectID": "01_ex.html",
    "href": "01_ex.html",
    "title": "Exercises: Intro R",
    "section": "",
    "text": "First things\nThe very first things to do are to open RStudio and get a blank script ready for writing your code!\n\n\nOur recommendation is that you have an R project for this course, and use a new script for each week of work. See the tip about “R projects” in Section 1A.\n\n\nPet Data\n\nWe’re going to play with some data on a sample of licensed pets from the city of Seattle, USA. It can be downloaded (or read directly into R) from https://uoepsy.github.io/data/pets_seattle.csv. It contains information on the license ID, year of issue, as well as the species, breeds and weights of each pet. You can find a data dictionary in Table 1\n\n\n\n\nTable 1: Seattle Pets: Data dictionary\n\n\nVariable\nDescription\n\n\n\n\nlicense_year\nYear in which license was issued\n\n\nlicense_number\nUnique license ID number\n\n\nanimals_name\nFull name of pet\n\n\nspecies\nSpecies of pet\n\n\nprimary_breed\nPrimary breed of pet\n\n\nsecondary_breed\nSecondary breed of pet\n\n\nweight_kg\nWeight in kilograms\n\n\n\n\n\n\n\n\nQuestion 1\n\n\nWrite a line of code that reads in the data to your R session. Then examine the dimensions of the dataset, and take a look at the first few lines.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou’ll need the read.csv() function. Remember to assign it a name to store it in your environment.\n1B #basic-data-wrangling contains an example of reading in data from a URL. You’ll then want to play with functions like dim() and head().\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe’re going to call it petdata in our environment here. Don’t forget the quotation marks around the url (otherwise R will look for an object in your environment called https://..., which isn’t there).\n\npetdata&lt;-read.csv(\"https://uoepsy.github.io/data/pets_seattle.csv\")\ndim(petdata)\n\n[1] 1956    7\n\n\nWe can see there are 1956 rows and 7 columns.\nAnd we can see the first few rows here:\n\nhead(petdata)\n\n  license_year license_number  animals_name species         primary_breed\n1         2018      LNS150171        Norman     Dog                 Boxer\n2         2017        LN20666         Henry     Dog          Bichon Frise\n3         2018      LN8000658 Vega Williams     Dog                   Mix\n4         2018       LN730940         Molly     Dog   Australian Shepherd\n5         2016       LN964607         Gremy     Dog Chihuahua, Short Coat\n6         2018      LNS117115        Shadow     Dog   Retriever, Labrador\n  secondary_breed weight_kg\n1             Mix     29.15\n2        Havanese     23.70\n3         Unknown     21.13\n4             Mix     18.70\n5         Terrier     20.36\n6         Unknown     11.51\n\n\n\n\n\n\nQuestion 2\n\n\nWhat are the names of the 47th and the 200th animals in the dataset? (use R code to find out)\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou’ll probably want to make use of the square brackets data[rows, columns].\n\n\n\n\n\n\n\n\nSolution\n\n\n\nThere are lots of different ways to do this. We can get out the entire rows, either individually:\n\npetdata[47,]\npetdata[200,]\n\nOr together:\n\npetdata[c(47,200),]\n\n    license_year license_number animals_name species       primary_breed\n47          2018      LNS140233     Hooligan     Dog Retriever, Labrador\n200         2017       LN584186  Maple Syrup     Cat  Domestic Shorthair\n    secondary_breed weight_kg\n47          Unknown     12.27\n200         Unknown      4.66\n\n\nOr we can extract the names only:\n\n# These all do the same\npetdata[c(47,200),\"animals_name\"]\npetdata[c(47,200),3]\npetdata$animals_name[c(47,200)]\n\nThe will all give us these names:\n\n\n[1] \"Hooligan\"    \"Maple Syrup\"\n\n\nIn the last one, we use the $ to access the animals_name variable. In this case, we don’t need to specify [rows, columns] inside the square brackets, because it’s a single variable - there are no columns.\n\ndataframe[rows, columns]\n\nvariable[entries]\n\n\n\n\n\nQuestion 3\n\n\nSubset the data to only the animals which are dogs, and store this subset as another named object in your environment.\nDo the same for the cats.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou’ll want to think about how we access data via asking for those entries that meet a specific condition (see 1B #accessing-by-a-condition)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe can ask “which entries of species variable are equal to ‘Dog’?” by using pet$species==\"Dog\".\nThis will give us a TRUE for each dog, and a FALSE for each non-dog.\nWe can then use this set of TRUEs and FALSEs to access those rows for which it is TRUE in our data:\n\ndogdata &lt;- petdata[petdata$species==\"Dog\", ]\ncatdata &lt;- petdata[petdata$species==\"Cat\", ]\n\n\n\n\n\nQuestion 4\n\n\nFind the name and weight of the heaviest cat, and of the lightest dog.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou could do this using the original data you read in from question 1, or use the subsets you created in question 3. You’ll again want to supply a condition within square brackets data[?==?]. That condition may well have something to do with being equal to the min() or the max() of some variable.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe can use min() and max() to return the minimum and maximum of a variable:\n\nmin(dogdata$weight_kg)\n\n[1] 0.39\n\nmax(catdata$weight_kg)\n\n[1] 5.48\n\n\nWe could then ask for each entry “is this cat’s weight the maximum cat’s weight?” with catdata$weight_kg == max(catdata$weight_kg) and then use that condition to access the rows in our dataset where the weight_kg variable is at its maximum:\n\ncatdata[catdata$weight_kg == max(catdata$weight_kg), ]\n\n    license_year license_number animals_name species      primary_breed\n414         2018      LNS101014       Smokey     Cat Domestic Shorthair\n    secondary_breed weight_kg\n414             Mix      5.48\n\ndogdata[dogdata$weight_kg == min(dogdata$weight_kg), ]\n\n     license_year license_number animals_name species  primary_breed\n1126         2017      LNS139134       Claire     Dog Great Pyrenees\n     secondary_breed weight_kg\n1126         Unknown      0.39\n\n\n\n\n\n\nQuestion 5\n\n\nDoes the original dataset contain only dogs and cats?\n\n\n\n\n\n\nHints\n\n\n\n\n\nGiven what you did in question 3, you might be able to answer this by just looking at your environment.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nIn the environment, we can see that the entire dataset has 1956 observations, the Dog’s data frame has 1322, and the Cat’s has 632.\nSo there are 2 missing!\n\n\n\n\nQuestion 6\n\n\nExtract the entries of the original dataset for which the species is neither “Dog” nor “Cat”?\nWhat are the names and species of these animals?\n\n\n\n\n\n\nHints\n\n\n\n\n\nThis is a slightly complex one. 1B #more-complex-conditions might help you here.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAs always, there are lots of different ways.\nHere are three:\n\n\n“not a dog AND not a cat”\nWe can ask if something is not a dog by using petdata$species != \"Dog\". But we want the rows where the species is not a dog and it’s not a cat. So it’s two conditions:\n\npetdata[petdata$species != \"Cat\" & petdata$species != \"Dog\", ]\n\n     license_year license_number     animals_name species primary_breed\n1505         2018      LNS147013    Billy the Kid    Goat     Miniature\n1655         2018      LNS132953 Vincent Van Goat    Goat     Miniature\n     secondary_breed weight_kg\n1505         Unknown    103.48\n1655         Unknown     73.96\n\n\n\n\n“not (dog OR cat)”\nWe could also do this in other ways, such as asking for all the entries which are either “Dog” or “Cat”, and then negating them:\n\npetdata[!(petdata$species == \"Cat\" | petdata$species == \"Dog\"), ]\n\n     license_year license_number     animals_name species primary_breed\n1505         2018      LNS147013    Billy the Kid    Goat     Miniature\n1655         2018      LNS132953 Vincent Van Goat    Goat     Miniature\n     secondary_breed weight_kg\n1505         Unknown    103.48\n1655         Unknown     73.96\n\n\n\n\n“not one of [Dog, Cat]”\nAnother clever little operator is the %in% operator, which asks whether something is in a set of things. Unfortunately, we can’t use !%in% to mean “not in”, so we need to put the ! right at the start of the condition:\n\npetdata[!petdata$species %in% c(\"Cat\",\"Dog\"), ]\n\n     license_year license_number     animals_name species primary_breed\n1505         2018      LNS147013    Billy the Kid    Goat     Miniature\n1655         2018      LNS132953 Vincent Van Goat    Goat     Miniature\n     secondary_breed weight_kg\n1505         Unknown    103.48\n1655         Unknown     73.96\n\n\n\n\n\n\n\n\nQuestion 7\n\n\nCreate a new variable in the data, which contains the weights of all the animals, but rounded to the nearest kg.\n\n\n\n\n\n\nHints\n\n\n\n\n\nTry looking up the help documentation for the function round(). Try playing with it in the console, e.g. round(c(3.5, 4.257, 1.1111)). You may find it helpful to look back at 1B #adding/changing-a-variable.\n\n“to the nearest kg” would mean we want no decimal points. Note that round() has a digits argument. e.g. round(22.324, digits = 2) and round(22.324, digits = 1) do different things.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe’re wanting this variable as a new column in the data, so don’t forget the dataframe$newvariable &lt;- ...... bit.\n\npetdata$weight_rounded &lt;- round(petdata$weight_kg)\n\n\n\n\n\nQuestion 8\n\n\nTry giving the dataset to the function summary(). You’ll get out some information on each of the variables. It is likely that you’ll get more useful information for the variables containing information on the animal’s weights than for those containing their names, breeds etc because these variables are vectors of “characters”. We’ll start to look more about different types of data next week.\n\n\n\n\n\nSolution\n\n\n\nEasy to do!\n\nsummary(petdata)\n\n  license_year  license_number     animals_name         species         \n Min.   :2015   Length:1956        Length:1956        Length:1956       \n 1st Qu.:2017   Class :character   Class :character   Class :character  \n Median :2018   Mode  :character   Mode  :character   Mode  :character  \n Mean   :2018                                                           \n 3rd Qu.:2018                                                           \n Max.   :2018                                                           \n primary_breed      secondary_breed      weight_kg       weight_rounded \n Length:1956        Length:1956        Min.   :  0.390   Min.   :  0.0  \n Class :character   Class :character   1st Qu.:  4.707   1st Qu.:  5.0  \n Mode  :character   Mode  :character   Median : 16.630   Median : 17.0  \n                                       Mean   : 15.312   Mean   : 15.3  \n                                       3rd Qu.: 22.500   3rd Qu.: 22.0  \n                                       Max.   :103.480   Max.   :103.0  \n\n\n\n\n\n\n\n\n\n\nSimulating Dice\n\nQuestion 9\n\n\nCopy the code from the lecture which creates a custom function called dice() (copied below).\nBe sure to run the code (highlight it all with your cursor, and hit “run” in the top right, or press Ctrl/Cmd+Enter).\n\ndice &lt;- function(num = 1) {\n  sum(sample(1:6, num, replace=TRUE))\n}\n\n\n\n\n\nWhat did that code do?\nIn a sense, this code does nothing: It won’t give you any output when you run it. What it is actually doing, though, is defining a function called dice(). If you look at your environment panel (top right), you’ll see dice appear when you run the code.\nTo produce some output, we have to call the function dice() (by writing it into code: dice(4), for example). dice() wants to be supplied with some information (in the argument num). If no information is supplied, num will take a default value of 1. (So writing dice() is equivalent to writing dice(1)).\nWhat does dice() do with num? It calls another function, sample(), with 3 arguments. We didn’t write sample(): it’s a function that’s “supplied with” R. To find out more about what sample() does:\n\nclick inside the brackets just after sample() in your R script;\npress TAB (⇥), then F1\nyou should see some help appear in the bottom right-hand panel of RStudio.\n\nYou will find that “sample() takes a sample … from the elements of x …” If you compare the code in RStudio to the code under “Usage” you’ll see that where the help has x, we have 1:6. So what does 1:6 mean? One way to find out is to open the console in RStudio (bottom left) and just type stuff in. What happens when you type 1:6? What about 2:17? (What about 6:1?)\nRemember: The console is the place to “try stuff out” (don’t worry, you can’t break it).\nWhat you will discover is that 1:6 creates a vector (list of similar things, in this case numbers) of the numbers 1-6. The next bit of the sample() function is size. In the dice() function, the num passes down to the size of the sample(): Looking through the help, size is the number of items to choose. So sample(1:6, 1) would choose one number from the numbers 1-6 at random; sample(1:6, 3) would choose 3, and so on. The last argument, replace=TRUE, tells sample() what to do with a number once it’s been picked: Does it go ‘back into the bag’ to be picked again (TRUE) or not? (FALSE)?\nAround the outside is sum() which simply sums the numbers on however many (num) dice you “rolled”.\nPutting it all together, our dice() function “throws num dice” by sample()ing from the numbers 1-6 num times, replaceing each number when it’s been picked, and sums the numbers of all the dice.\n\n\nQuestion 10\n\n\nUse the function you just made to ‘roll a die’ a few times. Check that it works like you expect.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou just need to run dice() a few times. A single die means num = 1, which is the default.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\ndice()\n\n[1] 4\n\ndice()\n\n[1] 3\n\ndice()\n\n[1] 5\n\ndice()\n\n[1] 5\n\n\n\n\n\n\nQuestion 11\n\n\nLook up the function replicate(). We can use it to do something in R lots of times! For instance, replicate(20, 1+1) will evaluate 1+1 twenty times.\nUse replicate() to simulate 20 rolls of a single die, and store the results in an object in your environment. Give it an easily identifiable name.\nWhat does each value in this object represent?\n\n\n\n\n\nSolution\n\n\n\n\nrolls20 &lt;- replicate(20, dice(num = 1))\nrolls20\n\n [1] 3 5 6 3 6 4 2 1 1 2 5 4 5 4 2 5 1 5 2 1\n\n\nEach value in rolls20 represents the simulated roll of a single die. We roll our die, and get a 3, we roll it again and get 5, the third roll we get 6, and so on..\n\n\n\n\nQuestion 12\n\n\nCreate a barplot showing the frequency with which each number was landed on in the 20 rolls.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThe functions table() and barplot() were used to do this in the lecture.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nYour plots will look slightly different to these, because all of our dice are random!\n\n# We can get the frequency table using table()\ntable(rolls20)\n\nrolls20\n1 2 3 4 5 6 \n4 4 2 3 5 2 \n\n# Which we can then pass to the barplot() function:\nbarplot(table(rolls20))\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 13\n\n\nDo the same for 100 rolls, and then for 1,000. What do you notice?\n\n\n\n\n\nSolution\n\n\n\n\nmorerolls &lt;- replicate(100, dice(1))\nbarplot(table(morerolls))\n\n\n\n\n\n\n\nmorerolls2 &lt;- replicate(1000, dice(1))\nbarplot(table(morerolls2))\n\n\n\n\n\n\n\n\nThe more rolls we do of the dice, the flatter the graph becomes. This is because there is an equal probability of the die landing on any of the responses - there is a uniform probability.\n\n\n\n\nQuestion 14\n\n\nCopy the code below into your script and run it. It creates a new function called wdice() which simulates the rolling of num dice which are slightly weighted.\nRoll a single weighted die 20 times and plot the frequency distribution. Do the same for 100 and 1,000 rolls of a single die. Does a pattern emerge? At how many rolls?\n\nwdice &lt;- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n\n\n\n\n\n\nSolution\n\n\n\n\nwdice &lt;- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n\nwd &lt;- replicate(20, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\nwd &lt;- replicate(1000, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\nwd &lt;- replicate(10000, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\n\nThe die is clearly weighted towards landing on 6. However, is 20 rolls enough to reliably observe this? In our 20 rolls above, it landed on 3 quite a bit too (yours will be different)! The pattern becomes clearer after 1000 rolls.\n\n\n\n\nQuestion 15\n\n\nRemember, wdice() and dice() are really just relying on different functions, like sample(). Try playing around with sample() in the console again - what does the prob = c(....) bit do?\n\n\n\n\n\nSolution\n\n\n\nThe prob bit is defining the probabilities of observing each outcome - i.e. there is a 25% chance of rolling a 6.\n\n\n\n\nQuestion 16\n\n\nLet’s try to modify the wdice() function. Edit the code for wdice() so that 50% of the time it lands on number 6.\n\n\n\n\n\n\nHints\n\n\n\n\n\n\nTo test out your modified function, you will need to re-run the code which defines the function. When we use wdice() we use the function which is in our environment. If we want to edit the function, we need to then overwrite (or “replace”/“reassign”) the object in our environment.\n\nWe need to be careful to remember that the probability of different outcomes should sum to 1 (i.e., it’s not possible to “50% of the time land on 6” as well as “70% of the time land on 5”!).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nwdice &lt;- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.1,0.1,0.1,0.1,0.1,0.5)))\n}\n\n\n\n\n\nQuestion 17\n\n\nCan you observe the weighting in your new die (the one which 50% of the time lands on number 6) in only 20 rolls?\n\n\n\n\n\nSolution\n\n\n\n\nwd &lt;- replicate(20, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\n\nThe die is very clearly weighted to land on 6. We can see this in just 20 rolls. Presumably it will become even clearer if we increased how many times we roll it.\n\n\n\n\nQuestion 18\n\n\nConceptually, what can we learn from this toy example?\n\n\n\n\n\nSolution\n\n\n\nThe more highly weighted a die is, the less we have to roll it in order to observe that weighting."
  },
  {
    "objectID": "01_exCROCODILE.html",
    "href": "01_exCROCODILE.html",
    "title": "Exercises: Intro R",
    "section": "",
    "text": "First things\nThe very first things to do are to open RStudio and get a blank script ready for writing your code!\n\n\nOur recommendation is that you have an R project for this course, and use a new script for each week of work. See the tip about “R projects” in Section 1A.\n\n\nPet Data\n\nWe’re going to play with some data on a sample of licensed pets from the city of Seattle, USA. It can be downloaded (or read directly into R) from https://uoepsy.github.io/data/pets_seattle.csv. It contains information on the license ID, year of issue, as well as the species, breeds and weights of each pet. You can find a data dictionary in Table 1\n\n\n\n\nTable 1: Seattle Pets: Data dictionary\n\n\nVariable\nDescription\n\n\n\n\nlicense_year\nYear in which license was issued\n\n\nlicense_number\nUnique license ID number\n\n\nanimals_name\nFull name of pet\n\n\nspecies\nSpecies of pet\n\n\nprimary_breed\nPrimary breed of pet\n\n\nsecondary_breed\nSecondary breed of pet\n\n\nweight_kg\nWeight in kilograms\n\n\n\n\n\n\n\n\nQuestion 1\n\n\nWrite a line of code that reads in the data to your R session. Then examine the dimensions of the dataset, and take a look at the first few lines.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou’ll need the read.csv() function. Remember to assign it a name to store it in your environment.\n1B #basic-data-wrangling contains an example of reading in data from a URL. You’ll then want to play with functions like dim() and head().\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe’re going to call it petdata in our environment here. Don’t forget the quotation marks around the url (otherwise R will look for an object in your environment called https://..., which isn’t there).\n\npetdata&lt;-read.csv(\"https://uoepsy.github.io/data/pets_seattle.csv\")\ndim(petdata)\n\n[1] 1956    7\n\n\nWe can see there are 1956 rows and 7 columns.\nAnd we can see the first few rows here:\n\nhead(petdata)\n\n  license_year license_number  animals_name species         primary_breed\n1         2018      LNS150171        Norman     Dog                 Boxer\n2         2017        LN20666         Henry     Dog          Bichon Frise\n3         2018      LN8000658 Vega Williams     Dog                   Mix\n4         2018       LN730940         Molly     Dog   Australian Shepherd\n5         2016       LN964607         Gremy     Dog Chihuahua, Short Coat\n6         2018      LNS117115        Shadow     Dog   Retriever, Labrador\n  secondary_breed weight_kg\n1             Mix     29.15\n2        Havanese     23.70\n3         Unknown     21.13\n4             Mix     18.70\n5         Terrier     20.36\n6         Unknown     11.51\n\n\n\n\n\n\nQuestion 2\n\n\nWhat are the names of the 47th and the 200th animals in the dataset? (use R code to find out)\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou’ll probably want to make use of the square brackets data[rows, columns].\n\n\n\n\n\n\n\n\nSolution\n\n\n\nThere are lots of different ways to do this. We can get out the entire rows, either individually:\n\npetdata[47,]\npetdata[200,]\n\nOr together:\n\npetdata[c(47,200),]\n\n    license_year license_number animals_name species       primary_breed\n47          2018      LNS140233     Hooligan     Dog Retriever, Labrador\n200         2017       LN584186  Maple Syrup     Cat  Domestic Shorthair\n    secondary_breed weight_kg\n47          Unknown     12.27\n200         Unknown      4.66\n\n\nOr we can extract the names only:\n\n# These all do the same\npetdata[c(47,200),\"animals_name\"]\npetdata[c(47,200),3]\npetdata$animals_name[c(47,200)]\n\nThe will all give us these names:\n\n\n[1] \"Hooligan\"    \"Maple Syrup\"\n\n\nIn the last one, we use the $ to access the animals_name variable. In this case, we don’t need to specify [rows, columns] inside the square brackets, because it’s a single variable - there are no columns.\n\ndataframe[rows, columns]\n\nvariable[entries]\n\n\n\n\n\nQuestion 3\n\n\nSubset the data to only the animals which are dogs, and store this subset as another named object in your environment.\nDo the same for the cats.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou’ll want to think about how we access data via asking for those entries that meet a specific condition (see 1B #accessing-by-a-condition)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe can ask “which entries of species variable are equal to ‘Dog’?” by using pet$species==\"Dog\".\nThis will give us a TRUE for each dog, and a FALSE for each non-dog.\nWe can then use this set of TRUEs and FALSEs to access those rows for which it is TRUE in our data:\n\ndogdata &lt;- petdata[petdata$species==\"Dog\", ]\ncatdata &lt;- petdata[petdata$species==\"Cat\", ]\n\n\n\n\n\nQuestion 4\n\n\nFind the name and weight of the heaviest cat, and of the lightest dog.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou could do this using the original data you read in from question 1, or use the subsets you created in question 3. You’ll again want to supply a condition within square brackets data[?==?]. That condition may well have something to do with being equal to the min() or the max() of some variable.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe can use min() and max() to return the minimum and maximum of a variable:\n\nmin(dogdata$weight_kg)\n\n[1] 0.39\n\nmax(catdata$weight_kg)\n\n[1] 5.48\n\n\nWe could then ask for each entry “is this cat’s weight the maximum cat’s weight?” with catdata$weight_kg == max(catdata$weight_kg) and then use that condition to access the rows in our dataset where the weight_kg variable is at its maximum:\n\ncatdata[catdata$weight_kg == max(catdata$weight_kg), ]\n\n    license_year license_number animals_name species      primary_breed\n414         2018      LNS101014       Smokey     Cat Domestic Shorthair\n    secondary_breed weight_kg\n414             Mix      5.48\n\ndogdata[dogdata$weight_kg == min(dogdata$weight_kg), ]\n\n     license_year license_number animals_name species  primary_breed\n1126         2017      LNS139134       Claire     Dog Great Pyrenees\n     secondary_breed weight_kg\n1126         Unknown      0.39\n\n\n\n\n\n\nQuestion 5\n\n\nDoes the original dataset contain only dogs and cats?\n\n\n\n\n\n\nHints\n\n\n\n\n\nGiven what you did in question 3, you might be able to answer this by just looking at your environment.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nIn the environment, we can see that the entire dataset has 1956 observations, the Dog’s data frame has 1322, and the Cat’s has 632.\nSo there are 2 missing!\n\n\n\n\nQuestion 6\n\n\nExtract the entries of the original dataset for which the species is neither “Dog” nor “Cat”?\nWhat are the names and species of these animals?\n\n\n\n\n\n\nHints\n\n\n\n\n\nThis is a slightly complex one. 1B #more-complex-conditions might help you here.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAs always, there are lots of different ways.\nHere are three:\n\n\n“not a dog AND not a cat”\nWe can ask if something is not a dog by using petdata$species != \"Dog\". But we want the rows where the species is not a dog and it’s not a cat. So it’s two conditions:\n\npetdata[petdata$species != \"Cat\" & petdata$species != \"Dog\", ]\n\n     license_year license_number     animals_name species primary_breed\n1505         2018      LNS147013    Billy the Kid    Goat     Miniature\n1655         2018      LNS132953 Vincent Van Goat    Goat     Miniature\n     secondary_breed weight_kg\n1505         Unknown    103.48\n1655         Unknown     73.96\n\n\n\n\n“not (dog OR cat)”\nWe could also do this in other ways, such as asking for all the entries which are either “Dog” or “Cat”, and then negating them:\n\npetdata[!(petdata$species == \"Cat\" | petdata$species == \"Dog\"), ]\n\n     license_year license_number     animals_name species primary_breed\n1505         2018      LNS147013    Billy the Kid    Goat     Miniature\n1655         2018      LNS132953 Vincent Van Goat    Goat     Miniature\n     secondary_breed weight_kg\n1505         Unknown    103.48\n1655         Unknown     73.96\n\n\n\n\n“not one of [Dog, Cat]”\nAnother clever little operator is the %in% operator, which asks whether something is in a set of things. Unfortunately, we can’t use !%in% to mean “not in”, so we need to put the ! right at the start of the condition:\n\npetdata[!petdata$species %in% c(\"Cat\",\"Dog\"), ]\n\n     license_year license_number     animals_name species primary_breed\n1505         2018      LNS147013    Billy the Kid    Goat     Miniature\n1655         2018      LNS132953 Vincent Van Goat    Goat     Miniature\n     secondary_breed weight_kg\n1505         Unknown    103.48\n1655         Unknown     73.96\n\n\n\n\n\n\n\n\nQuestion 7\n\n\nCreate a new variable in the data, which contains the weights of all the animals, but rounded to the nearest kg.\n\n\n\n\n\n\nHints\n\n\n\n\n\nTry looking up the help documentation for the function round(). Try playing with it in the console, e.g. round(c(3.5, 4.257, 1.1111)). You may find it helpful to look back at 1B #adding/changing-a-variable.\n\n“to the nearest kg” would mean we want no decimal points. Note that round() has a digits argument. e.g. round(22.324, digits = 2) and round(22.324, digits = 1) do different things.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe’re wanting this variable as a new column in the data, so don’t forget the dataframe$newvariable &lt;- ...... bit.\n\npetdata$weight_rounded &lt;- round(petdata$weight_kg)\n\n\n\n\n\nQuestion 8\n\n\nTry giving the dataset to the function summary(). You’ll get out some information on each of the variables. It is likely that you’ll get more useful information for the variables containing information on the animal’s weights than for those containing their names, breeds etc because these variables are vectors of “characters”. We’ll start to look more about different types of data next week.\n\n\n\n\n\nSolution\n\n\n\nEasy to do!\n\nsummary(petdata)\n\n  license_year  license_number     animals_name         species         \n Min.   :2015   Length:1956        Length:1956        Length:1956       \n 1st Qu.:2017   Class :character   Class :character   Class :character  \n Median :2018   Mode  :character   Mode  :character   Mode  :character  \n Mean   :2018                                                           \n 3rd Qu.:2018                                                           \n Max.   :2018                                                           \n primary_breed      secondary_breed      weight_kg       weight_rounded \n Length:1956        Length:1956        Min.   :  0.390   Min.   :  0.0  \n Class :character   Class :character   1st Qu.:  4.707   1st Qu.:  5.0  \n Mode  :character   Mode  :character   Median : 16.630   Median : 17.0  \n                                       Mean   : 15.312   Mean   : 15.3  \n                                       3rd Qu.: 22.500   3rd Qu.: 22.0  \n                                       Max.   :103.480   Max.   :103.0  \n\n\n\n\n\n\n\n\n\n\nSimulating Dice\n\nQuestion 9\n\n\nCopy the code from the lecture which creates a custom function called dice() (copied below).\nBe sure to run the code (highlight it all with your cursor, and hit “run” in the top right, or press Ctrl/Cmd+Enter).\n\ndice &lt;- function(num = 1) {\n  sum(sample(1:6, num, replace=TRUE))\n}\n\n\n\n\n\nWhat did that code do?\nIn a sense, this code does nothing: It won’t give you any output when you run it. What it is actually doing, though, is defining a function called dice(). If you look at your environment panel (top right), you’ll see dice appear when you run the code.\nTo produce some output, we have to call the function dice() (by writing it into code: dice(4), for example). dice() wants to be supplied with some information (in the argument num). If no information is supplied, num will take a default value of 1. (So writing dice() is equivalent to writing dice(1)).\nWhat does dice() do with num? It calls another function, sample(), with 3 arguments. We didn’t write sample(): it’s a function that’s “supplied with” R. To find out more about what sample() does:\n\nclick inside the brackets just after sample() in your R script;\npress TAB (⇥), then F1\nyou should see some help appear in the bottom right-hand panel of RStudio.\n\nYou will find that “sample() takes a sample … from the elements of x …” If you compare the code in RStudio to the code under “Usage” you’ll see that where the help has x, we have 1:6. So what does 1:6 mean? One way to find out is to open the console in RStudio (bottom left) and just type stuff in. What happens when you type 1:6? What about 2:17? (What about 6:1?)\nRemember: The console is the place to “try stuff out” (don’t worry, you can’t break it).\nWhat you will discover is that 1:6 creates a vector (list of similar things, in this case numbers) of the numbers 1-6. The next bit of the sample() function is size. In the dice() function, the num passes down to the size of the sample(): Looking through the help, size is the number of items to choose. So sample(1:6, 1) would choose one number from the numbers 1-6 at random; sample(1:6, 3) would choose 3, and so on. The last argument, replace=TRUE, tells sample() what to do with a number once it’s been picked: Does it go ‘back into the bag’ to be picked again (TRUE) or not? (FALSE)?\nAround the outside is sum() which simply sums the numbers on however many (num) dice you “rolled”.\nPutting it all together, our dice() function “throws num dice” by sample()ing from the numbers 1-6 num times, replaceing each number when it’s been picked, and sums the numbers of all the dice.\n\n\nQuestion 10\n\n\nUse the function you just made to ‘roll a die’ a few times. Check that it works like you expect.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou just need to run dice() a few times. A single die means num = 1, which is the default.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\ndice()\n\n[1] 5\n\ndice()\n\n[1] 5\n\ndice()\n\n[1] 1\n\ndice()\n\n[1] 2\n\n\n\n\n\n\nQuestion 11\n\n\nLook up the function replicate(). We can use it to do something in R lots of times! For instance, replicate(20, 1+1) will evaluate 1+1 twenty times.\nUse replicate() to simulate 20 rolls of a single die, and store the results in an object in your environment. Give it an easily identifiable name.\nWhat does each value in this object represent?\n\n\n\n\n\nSolution\n\n\n\n\nrolls20 &lt;- replicate(20, dice(num = 1))\nrolls20\n\n [1] 6 3 1 6 3 3 2 6 5 3 1 4 5 4 2 5 2 2 6 5\n\n\nEach value in rolls20 represents the simulated roll of a single die. We roll our die, and get a 6, we roll it again and get 3, the third roll we get 1, and so on..\n\n\n\n\nQuestion 12\n\n\nCreate a barplot showing the frequency with which each number was landed on in the 20 rolls.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThe functions table() and barplot() were used to do this in the lecture.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nYour plots will look slightly different to these, because all of our dice are random!\n\n# We can get the frequency table using table()\ntable(rolls20)\n\nrolls20\n1 2 3 4 5 6 \n2 4 4 2 4 4 \n\n# Which we can then pass to the barplot() function:\nbarplot(table(rolls20))\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 13\n\n\nDo the same for 100 rolls, and then for 1,000. What do you notice?\n\n\n\n\n\nSolution\n\n\n\n\nmorerolls &lt;- replicate(100, dice(1))\nbarplot(table(morerolls))\n\n\n\n\n\n\n\nmorerolls2 &lt;- replicate(1000, dice(1))\nbarplot(table(morerolls2))\n\n\n\n\n\n\n\n\nThe more rolls we do of the dice, the flatter the graph becomes. This is because there is an equal probability of the die landing on any of the responses - there is a uniform probability.\n\n\n\n\nQuestion 14\n\n\nCopy the code below into your script and run it. It creates a new function called wdice() which simulates the rolling of num dice which are slightly weighted.\nRoll a single weighted die 20 times and plot the frequency distribution. Do the same for 100 and 1,000 rolls of a single die. Does a pattern emerge? At how many rolls?\n\nwdice &lt;- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n\n\n\n\n\n\nSolution\n\n\n\n\nwdice &lt;- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n\nwd &lt;- replicate(20, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\nwd &lt;- replicate(1000, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\nwd &lt;- replicate(10000, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\n\nThe die is clearly weighted towards landing on 6. However, is 20 rolls enough to reliably observe this? In our 20 rolls above, it landed on 3 quite a bit too (yours will be different)! The pattern becomes clearer after 1000 rolls.\n\n\n\n\nQuestion 15\n\n\nRemember, wdice() and dice() are really just relying on different functions, like sample(). Try playing around with sample() in the console again - what does the prob = c(....) bit do?\n\n\n\n\n\nSolution\n\n\n\nThe prob bit is defining the probabilities of observing each outcome - i.e. there is a 25% chance of rolling a 6.\n\n\n\n\nQuestion 16\n\n\nLet’s try to modify the wdice() function. Edit the code for wdice() so that 50% of the time it lands on number 6.\n\n\n\n\n\n\nHints\n\n\n\n\n\n\nTo test out your modified function, you will need to re-run the code which defines the function. When we use wdice() we use the function which is in our environment. If we want to edit the function, we need to then overwrite (or “replace”/“reassign”) the object in our environment.\n\nWe need to be careful to remember that the probability of different outcomes should sum to 1 (i.e., it’s not possible to “50% of the time land on 6” as well as “70% of the time land on 5”!).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nwdice &lt;- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.1,0.1,0.1,0.1,0.1,0.5)))\n}\n\n\n\n\n\nQuestion 17\n\n\nCan you observe the weighting in your new die (the one which 50% of the time lands on number 6) in only 20 rolls?\n\n\n\n\n\nSolution\n\n\n\n\nwd &lt;- replicate(20, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\n\nThe die is very clearly weighted to land on 6. We can see this in just 20 rolls. Presumably it will become even clearer if we increased how many times we roll it.\n\n\n\n\nQuestion 18\n\n\nConceptually, what can we learn from this toy example?\n\n\n\n\n\nSolution\n\n\n\nThe more highly weighted a die is, the less we have to roll it in order to observe that weighting."
  },
  {
    "objectID": "01a_R.html",
    "href": "01a_R.html",
    "title": "1A: A first look at R & RStudio",
    "section": "",
    "text": "This reading:\n\nHow does R work?\nHow do we use the Rstudio interface?\n\n\nThe best way to learn R is to use it. Try following along with these reading by typing the code into your R script and running them. You will hopefully get the same output as is presented on this page below each bit of code. If you get errors and warnings, don’t panic - read them!\n\n\n\nR is a calculator\nWhen we first open RStudio, we should see something which looks more or less like the image in Figure 1, where there are several little windows. We are going to explore what each of these little windows offer by just diving in and starting to do things.\n\n\n\n\n\nFigure 1: RStudio, freshly opened\n\n\n\n\nStarting in the left-hand window, you’ll notice the blue sign &gt;.\nThis is where we R code gets executed.\nType 2+2, and hit Enter ↵.\nYou should discover that R is a calculator - R responds by telling us the answer (4).\nLet’s work through some basic operations (adding, subtracting, etc). For instance, can you work out what R will give you for each of these operations?\n\n\nArithmetic operations\n\n\n\n\n\n\n\nCode\n\n\n\n\n\n2 + 5\n\n\n\n10 - 4\n\n\n\n2 * 5\n\n\n\n10 - (2 * 5)\n\n\n\n(10 - 2) * 5\n\n\n\n10 / 2\n\n\n\n3^2\n(the ^ symbol is “to the power of”)\n\n\n\n\n\nShow me the output\n\n\n\nCode\nOutput\n\n\n\n\n2 + 5\n7\n\n\n10 - 4\n6\n\n\n2 * 5\n10\n\n\n10 - (2 * 5)\n0\n\n\n(10 - 2) * 5\n40\n\n\n10 / 2\n5\n\n\n3^2\n9(the ^ symbol is “to the power of”)\n\n\n\n\n\n\nR can get stuck\nWhenever you see the blue sign &gt;, it means R is ready and waiting for you to provide a command.\nIf you type 10 + and press Enter, you’ll see that instead of &gt; you are left with +. This means that R is waiting for more.\nEither give it more (finish the command), or cancel the command by pressing the Escape key on your keyboard.\n\nAs well as performing arithmetic calculations, we can ask R things for which the answer is TRUE or FALSE, such as “Is 3 less than 5?”. If we type 3 &lt; 5 and press Enter, then R should tell us that the statement we gave it is TRUE.\nThese computations don’t return numbers, but instead return logical values. There are few operators that we need to learn about here:\n\nEquality/Inequality: We use the symbols == to mean “is equal to”, and the symbols != for “is not equal to”.\n\nLess Than/Greater Than: To determine whether a value is less/greater than another value, we have our typical symbols &lt; and &gt;. We also have &lt;= and &gt;= when we want to include “less/greater than or equal to”.\n\nWe can combine these with & for “and”, | for “or”, and ! for “not”, to ask R all sorts of things.\nTry and work out what R should give you for each of these (or try it out yourself!):\n\n\nLogical operations\n\n\n\nCode\nOutput\n\n\n\n\n3 &gt; 5\n\n\n\n3 &lt;= 5\n\n\n\n3 &gt;= 3\n\n\n\n3 == 5\n\n\n\n(2 * 5) == 10\n\n\n\n(2 * 5) != 11\n\n\n\n(2 == 2) & (3 == 4)\n\n\n\n(2 == 2) | (3 == 4)\n\n\n\n(2 == 2) & !(3 == 4)\nTRUE\n\n\n\n\n\nShow me the output\n\n\n\nCode\nOutput\n\n\n\n\n3 &gt; 5\nFALSE\n\n\n3 &lt;= 5\nTRUE\n\n\n3 &gt;= 3\nTRUE\n\n\n3 == 5\nFALSE\n\n\n(2 * 5) == 10\nTRUE\n\n\n(2 * 5) != 11\nTRUE\n\n\n(2 == 2) & (3 == 4)\nFALSE\n\n\n(2 == 2) | (3 == 4)\nTRUE\n\n\n(2 == 2) & !(3 == 4)\nTRUE\n\n\n\n\n\n\nFALSE and TRUE as 0 and 1\nIt will become useful to think of these logical values (TRUE and FALSE) as also having intrinsic numeric values of 0 and 1.\nThis is how R will treat them if you ask it to do something that requires the values to be numeric.\nFor example, the code TRUE + 3 will return 4, and FALSE + 3 will return 3.\n\n\n\n\n\n\nR has a memory\nWe can also store things in R’s memory, and to do that we just need to give them a name.\nType x &lt;- 5 and press Enter.\nWhat has happened? We don’t get given an answer like we did with calculations such as 2 + 4. What we’ve done is stored in R’s memory something named x which has the value 5. We can now refer to the name and it will give us the value!\nIf we now type x and press Enter, it gives us whatever we assigned to the name “x”. So it gives us the number 5.\n\nx\n\n[1] 5\n\n\nWhat is going to happen when we type x * 3? It will give us 15!\n\nAssigning names to things in R\nThe &lt;- symbol, pronounced arrow, is what we use to assign a value to a named object:\n\nname &lt;- value\n\n\nNote, there are a few rules about names in R:\n\nNo spaces - spaces inside a name are not allowed (the spaces around the &lt;- don’t matter):\nlucky_number &lt;- 5 ✔ lucky number &lt;- 5 ❌\nNames must start with a letter:\nlucky_number &lt;- 5 ✔ 1lucky_number &lt;- 5 ❌\nCase sensitive:\nlucky_number is different from Lucky_Number\nhere is a set of words you can’t use as names, including: if, else, for, in, TRUE, FALSE, NULL, NA, NaN, function\n(Don’t worry about remembering these, R will tell you if you make the mistake of trying to name a variable after one of these).\n\n\n\n\n\n\nThe Console and The Environment\nIf you are working along with us, you might have also noticed that something else happened when we executed the code x &lt;- 5. The thing we named x with a value of 5 suddenly appeared in the top-right window. This is known as the environment (Figure 2), and it shows everything that we store in R.\n\n\n\n\n\nFigure 2: Assigning names to objects stores them in R’s environment.\n\n\n\n\nSo we’ve now made use of two of the panes that we see in RStudio:\nWhere code is run: When we’ve been writing and running R code (e.g. typing 2+5 or x&lt;-5 and pressing Enter), we’ve been doing it in the “console”.\nThe console is where R code gets executed (i.e. where our coded instruction to R code is interpreted and acted on), but as we’ll see below, it isn’t where all R code gets written.\nWhere things get stored: We’ve also been learning about how we can store things in R’s memory (the environment) by assigning a name to them using the &lt;- operator. The top-right pane of RStudio shows us the environment, where we can see everything that we have stored in R. Note that this also means we can keep track of what objects we have saved that are available for our use. If we never stored an object named “peppapig”, then R will give us an error when we do something like:\n\n2*peppapig\n\nError in eval(expr, envir, enclos): object 'peppapig' not found\n\n\nNow that we have an idea of what the console and the environment are for, we are well on our way. If you want a silly analogy, the console is like R’s mouth, where we feed it things, and the environment is just its memory, where it remembers what things are what. We can see these in Figure 3. Note however, that the console has been moved down to the bottom-left, as we are introducing a new pane above it. This is where we move to next.\n\n\n\n\n\nFigure 3: RStudio panes: Code is executed in the console, and objects are stored in the environment.\n\n\n\n\n\n\n\n\n\nR Scripts and the Editor\nWhat if we want to edit our code? Whatever we write in the console just disappears upwards. What if we want to change things we did earlier on?\nWhile the console is where code gets executed, it doesn’t have to be where code gets written.. We can write and edit our code in a separate place before we then send it to the console to be executed!!\nThe standard place to write and edit things is in an R scipt. We can open one by doing File &gt; New File &gt; R script, and a new file will open in the top-left pane of RStudio. The console will be shoved down to the bottom-left.\nIn the R script, we can write code. For instance, we might write:\n\nx &lt;- 210\ny &lt;- 15\nx / y\n\nNotice that nothing happens when we write each line. It’s not like writing in the console where R tells us the answers. This is because this code is not yet being executed. We haven’t actually fed it to R.\nThere are a couple of useful ways we can send the code to R.\n\nPosition your text-cursor (blinking vertical line) on the line of code we wish to run and press Ctrl+Enter (Windows) or Cmd+Enter (MacOS)\n\nPosition your text-cursor (blinking vertical line) on the line of code we wish to run and press the “Run” button in the top right of the script.\n\nWhen we do this, the line of code will be sent down to the console, where it will be executed, and R will do it’s thing.\nFor example, if we had sent the line x &lt;- 210 down to the console, R would then store the number 210 with the name x in our environment (as in Figure 4). Additionally, it will move the text-cursor to the next line, so we can just press Ctrl+Enter again to run the next line (and so on.).\n\n\n\n\n\nFigure 4: Code written in the script can be sent down to the console, where it is executed. In this example, the execution of the code stores an object in the environment.\n\n\n\n\nBy writing our code in a file such as an R script before sending it to the console we can edit, save, and share our code. This makes it so much more useful than just using the console (which is more like writing on scratch paper, where we can’t keep anything).\nFor instance, let’s say we made a mistake earlier, and instead of “x” being 210, it should have been 211. Well, we can just edit the script, and re-run it.\n\nRegularly save your scripts!\nTo save an R script that is open, we just\n\nFile &gt; Save (or Ctrl+S)\nLocate to the folder where we want to save the file.\n\ngive it an appropriate name, and click save.\n\nNOTE: When you save R script files, they terminate with a .R extension.\n\n\n\n\n\n\n\nLooking ahead to RMarkdown\n\n\n\n\n\n\nIn addition to R scripts, there is another type of document we can create, known as “Rmarkdown”.\nRmarkdown documents combine the analytical power of R and the utility of a text-processor. We can have one document which contains all of our analysis as well as our written text, and can be compiled into a nicely formatted report. This saves us doing analysis in R and copying results across to Microsoft Word. It ensures our report accurately reflects our analysis. Everything that you’re reading now has all been written in Rmarkdown!\n\n\n\nFigure 5: An example RMarkdown document\n\n\nWe’re going to learn more about Rmarkdown documents and how to write them later on, but the broad idea is that we can writing normal text interspersed with “code-chunks” (i.e., chunks of code!). RMarkdown documents looks much like an R script, only the code is contained within the grey-boxes, and text is written in between (see Figure 5). RMarkdown documents can then be compiled to create a lovely .pdf, .html, or .docx file.\n\n\n\n\n\nFigure 6: RMarkdown Workflow\n\n\n\n\n\n\n\n\n\n\n\n\nThe Four RStudio Panes\nWe’ve now seen almost all the different panes in RStudio:\n\n\nThe console is where R code gets executed\nThe environment is R’s memory, you can assign something a name and store it here, and then refer to it by name in your code.\nThe editor is where you can write and edit R code in R scripts and Rmarkdown documents. You can then send this to the console for it to be executed.\n\n\n\n\n\n\n\n\nFigure 7: The Four Panes of RStudio\n\n\n\n\n\nWe are yet to use the bottom-right window, but this is an easy one to explain. It is where we can see any plots that we create, where we can browse our files, and where we can ask R for some help documentation. We’ll make more use of this later on, but for now try typing plot(x = 4, y = 2) into the console and seeing what happens.\n\n\nProjects and file organisation\nWe’re not going to speak too much about this here but one key thing to remember is that R is working from a specific place in your computer. You can find out where by typing getwd() into the console.\nAn easy way to keep things organised is to set up an “R project”. This basically associates a specific folder on your computer with your working in R, and it means it will automatically look for things in that folder.\nWe recommend that you start a project for this course (call it something like “usmr”). This will the be project that you open whenever you work on this course (RStudio will usually re-open the previous project you were working on when you closed it).\nWith that project open, we suggest that you start a new script for each week, in which you complete your exercises, and which you then remember to save!\nIf you haven’t already, we suggest you start an R project by using (in the top menu of RStudio), File &gt; New Project and following the instructions. It will create a folder on your computer somewhere of your choosing, and you will now notice that if you click in the “Files” tab in the bottom right pane of RStudio, you can see the project folder!\n\n\n\n\n\n\nGood Habits\nAlong with regular saving of work and organising your files, it will be very useful in the long-run if we get used to always “starting fresh” when we open R.\nWe need to start thinking of the code that we write in an R script as a set of consecutive instructions that we can give to R in order to achieve our goal. It’s just a blank slate on which we write (in language R understands) “do this. now do this. now do this..” and so on.\nThis means that the script contains all the information needed.\nSo we can now:\n\nEmpty our environment\nRestart R\nRun all the code in our script (highlight multiple lines of code to run them all at once)\n\nand we’re back to where we are! This is great for when we make mistakes (we’re going to make many many mistakes!), because we can just clear everything, start at the top of our script, and work downwards to figure out what has gone wrong.\n\nTidying up\n\nTo empty our environment, we can click on the little broomstick icon: .\nTo restart the R Session (not always necessary, but good practice) in the top menu, we choose Session &gt; Restart R (or press Ctrl+Shift+F10).\n\n\nThe other very useful thing that we can do in a script is to write comments for ourselves or for others. By starting a line with a #, R will know that that entire line is not code, and so it won’t try to do anything with it. For instance, if we write these lines in our script, and send them both down to the console, nothing happens for the first line:\n\n\nComments\n\n# The line below will add 5 to 2. \n2+5\n\n[1] 7\n\n\n\n\nIf we forget the #\n\nThe line below will add 5 to 2. \n2+5\n\n\nError: unexpected symbol in “The line”\n\n\n\n\n\n\n\n\nUseful Settings\nBelow are a couple of our recommended settings for you to change as you begin your journey in R. After you’ve changed them, take a 5 minute break before moving on to the next reading.\n\n1. Clean environments\nAs you use R more, you will store lots of things with different names. Throughout this course alone, you’ll probably name hundreds of different things. This could quickly get messy within our project.\nWe can make it so that we have a clean environment each time you open RStudio. This will be really handy.\n\nIn the top menu, click Tools &gt; Global Options…\nThen, untick the box for “Restore .RData into workspace at startup”, and change “Save workspace to .RData on exit” to Never:\n\n\n\n\n2. Wrapping code\nIn the editor, you might end up with a line of code which is really long, but you can make RStudio ‘wrap’ the line, so that you can see it all, without having to scroll:\n\nx &lt;- 1+2+3+6+3+45+8467+356+8565+34+34+657+6756+456+456+54+3+78+3+3476+8+4+67+456+567+3+34575+45+2+6+9+5+6\n\n\nIn the top menu, click Tools &gt; Global Options…\nIn the left menu of the box, click “Code”\nTick the box for “Soft-wrap R source files”"
  },
  {
    "objectID": "01b_data.html",
    "href": "01b_data.html",
    "title": "1B: More R - Basic Data Skills",
    "section": "",
    "text": "This reading:\n\nHow does R store data?\n\nWhat can R do with data?\n\nHow can we use R to access and manipulate data?"
  },
  {
    "objectID": "01b_data.html#accessing-subsets-of-data",
    "href": "01b_data.html#accessing-subsets-of-data",
    "title": "1B: More R - Basic Data Skills",
    "section": "Accessing subsets of data",
    "text": "Accessing subsets of data\nWhat if we want to extract certain subsections of our dataset, such as specific observational units or variables? This is where we learn about two important bits of R code used to access parts of data - the dollar sign $, and the square brackets [].\n\nThe dollar sign $\nThe dollar sign allows us to extract a specific variable from a dataframe. For instance, we can pull out the variable named “eye_color” in the data, by using $eye_color after the name that we gave our dataframe.\nRemember that each variable in a dataframe is a vector (a set of values). Once extracted, we will have a vector and not a dataframe.\n\nstarwars2$eye_color\n\n [1] \"blue\"          \"yellow\"        \"red\"           \"yellow\"       \n [5] \"brown\"         \"blue\"          \"blue\"          \"red\"          \n [9] \"brown\"         \"blue-gray\"     \"blue\"          \"blue\"         \n[13] \"blue\"          \"brown\"         \"black\"         \"orange\"       \n[17] \"hazel\"         \"blue\"          \"yellow\"        \"brown\"        \n[21] \"red\"           \"brown\"         \"blue\"          \"orange\"       \n[25] \"blue\"          \"brown\"         \"black\"         \"red\"          \n[29] \"blue\"          \"orange\"        \"orange\"        \"orange\"       \n[33] \"yellow\"        \"orange\"        NA              \"brown\"        \n[37] \"yellow\"        \"pink\"          \"hazel\"         \"yellow\"       \n[41] \"black\"         \"orange\"        \"brown\"         \"yellow\"       \n[45] \"black\"         \"brown\"         \"blue\"          \"orange\"       \n[49] \"yellow\"        \"black\"         \"blue\"          \"brown\"        \n[53] \"brown\"         \"blue\"          \"yellow\"        \"blue\"         \n[57] \"blue\"          \"brown\"         \"brown\"         \"brown\"        \n[61] \"brown\"         \"yellow\"        \"yellow\"        \"black\"        \n[65] \"black\"         \"blue\"          \"unknown\"       \"unknown\"      \n[69] \"gold\"          \"black\"         \"green, yellow\" \"blue\"         \n[73] \"brown\"         \"black\"         NA             \n\n\n\n\nThe square brackets []\nSquare brackets are used to do what is known as indexing (finding specific entries in your data).\nWe can retrieve bits of data by identifying the \\(i^{th}\\) entry(s) inside the square brackets, for instance:\n\n# assign the numbers 10, 20 ... 100 to the name \"somevalues\"\nsomevalues &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)\n\n# pull out the 3rd entry\nsomevalues[3]\n\n[1] 30\n\n\nIn the above example, we have a vector (a single sequence of values), and so we can retrieve entries with the syntax:\n\nvector[entry]\n\n In a dataframe we have an extra dimension - we have rows and columns. Using square brackets with a dataframe needs us to specify both:\n\n\ndataframe[rows, columns]\n\n\nLet’s look at some examples:\n\n\nExamples of Indexing\n\nSpecifying row number and column number:\n\n\n# first row, fourth column\nstarwars2[1, 4]\n# tenth row, first column\nstarwars2[10, 1]\n\n\nIf we leave either rows or columns blank, then we will get out all of them:\n\n\n# tenth row, all columns\nstarwars2[10, ]\n# all rows, 2nd column\nstarwars2[ , 2]\n\n\nThere are is another way to identify column - we can use the name in quotation marks:\n\n\n# first row, \"species\" column\nstarwars2[1, \"species\"]\n\n\nWe can also ask for multiple rows, or multiple columns, or both! To do that, we use c():\n\n\n# the 1st AND the 6th rows, and the 1st AND 3rd columns\nstarwars2[c(1,6), c(1,3)] \n\n\nAnd we can specify a sequence using the colon, from:to: 2\n\n\n# FROM the 1st TO the 6th row, all columns\nstarwars2[1:6, ] \n\n\nWe can even use the two accessors in combination:3\n\n\n# extract the variable called \"name\" and show the 20th entry\nstarwars2$name[20]  \n\n\n\nShow me the output\n\nSpecifying row number and column number:\n\n\n# first row, fourth column\nstarwars2[1, 4]\n\n[1] \"blue\"\n\n# tenth row, first column\nstarwars2[10, 1]\n\n[1] \"Obi-Wan Kenobi\"\n\n\n\nIf we leave either rows or columns blank, then we will get out all of them:\n\n\n# tenth row, all columns\nstarwars2[10, ]\n\n             name height    hair_color eye_color homeworld species\n10 Obi-Wan Kenobi    182 auburn, white blue-gray   Stewjon   Human\n\n# all rows, 2nd column\nstarwars2[ , 2]\n\n [1] 172 167  96 202 150 178 165  97 183 182 188 180 228 180 173 175 170 180 170\n[20] 183 190 177 175 180 150  88 160 191 170 196 224 206 137 112 170 163 175 180\n[39] 178  94 122 163 188 198 196 171 184 188 264 188 196 185 157 183 183 170 166\n[58] 165 193 191 183 168 198 229 213 167  79 193 191 178 216 234 188 206 180\n\n\n\nThere are is another way to identify column - we can use the name in quotation marks:\n\n\n# first row, \"species\" column\nstarwars2[1, \"species\"]\n\n[1] \"Human\"\n\n\n\nWe can also ask for multiple rows, or multiple columns, or both! To do that, we use c():\n\n\n# the 1st AND the 6th rows, and the 1st AND 3rd columns\nstarwars2[c(1,6), c(1,3)] \n\n            name  hair_color\n1 Luke Skywalker       blond\n6      Owen Lars brown, grey\n\n\n\nAnd we can specify a sequence using the colon, from:to:\n\n\n# FROM the 1st TO the 6th row, all columns\nstarwars2[1:6, ] \n\n            name height  hair_color eye_color homeworld species\n1 Luke Skywalker    172       blond      blue  Tatooine   Human\n2          C-3PO    167        &lt;NA&gt;    yellow  Tatooine   Human\n3          R2-D2     96        &lt;NA&gt;       red     Naboo   Droid\n4    Darth Vader    202        none    yellow  Tatooine   Human\n5    Leia Organa    150       brown     brown  Alderaan   Human\n6      Owen Lars    178 brown, grey      blue  Tatooine   Human\n\n\n\nWe can even use the two accessors in combination:\n\n\n# extract the variable called \"name\" and show the 20th entry\nstarwars2$name[20]  \n\n[1] \"Boba Fett\"\n\n\n\n\n\nThe dollar sign $\nUsed to extract a variable from a dataframe:\n\ndataframe$variable\n\nThe square brackets []\nUsed to extract parts of an R object by identifying rows and/or columns, or more generally, “entries”. Left blank will return all.\n\nvector[entries]\ndataframe[rows, columns]"
  },
  {
    "objectID": "01b_data.html#accessing-by-a-condition",
    "href": "01b_data.html#accessing-by-a-condition",
    "title": "1B: More R - Basic Data Skills",
    "section": "Accessing by a condition",
    "text": "Accessing by a condition\nWe can also do something really useful, which is to access all the entries in the data for which a specific condition is true.\nLet’s take a simple example to start:\n\nsomevalues &lt;- c(10, 10, 0, 20, 15, 40, 10, 40, 50, 35)\n\nTo only select values which are greater than 20, we can use:\n\nsomevalues[somevalues &gt; 20]\n\n[1] 40 40 50 35\n\n\n\nUnpacking: somevalues[somevalues &gt; 20]\n First, let’s look at what somevalues &gt; 20 does. It returns TRUE for the entries of somevalues which are greater than 20, and FALSE for the entries of somevalues that are not (that is, which are less than, or equal to, 20.\nThis statement somevalues &gt; 20 is called the condition.\n\nsomevalues &gt; 20\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n\n\nNow consider putting that sequence of TRUEs and FALSEs inside the square brackets in somevalues[]. This returns only the entries of somevalues for which the condition is TRUE.\n\nsomevalues[c(FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE)]\n\n[1] 40 40 50 35\n\n\nSo what we’re doing is using a condition inside the square brackets to return all the values for which that condition is TRUE.\nAnd we’re being super efficient, because we don’t want to write out TRUEs and FALSEs all day, so we just give the conditional question inside the brackets directly:\n\nsomevalues[somevalues &gt; 20]\n\n[1] 40 40 50 35\n\n\n\n We can extend this same logic to a dataframe. Let’s suppose we want to access all the entries in our Star Wars data who have the value “Droid” in the species variable. To work out how to do this, we first need a line of code which defines our condition - one which returns TRUE for each entry of the species variable which is “Droid”, and FALSE for those that are not “Droid”.\nWe can use the dollar sign to pull out the species variable:\n\nstarwars2$species\n\n [1] \"Human\"        \"Human\"        \"Droid\"        \"Human\"        \"Human\"       \n [6] \"Human\"        \"Human\"        \"Droid\"        \"Human\"        \"Human\"       \n[11] \"Human\"        \"Human\"        \"Wookiee\"      \"Human\"        \"Rodian\"      \n[16] \"Hutt\"         \"Human\"        \"Human\"        \"Human\"        \"Human\"       \n[21] \"Trandoshan\"   \"Human\"        \"Human\"        \"Mon Calamari\" \"Human\"       \n[26] \"Ewok\"         \"Sullustan\"    \"Neimodian\"    \"Human\"        \"Gungan\"      \n[31] \"Gungan\"       \"Gungan\"       \"Toydarian\"    \"Dug\"          \"unknown\"     \n[36] \"Human\"        \"Zabrak\"       \"Twi'lek\"      \"Twi'lek\"      \"Vulptereen\"  \n[41] \"Xexto\"        \"Toong\"        \"Human\"        \"Cerean\"       \"Nautolan\"    \n[46] \"Zabrak\"       \"Tholothian\"   \"Iktotchi\"     \"Quermian\"     \"Kel Dor\"     \n[51] \"Chagrian\"     \"Human\"        \"Human\"        \"Human\"        \"Geonosian\"   \n[56] \"Mirialan\"     \"Mirialan\"     \"Human\"        \"Human\"        \"Human\"       \n[61] \"Human\"        \"Clawdite\"     \"Besalisk\"     \"Kaminoan\"     \"Kaminoan\"    \n[66] \"Human\"        \"Aleena\"       \"Skakoan\"      \"Muun\"         \"Togruta\"     \n[71] \"Kaleesh\"      \"Wookiee\"      \"Human\"        \"Pau'an\"       \"unknown\"     \n\n\nAnd we can ask R whether each value is equal to “Droid”\n\nRemember: in R, we ask whether something is equal to something else by using a double-equals, ==. A single equal sign would be wrong, as it denotes assignment.\n\n\nstarwars2$species == \"Droid\"\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[73] FALSE FALSE FALSE\n\n\nFinally, we can use this condition inside our square brackets to access the entries of the data for which this condition is TRUE:\n\n# I would read the code below as: \n# \"In the starwars2 dataframe, give me all the rows \n# for which the condition starwars2$species==\"Droid\"\n# is TRUE, and give me all the columns.\"\n\nstarwars2[starwars2$species == \"Droid\", ]\n\n   name height hair_color eye_color homeworld species\n3 R2-D2     96       &lt;NA&gt;       red     Naboo   Droid\n8 R5-D4     97       &lt;NA&gt;       red  Tatooine   Droid"
  },
  {
    "objectID": "01b_data.html#more-complex-conditions",
    "href": "01b_data.html#more-complex-conditions",
    "title": "1B: More R - Basic Data Skills",
    "section": "More complex conditions",
    "text": "More complex conditions\nThinking back to Reading 1A when we first introduced R, we talked briefly about “logical operators”. Specifically, the operators &, |, and ! (for “and”, “or”,” and “not”), will come in handy now.\nFor instance, we can now extract all those in the dataset which are humans and taller than 190cm:\n\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$species==\"Human\" AND starwars2$height &gt; 190 are TRUE, \n# and give me all the columns.\"\nstarwars2[starwars2$species == \"Human\" & starwars2$height &gt; 190, ]\n\n                  name height hair_color eye_color homeworld species\n4          Darth Vader    202       none    yellow  Tatooine   Human\n59               Dooku    193      white     brown   Serenno   Human\n60 Bail Prestor Organa    191      black     brown  Alderaan   Human\n\n\nOr we can extract all those in the dataset which are either droids or ewoks:\n\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$species==\"Droid\" OR starwars2$species==\"Ewok\" is TRUE, \n# and give me all the columns.\"\nstarwars2[starwars2$species == \"Droid\" | starwars2$species == \"Ewok\", ]\n\n                    name height hair_color eye_color homeworld species\n3                  R2-D2     96       &lt;NA&gt;       red     Naboo   Droid\n8                  R5-D4     97       &lt;NA&gt;       red  Tatooine   Droid\n26 Wicket Systri Warrick     88      brown     brown     Endor    Ewok"
  },
  {
    "objectID": "01b_data.html#editing-specific-entries",
    "href": "01b_data.html#editing-specific-entries",
    "title": "1B: More R - Basic Data Skills",
    "section": "Editing specific entries",
    "text": "Editing specific entries\nNow that we’ve seen a few ways of accessing sections of data, we can learn how to edit them! One of the most common reasons you will need to modify entries in your data is in data cleaning. This is the process of identifying incorrect / incomplete / irrelevant data, and replacing / modifying / deleting them.\nAbove, we looked at the subsection of the data where the species variable had the entry “Droid”. Some of you may have noticed earlier that we had some data on C3PO. Are they not also a droid?\n\n\n\n(Looks pretty Droid-y to me! disclaimer: I know nothing about Star Wars 🙂 )\nJust as we saw above how to access specific entries, e.g.:\n\n# 2nd row, all columns\nstarwars2[2, ]\n\n   name height hair_color eye_color homeworld species\n2 C-3PO    167       &lt;NA&gt;    yellow  Tatooine   Human\n\n# 2nd row, 6th column (the \"species\" column)\nstarwars2[2,6]\n\n[1] \"Human\"\n\n\nWe can change these by assigning them a new value (remember the &lt;- symbol). In doing so, we overwrite4 the entry in the 2nd row and 6th column of the data (starwars2[2,6]) with the value “Droid”.\n\n# C3PO is a droid, not a human\nstarwars2[2,6] &lt;- \"Droid\"\n# Look at the 2nd row now -\n# the entry in the \"species\" column has changed:\nstarwars2[2, ]\n\n   name height hair_color eye_color homeworld species\n2 C-3PO    167       &lt;NA&gt;    yellow  Tatooine   Droid"
  },
  {
    "objectID": "01b_data.html#editing-entries-via-a-condition",
    "href": "01b_data.html#editing-entries-via-a-condition",
    "title": "1B: More R - Basic Data Skills",
    "section": "Editing entries via a condition",
    "text": "Editing entries via a condition\nWe saw above how to access parts of data by means of a condition, with code such as:\n\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$homeworld==\"Naboo\" is TRUE, and give me all the columns.\"\nstarwars2[starwars2$homeworld==\"Naboo\", ]\n\n            name height hair_color eye_color homeworld species\n3          R2-D2     96       &lt;NA&gt;       red     Naboo   Droid\n19     Palpatine    170       grey    yellow     Naboo   Human\n30 Jar Jar Binks    196       none    orange     Naboo  Gungan\n31  Roos Tarpals    224       none    orange     Naboo  Gungan\n32    Rugor Nass    206       none    orange     Naboo  Gungan\n52  Gregar Typho    185      black     brown     Naboo   Human\n53         Cordé    157      brown     brown     Naboo   Human\n58         Dormé    165      brown     brown     Naboo   Human\n\n\nWhat if we wanted to modify it so that every character from “Naboo” was actually of species “Nabooian”?\nWe can do that in a number of ways, all of which do the same thing - namely, they access parts of the data and assign them the new value “Nabooian”.\nThe lines of code below all do exactly that, in different ways. We’ve also tried to give a way of interepreting each line.\n\n# In the starwars2 data, give the rows for which condition \n# starwars2$homeworld==\"Naboo\" is TRUE, and select only the \"species\" column. \n# Assign to these selected entries the value \"Nabooian\".\nstarwars2[starwars2$homeworld==\"Naboo\", \"species\"] &lt;- \"Nabooian\"\n\n\n# In the starwars2 data, give the rows for which condition \n# starwars2$homeworld==\"Naboo\" is TRUE, and select only the 6th column. \n# Assign to these selected entries the value \"Nabooian\".\nstarwars2[starwars2$homeworld==\"Naboo\", 6] &lt;- \"Nabooian\"\n\n\n# Extract the species variable from the starwars2 data (it's a vector).\n# Pick the entries for which the condition starwars2$homeworld==\"Naboo\" is TRUE.\n# Assign to these selected entries the value \"Nabooian\".\nstarwars2$species[starwars2$homeworld==\"Naboo\"] &lt;- \"Nabooian\"\n\n\n\n\n\n\n\noptional: a little extra…\n\n\n\n\n\nIn a similar way, we could have changed C-3PO to a Droid without ever having to know what row of the data they were in!\n\n# for the row(s) where the name variable in starwars2\n# is equal to \"C-3PO\", in the species variable we assign\n# that entry to be \"Droid\"\nstarwars2[starwars2$name==\"C-3PO\", \"species\"] &lt;- \"Droid\""
  },
  {
    "objectID": "01b_data.html#addingchanging-a-variable",
    "href": "01b_data.html#addingchanging-a-variable",
    "title": "1B: More R - Basic Data Skills",
    "section": "Adding/Changing a variable",
    "text": "Adding/Changing a variable\nAnother thing we might want to do is change a whole variable (a whole column) in some way.\nThe logic is exactly the same, for instance, we can take the variable “height” from the dataframe “starwars2”, dividing it by 100 via starwars2$height / 100, and then assign the result to the same variable name in the data, i.e. we overwrite the column:\n\nstarwars2$height &lt;- starwars2$height / 100\n\nWe could instead have added a new column named “height_m” with those values if we did not want to overwrite “height”:\n\nstarwars2$height_m &lt;- starwars2$height / 100\n\nThis would have left the “height” variable as-is, and created a new one called “height2” which was the values in “height” divided by 100."
  },
  {
    "objectID": "01b_data.html#removing-rows-or-columns",
    "href": "01b_data.html#removing-rows-or-columns",
    "title": "1B: More R - Basic Data Skills",
    "section": "Removing rows or columns",
    "text": "Removing rows or columns\nLastly, we might want to change the data by removing a row or a column. Again, the logic remains the same, in that we use &lt;- to assign the edited data to a name (either a new name, thus creating a new object, or an existing name, thereby overwriting that object).\nFor instance, notice that the 35th and 75th rows of our data probably aren’t a valid observation - I’m reasonably sure that Marge and Homer Simpson never appeared in Star Wars:\n\nstarwars2[c(35,75), ]\n\n            name height hair_color eye_color   homeworld species\n35 Marge Simpson    1.7       Blue      &lt;NA&gt; Springfield unknown\n75 Homer Simpson    1.8       &lt;NA&gt;      &lt;NA&gt; Springfield unknown\n\n\nWe can remove a certain row(s) by using a minus sign - inside the square brackets\n\n# everything minus the 75th row\nstarwars2[-75, ]\n# everything minus the (35th and 75th rows)\nstarwars2[-c(35, 75), ]\n\nAnd we can simply re-use the name “starwars2” to overwrite the data and make this change take effect (rather than just print out the result, which the code above did):\n\nstarwars2 &lt;- starwars2[-c(35, 75), ]\n\n(now, in the environment pane of Rstudio, the object named “starwars2” will say 73 observations, rather than 75, which it had before - we’ve removed the 2 rows)\n The same logic applies for columns:\n\n# Create a new object called \"anonymous_starwars2\" and assign it \n# to the values which are the \"starwars2\" dataframe minus the \n# 1st column (the \"name\" column):\nanonymous_starwars2 &lt;- starwars2[, -1]\n# dimensions of our initial data\ndim(starwars2)\n\n[1] 73  6\n\n# the data we just assigned has one fewer columns\ndim(anonymous_starwars2)\n\n[1] 73  5"
  },
  {
    "objectID": "01b_data.html#footnotes",
    "href": "01b_data.html#footnotes",
    "title": "1B: More R - Basic Data Skills",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTo save as .csv in Microsoft Excel, we go to File &gt; Save as, and then in the Save as Type box, choose to save the file as CSV (Comma delimited)↩︎\nThe colon operator, from:to, creates a vector from the value from to the value to in steps of 1.\nFor instance, 1:6 is the same as c(1,2,3,4,5,6).↩︎\nNote: When we do this, we don’t have the comma inside the square brackets.\nWhen we use the $ to pull out a variable, such as starwars2$name, we no longer have a dataframe.\nstarwars2$name doesn’t have rows and columns, it just has a series of values - it’s a vector!\nSo when you are using [] with a vector (1 dimension) rather than a dataframe (2 dimensions), you don’t specify [rows, columns], but simply [entry].↩︎\nyou could think of this as replacing / overwriting / reassigning the entry↩︎"
  },
  {
    "objectID": "02_ex.html",
    "href": "02_ex.html",
    "title": "Exercises: More R; Estimates & Intervals",
    "section": "",
    "text": "Data: Past Surveys\nIn the last few years, we have asked students of the statistics courses in the Psychology department to fill out a little survey.\nAnonymised data are available at https://uoepsy.github.io/data/surveydata_historical.csv.\nNote: this does not contain the responses from this year."
  },
  {
    "objectID": "02_ex.html#optional-extras",
    "href": "02_ex.html#optional-extras",
    "title": "Exercises: More R; Estimates & Intervals",
    "section": "Optional Extras",
    "text": "Optional Extras\n\nOptional Extra\n\n\nNote that the confidence interval from the previous question is concerned with describing the abstract and theoretical distribution of “what the mean sleep quality rating would look like from all possible samples of this size that I could take”. In order to do this we used a formula to describe the spread of this distribution, and in doing so had to assume that the standard deviation of our sample is a good approximation of the standard deviation of the population, and that the population is normally distributed.\nWe can also avoid ever using the standard deviation of our sample (sd(usmr2022$sleeprating)), and instead approximate the sampling distribution of the mean by “bootstrapping” - taking repeated resamples with replacement from the original sample (see 2B#standard-error.\n\nbootstrap_means &lt;- replicate(1000, mean(sample(observed_sample, replace = TRUE)))\n\n\nCreate an object that contains the 10,000 means from 10,000 resamples of our sleep ratings.\n\nThe distribution of resample means is the ‘bootstrap distribution’. Plot a histogram of it. What is the standard deviation? How does it compare to the standard error you calculated in the previous question with the formula?\n\nAt what values does the middle 95% of the bootstrap distribution fall?\n\n\n\n\n\n\n\nHints\n\n\n\n\n\nFor 3, look up quantile(). We saw this in 2B #confidence-intervals.\n\n\n\n\n\n\n\n\n\nResample means\nHere is our sample of sleep ratings:\n\nsleeprates &lt;- usmr2022$sleeprating\n\nAnd we can get rid of the NA’s:\n\nsleeprates &lt;- sleeprates[!is.na(sleeprates)]\n\nWe can resample with replacement from this set of numbers by using the replace = TRUE argument in the sample() function.\nNote, we’re leaving size = blank, which means it will stop at the same length as the original vector we give it.\n\nsample(sleeprates, replace = TRUE)\n\nand the mean of a given resample is calculated by wrapping mean() around the above code:\n\nmean(sample(sleeprates, replace = TRUE))\n\n[1] 62.51899\n\n\nfinally, we’ll do it lots and lots of times, using replicate():\n\nBSmeans &lt;- replicate(10000, mean(sample(sleeprates, replace = TRUE)))\n\n\n\nBootstrap Distribution\nHere’s the histogram of the bootstrap distribution:\n\nhist(BSmeans)\n\n\n\n\n\n\n\n\nAnd here’s the standard deviation of that distribution. This is a bootstrapped estimate of the standard error.\n\nsd(BSmeans)\n\n[1] 2.569066\n\n\nRecall our standard error calculated using \\(\\frac{s}{\\sqrt{n}}\\) from the previous question was 2.55\n\n\nPercentiles\nWe can get the 2.5% and 97.5% percentiles (i.e. getting the middle 95%), using the code below. Recall our confidence intervals that we computed analytically were 60.99 and 70.99.\n\nquantile(BSmeans, c(.025,.975))\n\n    2.5%    97.5% \n60.92373 70.96203 \n\n\n\n\n\n\n\n\n\n\n\nbootstraps\n\n\n\n\n\nBootstrapping is a great way to learn about sampling variability because it allows us to actually plot, summarise and describe what would otherwise be an abstract conceptual distribution.\nIt can also be a useful tool in practice, but it doesn’t come without its own problems/complexities. One important thing to note is that it often works worse than traditional methods for small samples, especially skewed samples (i.e. bootstrapping a “95% CI” for a small sample will often be too narrow and &lt;95%)."
  },
  {
    "objectID": "02_exOSTRICH.html",
    "href": "02_exOSTRICH.html",
    "title": "Exercises: More R; Estimates & Intervals",
    "section": "",
    "text": "Data: Past Surveys\nIn the last few years, we have asked students of the statistics courses in the Psychology department to fill out a little survey.\nAnonymised data are available at https://uoepsy.github.io/data/surveydata_historical.csv.\nNote: this does not contain the responses from this year."
  },
  {
    "objectID": "02_exOSTRICH.html#optional-extras",
    "href": "02_exOSTRICH.html#optional-extras",
    "title": "Exercises: More R; Estimates & Intervals",
    "section": "Optional Extras",
    "text": "Optional Extras\n\nOptional Extra\n\n\nNote that the confidence interval from the previous question is concerned with describing the abstract and theoretical distribution of “what the mean sleep quality rating would look like from all possible samples of this size that I could take”. In order to do this we used a formula to describe the spread of this distribution, and in doing so had to assume that the standard deviation of our sample is a good approximation of the standard deviation of the population, and that the population is normally distributed.\nWe can also avoid ever using the standard deviation of our sample (sd(usmr2022$sleeprating)), and instead approximate the sampling distribution of the mean by “bootstrapping” - taking repeated resamples with replacement from the original sample (see 2B#standard-error.\n\nbootstrap_means &lt;- replicate(1000, mean(sample(observed_sample, replace = TRUE)))\n\n\nCreate an object that contains the 10,000 means from 10,000 resamples of our sleep ratings.\n\nThe distribution of resample means is the ‘bootstrap distribution’. Plot a histogram of it. What is the standard deviation? How does it compare to the standard error you calculated in the previous question with the formula?\n\nAt what values does the middle 95% of the bootstrap distribution fall?\n\n\n\n\n\n\n\nHints\n\n\n\n\n\nFor 3, look up quantile(). We saw this in 2B #confidence-intervals.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nResample means\nHere is our sample of sleep ratings:\n\nsleeprates &lt;- usmr2022$sleeprating\n\nAnd we can get rid of the NA’s:\n\nsleeprates &lt;- sleeprates[!is.na(sleeprates)]\n\nWe can resample with replacement from this set of numbers by using the replace = TRUE argument in the sample() function.\nNote, we’re leaving size = blank, which means it will stop at the same length as the original vector we give it.\n\nsample(sleeprates, replace = TRUE)\n\nand the mean of a given resample is calculated by wrapping mean() around the above code:\n\nmean(sample(sleeprates, replace = TRUE))\n\n[1] 63.25316\n\n\nfinally, we’ll do it lots and lots of times, using replicate():\n\nBSmeans &lt;- replicate(10000, mean(sample(sleeprates, replace = TRUE)))\n\n\n\nBootstrap Distribution\nHere’s the histogram of the bootstrap distribution:\n\nhist(BSmeans)\n\n\n\n\n\n\n\n\nAnd here’s the standard deviation of that distribution. This is a bootstrapped estimate of the standard error.\n\nsd(BSmeans)\n\n[1] 2.525404\n\n\nRecall our standard error calculated using \\(\\frac{s}{\\sqrt{n}}\\) from the previous question was 2.55\n\n\nPercentiles\nWe can get the 2.5% and 97.5% percentiles (i.e. getting the middle 95%), using the code below. Recall our confidence intervals that we computed analytically were 60.99 and 70.99.\n\nquantile(BSmeans, c(.025,.975))\n\n    2.5%    97.5% \n60.91108 70.81013 \n\n\n\n\n\n\n\n\n\n\n\nbootstraps\n\n\n\n\n\nBootstrapping is a great way to learn about sampling variability because it allows us to actually plot, summarise and describe what would otherwise be an abstract conceptual distribution.\nIt can also be a useful tool in practice, but it doesn’t come without its own problems/complexities. One important thing to note is that it often works worse than traditional methods for small samples, especially skewed samples (i.e. bootstrapping a “95% CI” for a small sample will often be too narrow and &lt;95%)."
  },
  {
    "objectID": "02a_measurement.html",
    "href": "02a_measurement.html",
    "title": "2A: Measurement & Distributions",
    "section": "",
    "text": "This reading:\n\nWhat different types of data can we collect?\nHow can we summarise and visualise distributions of different types of data?\n\nAlso:\n\nThe “Tidyverse” a different style of coding in R"
  },
  {
    "objectID": "02a_measurement.html#categorical",
    "href": "02a_measurement.html#categorical",
    "title": "2A: Measurement & Distributions",
    "section": "Categorical",
    "text": "Categorical\n\nCategorical variables tell us what group or category each individual belongs to. Each distinct group or category is called a level of the variable.\n\n\n\n\n\n\n\n\nType\nDescription\nExample\n\n\n\n\nNominal (Unordered categorical)\nA categorical variable with no intrinsic ordering among the levels.\nSpecies: Dog, Cat, Parrot, Horse, …\n\n\nOrdinal (Ordered categorical)\nA categorical variable which levels possess some kind of order\nLevel: Low, Medium, High\n\n\nBinary categorical\nA special case of categorical variable with only 2 possible levels\nisDog: Yes or No.\n\n\n\n\nIf we want to summarise a categorical variable into a single number, then the simplest approach is to use the mode:\n\nMode: The most frequent value (the value that occurs the greatest number of times).\n\nWhen we have ordinal variables, there is another option, and that is to use the median:\n\nMedian: For ordinal variables only, this is the value for which 50% of observations are lower and 50% are higher. It is the mid-point of the values when they are rank-ordered.\n\nWhen we use the median as our measure of “central tendency” (i.e. the middle of the distribution) and we want to discuss how spread out the spread are around it, then we will want to use quartiles. The Inter-Quartile Range (IQR) is obtained by rank-ordering all the data, and finding the points at which 25% (one quarter) and 75% (three quarters) of the data falls below (this makes the median the “2nd quartile”).\nIn our dataset on passwords, we have various categorical variables, such as the type of password (categories like “animal”, “fluffy” etc).\nThere are various ways we might want to summarise categorical variables like this. We have already seen the code to do this in our example of the dice simulation - we can simply counting the frequencies in each level:\n\ntable(pwords$type)\n\n\n             animal          cool-macho              fluffy                food \n                 29                  79                  44                  11 \n               name           nerdy-pop    password-related     rebellious-rude \n                183                  30                  15                  11 \nsimple-alphanumeric               sport \n                 61                  37 \n\n\nThis shows us that the mode (most common) is “name” related passwords.\nWe could also convert these to proportions, by dividing each of these by the total number of observations. For instance, here are the percentages of passwords of each type1:\n\ntable(pwords$type) / sum(table(pwords$type)) * 100\n\n\n             animal          cool-macho              fluffy                food \n                5.8                15.8                 8.8                 2.2 \n               name           nerdy-pop    password-related     rebellious-rude \n               36.6                 6.0                 3.0                 2.2 \nsimple-alphanumeric               sport \n               12.2                 7.4 \n\n\n\nOften, if the entries in a variable are characters (letters), then many functions in R (like table()) will treat it the same as if it is a categorical variable.\nHowever, this is not always the case, so it is good to tell R specifically that each variable is a categorical variable.\nThere is a special way that we tell R that a variable is categorical - we set it to be a “factor”. Note what happens when we make the “type” and “strength_cat” variables to be a factor:\n\npwords$type &lt;- factor(pwords$type)\npwords$strength_cat &lt;- factor(pwords$strength_cat)\nsummary(pwords)\n\n      rank         password                          type        cracked      \n Min.   :  1.0   Length:500         name               :183   Min.   : 1.290  \n 1st Qu.:125.8   Class :character   cool-macho         : 79   1st Qu.: 3.430  \n Median :250.5   Mode  :character   simple-alphanumeric: 61   Median : 3.720  \n Mean   :250.5                      fluffy             : 44   Mean   : 5.603  \n 3rd Qu.:375.2                      sport              : 37   3rd Qu.: 3.720  \n Max.   :500.0                      nerdy-pop          : 30   Max.   :92.270  \n                                    (Other)            : 66                   \n    strength      strength_cat\n Min.   : 1.000   medium:402  \n 1st Qu.: 6.000   strong: 25  \n Median : 7.000   weak  : 73  \n Mean   : 6.768               \n 3rd Qu.: 8.000               \n Max.   :10.000               \n                              \n\n\nR now recognises that there a set number of possible response options, or “levels”, for these variables. We can see what they are using:\n\nlevels(pwords$strength_cat)\n\n[1] \"medium\" \"strong\" \"weak\"  \n\n\nThe “strength_cat” variable specifically has an ordering to the levels, so we might be better off also telling R about this ordering. We do this like so:\n\npwords$strength_cat &lt;- factor(pwords$strength_cat, ordered = TRUE, levels = c(\"weak\",\"medium\",\"strong\"))\n\n\nSometimes, we might have a variable that we know is categorical, but we might want to treat it as a set of numbers instead. A very common example in psychological research is Likert data (questions measured on scales such as “Strongly Disagree”&gt;&gt;“Disagree”&gt;&gt;…&gt;&gt;“Strongly Agree”).\nIt is often useful to have these responses as numbers (e.g. 1 = “Strongly Disagree” to 5 = “Strongly Agree”), as this allows us to use certain functions and analyses more easily. For instance, the median() and IQR() functions require the data to be numbers.\nThis will not work:\n\nmedian(pwords$strength_cat)\n\nError in median.default(pwords$strength_cat): need numeric data\n\n\nWhen we ask R to convert a factor to a numeric variable, it will give turn the first category into 1, the second category to 2, and so on. As R knows that our strength_cat variable is the ordered categories “weak”&gt;&gt;“medium”&gt;&gt;“strong”, then as.numeric(pwords$strength_cat) will turn these to 1s, 2s, and 3s.\n\nmedian(as.numeric(pwords$strength_cat))\n\n[1] 2\n\n\n\nConverting between types of data:\nIn R, we can use various functions to convert between different types of data, such as:\n\nfactor() / as.factor() - to turn a variable into a factor\nas.numeric() - to turn a variable into numbers\nas.character() - to turn a variable into letters\n\nand we can check what type of data something is coded as, by using is.factor(), is.numeric(), is.character().\n\n\n\n\n\n\nbe careful with conversions\n\n\n\n\n\nStudy the code below and the output.\nThink carefully about why this happens:\n\nvec &lt;- c(1,2,4,7)\nas.numeric(as.factor(vec))\n\n[1] 1 2 3 4\n\n\nWhy is the output different here?\n\nas.numeric(as.character(as.factor(vec)))\n\n[1] 1 2 4 7"
  },
  {
    "objectID": "02a_measurement.html#numeric",
    "href": "02a_measurement.html#numeric",
    "title": "2A: Measurement & Distributions",
    "section": "Numeric",
    "text": "Numeric\n\nNumeric (or quantitative) variables consist of numbers, and represent a measurable quantity. Operations like adding and averaging make sense only for numeric variables.\n\n\n\n\n\n\n\n\nType\nDescription\nExample\n\n\n\n\nContinuous\nVariables which can take any real number within the specified range of measurement\nHeight: 172, 165.2, 183, …\n\n\nDiscrete\nVariables which can only take integer number values. For instance, a counts can only take positive integer values (0, 1, 2, 3, etc.)\nNumber_of_siblings: 0, 1, 2, 3, 4, …\n\n\n\n\nOne of the most frequently used measures of central tendency for numeric data is the mean. The mean is calculated by summing all of the observations together and then dividing by the total number of obervations (\\(n\\)).\n\nMean: \\(\\bar{x}\\)\nWhen we have sampled some data, we denote the mean of our sample with the symbol \\(\\bar{x}\\) (sometimes referred to as “x bar”). The equation for the mean is:\n\\[\\bar{x} = \\frac{\\sum\\limits_{i = 1}^{n}x_i}{n}\\]\n\n\n\n\n\n\nHelp reading mathematical formulae\n\n\n\n\n\nThis might be the first mathematical formula you have seen in a while, so let’s unpack it.\nThe \\(\\sum\\) symbol is used to denote a series of additions - a “summation”.\nWhen we include the bits around it: \\(\\sum\\limits_{i = 1}^{n}x_i\\) we are indicating that we add together all the terms \\(x_i\\) for values of \\(i\\) between \\(1\\) and \\(n\\): \\[\\sum\\limits_{i = 1}^{n}x_i \\qquad = \\qquad x_1+x_2+x_3+...+x_n\\]\nSo in order to calculate the mean, we do the summation (adding together) of all the values from the \\(1^{st}\\) to the \\(n^{th}\\) (where \\(n\\) is the total number of values), and we divide that by \\(n\\).\n\n\n\n\nIf we are using the mean as our as our measure of central tendency, we can think of the spread of the data in terms of the deviations (distances from each value to the mean).\nRecall that the mean is denoted by \\(\\bar{x}\\). If we use \\(x_i\\) to denote the \\(i^{th}\\) value of \\(x\\), then we can denote deviation for \\(x_i\\) as \\(x_i - \\bar{x}\\).\nThe deviations can be visualised by the red lines in Figure 1.\n\n\n\n\n\nFigure 1: Deviations from the mean\n\n\n\n\n\nThe sum of the deviations from the mean, \\(x_i - \\bar x\\), is always zero\n\\[\n\\sum\\limits_{i = 1}^{n} (x_i - \\bar{x}) = 0\n\\]\nThe mean is like a center of gravity - the sum of the positive deviations (where \\(x_i &gt; \\bar{x}\\)) is equal to the sum of the negative deviations (where \\(x_i &lt; \\bar{x}\\)).\n\nBecause deviations around the mean always sum to zero, in order to express how spread out the data are around the mean, we must we consider squared deviations.\nSquaring the deviations makes them all positive. Observations far away from the mean in either direction will have large, positive squared deviations. The average squared deviation is known as the variance, and denoted by \\(s^2\\)\n\nVariance: \\(s^2\\)\nThe variance is calculated as the average of the squared deviations from the mean.\nWhen we have sampled some data, we denote the mean of our sample with the symbol \\(\\bar{x}\\) (sometimes referred to as “x bar”). The equation for the variance is:\n\\[s^2 = \\frac{\\sum\\limits_{i=1}^{n}(x_i - \\bar{x})^2}{n-1}\\]\n\n\n\n\n\n\noptional: why n minus 1?\n\n\n\n\n\nThe top part of the equation \\(\\sum\\limits_{i=1}^{n}(x_i - \\bar{x})^2\\) can be expressed in \\(n-1\\) terms, so we divide by \\(n-1\\) to get the average.\n Example: If we only have two observations \\(x_1\\) and \\(x_2\\), then we can write out the formula for variance in full quite easily. The top part of the equation would be: \\[\n\\sum\\limits_{i=1}^{2}(x_i - \\bar{x})^2 \\qquad = \\qquad (x_1 - \\bar{x})^2 + (x_2 - \\bar{x})^2\n\\]\nThe mean for only two observations can be expressed as \\(\\bar{x} = \\frac{x_1 + x_2}{2}\\), so we can substitute this in to the formula above. \\[\n(x_1 - \\bar{x})^2 + (x_2 - \\bar{x})^2\n\\] becomes: \\[\n\\left(x_1 - \\frac{x_1 + x_2}{2}\\right)^2 + \\left(x_2 - \\frac{x_1 + x_2}{2}\\right)^2\n\\] Which simplifies down to one value: \\[\n\\left(\\frac{x_1 - x_2}{\\sqrt{2}}\\right)^2\n\\]  So although we have \\(n=2\\) datapoints, \\(x_1\\) and \\(x_2\\), the top part of the equation for the variance has 1 fewer units of information. In order to take the average of these bits of information, we divide by \\(n-1\\).\n\n\n\n\nOne difficulty in interpreting variance as a measure of spread is that it is in units of squared deviations. It reflects the typical squared distance from a value to the mean.\nConveniently, by taking the square root of the variance, we can translate the measure back into the units of our original variable. This is known as the standard deviation.\n\nStandard Deviation: \\(s\\)\nThe standard deviation, denoted by \\(s\\), is a rough estimate of the typical distance from a value to the mean.\nIt is the square root of the variance (the typical squared distance from a value to the mean).\n\\[\ns = \\sqrt{\\frac{\\sum\\limits_{i=1}^{n}(x_i - \\bar{x})^2}{n-1}}\n\\]\n\nIn the passwords dataset, we only have one continuous variable, and that is the “cracked” variable, which if we recall is the “Time to crack by online guessing”. You might be questioning whether the “strength” variable, which ranges from 1 to 10 is numeric? This depends on whether we think that statements like “a password of strength 10 is twice as strong as a password of strength 5”.\nFor now, we’ll just look at the “cracked” variable.\nTo calculate things like means and standard deviations in R is really easy, because there are functions that do them all for us.\nFor instance, we can do the calculation by summing the cracked variable, and dividing by the number of observations (in our case we have 500 passwords):\n\n# get the values in the \"cracked\" variable from the \"pwords\" dataframe, and\n# sum them all together. Then divide this by 500\nsum(pwords$cracked)/500\n\n[1] 5.60266\n\n\nOr, more easily, we can use the mean() function:\n\nmean(pwords$cracked)\n\n[1] 5.60266\n\n\nWe can get R to calculate the variance and standard deviation with the var() and sd() functions:\n\nvar(pwords$cracked)\n\n[1] 71.16618\n\nsd(pwords$cracked)\n\n[1] 8.436005\n\n\nand just to prove to ourselves:\n\nsd(pwords$cracked)^2 == var(pwords$cracked)\n\n[1] TRUE\n\n\n\nIf a column of our dataset contains only numbers, R will typically just interpret it as a numeric variable. However, we should still be careful; remember what happens if we have just one erroneous entry in there - they can all change to be characters (surrounded by quotation marks):\n\nc(1,3,6,\"peppapig\",3)\n\n[1] \"1\"        \"3\"        \"6\"        \"peppapig\" \"3\"       \n\n\nWe can force a variable to be numeric by using as.numeric(), which will also coerce any non-numbers to be NA (not applicable):\n\nas.numeric(c(1,3,6,\"peppapig\",3))\n\n[1]  1  3  6 NA  3\n\n\nIf there is an NA in the variable, many functions like mean(), var() and sd() will not compute:\n\nx &lt;- c(1, 3, 6, NA, 3)\nmean(x)\n\n[1] NA\n\n\nHowever, we can ask these functions to remove the NAs prior to the computation:\n\nmean(x, na.rm = TRUE)\n\n[1] 3.25\n\n\n\n\n\n\n\n\nFigure 2: Artwork by @allison_horst"
  },
  {
    "objectID": "02a_measurement.html#this-is-a-pipe",
    "href": "02a_measurement.html#this-is-a-pipe",
    "title": "2A: Measurement & Distributions",
    "section": "This is a pipe!",
    "text": "This is a pipe!\nWe have seen already seen a few examples of code such as:\n\ndim(somedata)\ntable(somedata$somevariable)\n\n\n\n\nAnd we have seen how we might wrap functions inside functions:\n\nbarplot(table(somedata$somevariable))\n\nThis sort of writing (functions inside functions inside functions) involves R evaluating code from the inside out. But a lot of us don’t intuitively think that way, and actually find it easier to think in terms of a sequence. The code barplot(table(somedata$somevariable)) could be read as “take this variable, then make a table of it, then make a barplot of that table”.\nWe can actually write code that better maps to this way of reading, using a nice little symbol called a “pipe”:\n\nPiping\nWe can write in a different style, however, and this may help to keep code tidy and easily readable - we can write sequentially:\n\nNotice that what we are doing is using a new symbol: |&gt;\nThis symbol takes the output of whatever is on it’s left-hand side, and uses it as an input for whatever is on the right-hand side.\nThe |&gt; symbol gets called a “pipe”.\n\nLet’s see it in action with the passwords dataset we’ve been using.\n\n\ninside-out\nThe typical way of writing code is requires reading from the inside-out:\n\nbarplot(table(pwords$type))\n\n\n\n\n\n\n\n\n\n\npiped\nWhen we pipe code, we can read it from left to right:\n\npwords$type |&gt;\n    table() |&gt;\n    barplot()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOther pipes: |&gt; and %&gt;%\n\n\n\n\n\nThe |&gt; pipe is a relatively recent addition to R, but will likely be replacing the older %&gt;% pipe that was in a specific set of packages, and has been around since about 2014.\nThese two pipes do basically the same thing\nThere are some subtle differences between the two that only become apparent in very specific situations, none of which are likely to arise on this course.\nHowever, it’s important to be aware of them both, because you will like see them both in resources/online forums etc. You can usually just use them interchangeably.\n\n\n# for %&gt;% we need the tidyverse\nlibrary(tidyverse)\n1:10 %&gt;% mean()\n\n\n\n\n# the new base R pipe\n1:10 |&gt; mean()"
  },
  {
    "objectID": "02a_measurement.html#the-tidyverse",
    "href": "02a_measurement.html#the-tidyverse",
    "title": "2A: Measurement & Distributions",
    "section": "The Tidyverse",
    "text": "The Tidyverse\nWe’re going to use pipes a lot throughout this course, and it pairs really well with a group of functions in the tidyverse packages, which were designed to be used in conjunction with a pipe:\n\nselect() extracts columns\n\nfilter() subsets data based on conditions\n\nmutate() adds new variables\n\ngroup_by() group related rows together\n\nsummarise()/summarize() reduces values down to a single summary\n\nTypically, the tidyverse means that we no longer have to keep telling R in which dataframe to look for the variable. The tidyverse functions are designed to make things is a bit easier. The examples below show how.\nYou’ll notice that the code has lots of indentations to make it more readable, which RStudio does for you when you press enter!\nBefore anything else, however, we need to load the tidyverse package:\n\nlibrary(tidyverse)\n\n\nselect()\nWe know about using $ to extract a column from a dataframe. The select() function is a little bit like that - it allows us to choose certain columns in a dataframe. It will return all rows.\nBecause we can select multiple columns this way, it doesn’t return us a vector (in the way dataframe$variable does), but returns a dataframe:\n\n# take the data\n# and select the \"variable1\" and \"variable2\" columns\ndata |&gt;\n  select(variable1, variable2)\n\n\n\nTidyverse\n\npwords |&gt;\n  select(type, strength)\n\n\n\nBase R\n\npwords[, c(\"type\",\"strength\")]\n\n\n\n\n\nfilter()\nThe filter() function is a bit like the [] to choose rows that meet certain conditios - it allows us to filter a dataframe down to those rows which meet a given condition. It will return all columns.\n\n# take the data\n# and filter it to only the rows where the \"variable1\" column is \n# equal to \"value1\". \ndata |&gt; \n  filter(variable1 == value1)\n\n\n\nTidyverse\n\npwords |&gt;\n    filter(strength_cat == \"strong\")\n\n\n\nBase R\n\npwords[pwords$strength_cat == \"strong\", ]\n\n\n\n\n\nmutate()\nThe mutate() function is used to add or modify variables to data.\n\n# take the data\n# |&gt;\n# mutate it, such that there is a variable called \"newvariable\", which\n# has the values of a variable called \"oldvariable\" multiplied by two.\ndata |&gt;\n  mutate(\n    newvariable = oldvariable * 2\n  )\n\nTo ensure that our additions/modifications of variables are stored in R’s environment (rather than simply printed out), we need to reassign the name of our dataframe:\n\ndata &lt;- \n  data |&gt;\n  mutate(\n    ...\n  )\n\nNote: Inside functions like mutate(), we don’t have to keep using the dollar sign $, as we have already told it what data to look for variables in.\n\n\nTidyverse\n\npwords &lt;- pwords |&gt; \n    mutate(\n        cracked_min = cracked / 60\n    )\n\n\n\nBase R\n\npwords$cracked_min &lt;- pwords$cracked / 60\n\n\n\n\n\nsummarise()\nThe summarise() function is used to reduce variables down to a single summary value.\n\n# take the data |&gt;\n# summarise() it, such that there is a value called \"summary_value\", which\n# is the sum() of \"variable1\" column, and a value called \n# \"summary_value2\" which is the mean() of the \"variable2\" column.\ndata |&gt;\n  summarise(\n    summary_value = sum(variable1),\n    summary_value2 = mean(variable2)\n  )\n\n\n\nTidyverse\n\npwords |&gt; \n    summarise(\n        mean_cracked = mean(cracked),\n        sd_cracked = sd(cracked),\n        nr_strong = sum(strength_cat == \"strong\")\n    )\n\n\n\nBase R\nTo store these all in the same object (like the tidyverse way) we would have to create a data.frame() and add these as variables.\n\nmean(pwords$cracked)\nsd(pwords$cracked)\nsum(pwords$strength_cat == \"strong\")\n\n\n\n\n\ngroup_by()\nThe group_by() function is often used as an intermediate step in order to do something. For instance, if we want to summarise a variable by calculating its mean, but we want to do that for several groups, then we first group_by() and then summarise():\n\n# take the data |&gt; \n# and, grouped by the levels of the \"mygroups\" variable,\n# summarise() it so that there is a column called \"summary_col\", which\n# is the mean of the \"variable1\" column for each group. \ndata |&gt;\n    group_by(mygroups) |&gt;\n    summarise(\n        summary_col = mean(variable1)\n    )\n\n\n\nTidyverse\n\npwords |&gt; \n    group_by(strength_cat) |&gt;\n    summarise(\n        mean_cracked = mean(cracked)\n    )\n\n\n\nBase R\nThis is less easy. There are functions in Base R that can do similar things, but we’re not going to teach those here. You could envisage getting all the same values by doing:\n\nmean(pwords$cracked[pwords$strength_cat == \"weak\"])\nmean(pwords$cracked[pwords$strength_cat == \"medium\"])\nmean(pwords$cracked[pwords$strength_cat == \"strong\"])"
  },
  {
    "objectID": "02a_measurement.html#boxplots",
    "href": "02a_measurement.html#boxplots",
    "title": "2A: Measurement & Distributions",
    "section": "Boxplots",
    "text": "Boxplots\nBoxplots provide a useful way of visualising the interquartile range (IQR). You can see what each part of the boxplot represents in Figure Figure 4.\n\n\n\n\n\nFigure 4: Anatomy of a boxplot\n\n\n\n\nWe can create a boxplot of our age variable using the following code:\n\n# Notice, we put strength on the x axis, making the box plot vertical. \n# If we had set aes(y = strength) instead, then it would simply be rotated 90 degrees \nggplot(data = pwords, aes(x = strength)) +\n  geom_boxplot()"
  },
  {
    "objectID": "02a_measurement.html#histograms",
    "href": "02a_measurement.html#histograms",
    "title": "2A: Measurement & Distributions",
    "section": "Histograms",
    "text": "Histograms\nNow that we have learned about the different measures of central tendency and of spread, we can look at how these map to how visualisations of numeric variables look.\nWe can visualise numeric data using a histogram, which shows the frequency of values which fall within bins of an equal width.\nTo do this, we’re going to use some new data, on 120 participants’ IQ scores (measured on the Wechsler Adult Intelligence Scale (WAIS)), their ages, and their scores on 2 other tests. The data are available at https://uoepsy.github.io/data/wechsler.csv\n\nwechsler &lt;- read_csv(\"https://uoepsy.github.io/data/wechsler.csv\")\n\n\n# make a ggplot with the \"wechsler\" data. \n# on the x axis put the possible values in the \"iq\" variable,\n# add a histogram geom (will add bars representing the count \n# in each bin of the variable on the x-axis)\nggplot(data = wechsler, aes(x = iq)) + \n  geom_histogram()\n\n\n\n\n\n\n\n\nWe can specifiy the width of the bins:\n\nggplot(data = wechsler, aes(x = iq)) + \n  geom_histogram(binwidth = 5)\n\n\n\n\n\n\n\n\nLet’s take a look at the means and standard deviations of participants’ scores on the other tests (the test1 and test2 variables).\nNote how nicely we can do this with our newfound tidyverse skills!\n\nwechsler |&gt; \n  summarise(\n    mean_test1 = mean(test1),\n    sd_test1 = sd(test1),\n    mean_test2 = mean(test2),\n    sd_test2 = sd(test2)\n  )\n\n# A tibble: 1 × 4\n  mean_test1 sd_test1 mean_test2 sd_test2\n       &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n1       49.3     7.15       51.2     14.4\n\n\nTests 1 and 2 have similar means (around 50), but the standard deviation of Test 2 is almost double that of Test 1. We can see this distinction in the visualisation below - the histograms are centered at around the same point (50), but the one for Test 2 is a lot wider than that for Test 1.\n\n\n\n\n\n\n\n\n\n\nDefining moments\nThe “moments” of a distribution are the metrics that relate to the shape of that distribution. We’ve already seen the primary two moments that define the shapes of these distributions: the mean and the variance. The mean moves the distribution right or left, and the variance makes the distribution wider or narrower.\nThere are two more, “skewness” and “kurtosis” which tend to be of less focus of investigation (the questions we ask tend to be mainly concerned with means and variances). Skewness is a measure of asymmetry in a distribution. Distributions can be positively skewed or negatively skewed, and this influences our measures of central tendency and of spread to different degrees. The kurtosis is a measure of how “pointy” vs “rounded” the shape of a distribution is."
  },
  {
    "objectID": "02a_measurement.html#density",
    "href": "02a_measurement.html#density",
    "title": "2A: Measurement & Distributions",
    "section": "Density",
    "text": "Density\nIn addition to grouping numeric data into bins in order to produce a histogram, we can also visualise a density curve.\nBecause there are infinitely many values that numeric variables could take (e.g., 50, 50.1, 50.01, 5.001, …), we could group the data into infinitely many bins. This is essentially what we are doing with a density curve.\nYou can think of “density” as a bit similar to the notion of “relative frequency” (or “proportion”), in that for a density curve, the values on the y-axis are scaled so that the total area under the curve is equal to 1. In creating a curve for which the total area underneath is equal to one, we can use the area under the curve in a range of values to indicate the proportion of values in that range.\n\nggplot(data = wechsler, aes(x = iq)) + \n  geom_density()\n\n\n\n\n\n\n\n\n\nArea under the curve\nThink about the barplots we have been looking at in the exercises where we simulate dice rolling :\n\n# our function to simulate the roll of a die/some dice\ndice &lt;- function(num = 1) {\n  sum(sample(1:6, num, replace=TRUE))\n}\n# simulate 1000 rolls of a single die\nroll1000 &lt;- replicate(1000, dice(1))\n# tabulate and plot:\ntable(roll1000) |&gt;\n  barplot(ylab=\"count\")\n\n\n\n\n\n\n\n\nTo think about questions like “what proportion of 1000 rolls does the die land on 6?”, we are simply interested in the count of 6s divided by the count of all rolls:\n\ntab1000 &lt;- table(roll1000)\ntab1000\n\nroll1000\n  1   2   3   4   5   6 \n162 169 167 189 152 161 \n\ntab1000[6] / sum(tab1000)\n\n    6 \n0.161 \n\n\nSo Another way of thinking of this is that we are just dividing the count in each category by the total number. Or, Put another way, imagine we divide the area of each bar by the total area. The area now sums to 1, and our question is asking about the ratio of the red area to the total area (grey + red):\n\n\n\n\n\n\n\n\n\nNothing really changes with a density curve! If we want to ask what proportion of our distribution of IQ scores is &gt;120, then we are asking about the area under the curve that is to the right of 120:\n\n\n\n\n\n\n\n\n\nIt looks like about a third, maybe a little less. Let’s calculate this proportion directly:\n\nsum(wechsler$iq&gt;110) / length(wechsler$iq)\n\n[1] 0.2\n\n\nIt might seem a little odd to think about area under the curve when we are asking about “what proportion of the data is …?”. If we have the data, then we can just calculate the answer (like we did above). However, a lot of statistics is really concerned with the probability of events. When we discuss probability, we move from talking about a specific set of observed data to thinking about a theoretical/mathematical model that defines the way in which data is generated. This where it becomes more useful to think about distributions in a more abstract sense.\nFor instance, with a fair six-sided die, we have a probability distribution (Figure 5) in which each side is given the probability \\(\\frac{1}{6}\\): \\[\n\\begin{gather*}\nP(x) = \\begin{cases}\n  \\frac{1}{6} & \\text{if $x \\in \\{1,2,3,4,5,6\\}$}\\\\\n  0 & \\text{otherwise.}\n  \\end{cases}\n\\end{gather*}\n\\] Instead of rolling a die, suppose that we are picking a person off the street and measuring their IQ. Given that IQ scales are designed to have a mean of 100 and standard deviation of 15, what is the probability that we pick a person with an IQ of greater than 110?\n\n\n\n\n\nFigure 5: Left: Discrete probability distribution of a fair six-sided die. Right: Continuous probability distribution of IQ scores"
  },
  {
    "objectID": "02a_measurement.html#footnotes",
    "href": "02a_measurement.html#footnotes",
    "title": "2A: Measurement & Distributions",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nthink about what sum(table(pwords$type)) is doing. it’s counting all the values in the table. so it’s going to give us the total↩︎"
  },
  {
    "objectID": "02b_sampling.html",
    "href": "02b_sampling.html",
    "title": "2B: Curves & Sampling",
    "section": "",
    "text": "This reading:\n\nWhat are probability distributions and why are they relevant?\n\nHow does using a sample to approximate a population lead to uncertainty?\nHow can we quantify uncertainty due to sampling?"
  },
  {
    "objectID": "02b_sampling.html#the-standard-normal-distribution",
    "href": "02b_sampling.html#the-standard-normal-distribution",
    "title": "2B: Curves & Sampling",
    "section": "The Standard Normal Distribution",
    "text": "The Standard Normal Distribution\nNote that if we translate our “IQ &gt;120” to being in terms of standard deviations - \\(\\frac{120 - 100}{15} = 1\\frac{1}{3}\\) - then we can perform the same computations as we have done above, but comparing against against a normal distribution with mean of 0 and standard deviation of 1 (which are the defaults for the pnorm() function):\n\npnorm((120-100)/15, lower.tail = FALSE)\n\n[1] 0.09121122\n\n\n\n\n\n\n\nFigure 7: pnorm() with the ‘standard normal distribution’: the normal distribution with mean = 0 and sd = 1\n\n\n\n\nWhat we’re doing here is re-expressing the observed distribution into one which has mean of 0 and standard deviation of 1 - we are standardising them. This idea will become incredibly useful. For one thing it makes comparisons possible, for example, consider the two statements below:\n\n“I am 15 IQ points higher than average, and 24cm taller than average”\n“I am 1 standard deviation above the average IQ, and 2 standard deviations above average height”\n\nThe standard normal distribution - the normal distribution with mean = 0, sd = 1, is going to be seen a lot more frequently."
  },
  {
    "objectID": "02b_sampling.html#the-relevance-of-the-normal-distribution",
    "href": "02b_sampling.html#the-relevance-of-the-normal-distribution",
    "title": "2B: Curves & Sampling",
    "section": "The relevance of the normal distribution?",
    "text": "The relevance of the normal distribution?\nWe can motivate the relevance of the normal distribution in various ways. For instance, when we take a measurement of something such as the length of a stick, then we always have a bit of imprecision - our measurements will vary a bit. Assuming that our measurement tool is unbiased and this imprecision is purely random, we would expect the measurements of the stick to be ‘normally distributed’ around the true length of the stick (Figure 8).\n\n\n\n\n\nFigure 8: Snapshots from 21/22 lecture slides on measurement\n\n\n\n\nIn this way, the normal distribution captures the idea of random deviations around a central point. As we will see below, this becomes extremely relevant for statistics because we tend to collect data on a random sample of people, and each sample we could take will randomly deviate a bit in how well it represents the bigger group that we took it from."
  },
  {
    "objectID": "02b_sampling.html#footnotes",
    "href": "02b_sampling.html#footnotes",
    "title": "2B: Curves & Sampling",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nremember that standard deviation is \\(\\sqrt{\\text{variance}}\\)↩︎\nOften in neuropsychological testing, a set of “normative values” are provided in order to define “what is expected” (sometimes in reference to a specific population).↩︎\nand the statements may not hold for all individuals - for certain people, some drugs just won’t work! but what is important for a healthcare system deciding on whether or not to purchase supplies of a drug is the average treatment effect.↩︎\nIf you’re working along with this, yours will be different, because it’s random!↩︎\nImagine a bag full of coloured marbles. If we sample with replacement, then we take a marble out, record its colour, and put it back. Then we take a marble out, record its colour, and put it back. And so on. This means we might get the same marble more than once.↩︎\nusing the formula \\(\\frac{\\sigma}{\\sqrt{n}}\\) for standard error↩︎"
  },
  {
    "objectID": "csstests.html",
    "href": "csstests.html",
    "title": "Tests",
    "section": "",
    "text": "Notes for Wizards\n\n\n\n\n\nhere’s a note!\n\n\n\n\n\n\n\n\n\nHints\n\n\n\n\n\n\n\n\n\n\nlearning obj\n\n\nimportant\n\n\nsticky\n\n\n\n\n\nr tips\n\n\nstatbox\n\n\ninterprtation interprtation interprtation\n\n\nQuestion\n\n\nquestion\nwhat is your name?\nwhat is your favourite colour?\n\n\n\n\n\nSolution\n\n\n\nsolution\nhello\n\n2+2\n\n[1] 4\n\n\n\n\n\n\n\nOptional hello my optional friend\n\n\n\nit’s nice to see you again\n\n\n\n\n\nthis is not a panel\n\n\nthis is a panel\n\n\nthis is a panel"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Univariate Statistics and Methodology in R",
    "section": "",
    "text": "Univariate Statistics and Methodology in R (USMR) is a semester long crash-course aimed at providing Masters students in psychology with a competence in standard statistical methodologies and data analysis using R. Typically the analyses taught in this course are relevant for when there is just one source of variation - i.e. when we are interested in a single outcome measured across a set of independent observations. The first half of the course covers the fundamentals of statistical inference using a simulation-based approach, and introduces students to working with R & RStudio. The latter half of the course focuses on the general linear model, emphasising the fact that many statistical methods are simply special cases of this approach. This course introduces students to statistical modelling and empowers them with tools to analyse richer data and answer a broader set of research questions."
  }
]