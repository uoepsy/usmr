[
  {
    "objectID": "01_ex.html",
    "href": "01_ex.html",
    "title": "Exercises: Intro R",
    "section": "",
    "text": "First things\nThe very first things to do are to open RStudio and get a blank script ready for writing your code!\n\n\nOur recommendation is that you have an R project for this course, and use a new script for each week of work. See the tip about “R projects” in Section 1A.\n\n\nPet Data\n\nWe’re going to play with some data on a sample of licensed pets from the city of Seattle, USA. It can be downloaded (or read directly into R) from https://uoepsy.github.io/data/pets_seattle.csv. It contains information on the license ID, year of issue, as well as the species, breeds and weights of each pet. You can find a data dictionary in Table 1\n\n\n\n\nTable 1: Seattle Pets: Data dictionary\n\n\nVariable\nDescription\n\n\n\n\nlicense_year\nYear in which license was issued\n\n\nlicense_number\nUnique license ID number\n\n\nanimals_name\nFull name of pet\n\n\nspecies\nSpecies of pet\n\n\nprimary_breed\nPrimary breed of pet\n\n\nsecondary_breed\nSecondary breed of pet\n\n\nweight_kg\nWeight in kilograms\n\n\n\n\n\n\n\n\nQuestion 1\n\n\nWrite a line of code that reads in the data to your R session. Then examine the dimensions of the dataset, and take a look at the first few lines.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou’ll need the read.csv() function. Remember to assign it a name to store it in your environment.\n1B #basic-data-wrangling contains an example of reading in data from a URL. You’ll then want to play with functions like dim() and head().\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe’re going to call it petdata in our environment here. Don’t forget the quotation marks around the url (otherwise R will look for an object in your environment called https://..., which isn’t there).\n\npetdata&lt;-read.csv(\"https://uoepsy.github.io/data/pets_seattle.csv\")\ndim(petdata)\n\n[1] 1956    7\n\n\nWe can see there are 1956 rows and 7 columns.\nAnd we can see the first few rows here:\n\nhead(petdata)\n\n  license_year license_number  animals_name species         primary_breed\n1         2018      LNS150171        Norman     Dog                 Boxer\n2         2017        LN20666         Henry     Dog          Bichon Frise\n3         2018      LN8000658 Vega Williams     Dog                   Mix\n4         2018       LN730940         Molly     Dog   Australian Shepherd\n5         2016       LN964607         Gremy     Dog Chihuahua, Short Coat\n6         2018      LNS117115        Shadow     Dog   Retriever, Labrador\n  secondary_breed weight_kg\n1             Mix     29.15\n2        Havanese     23.70\n3         Unknown     21.13\n4             Mix     18.70\n5         Terrier     20.36\n6         Unknown     11.51\n\n\n\n\n\n\nQuestion 2\n\n\nWhat are the names of the 47th and the 200th animals in the dataset? (use R code to find out)\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou’ll probably want to make use of the square brackets data[rows, columns].\n\n\n\n\n\n\n\n\nSolution\n\n\n\nThere are lots of different ways to do this. We can get out the entire rows, either individually:\n\npetdata[47,]\npetdata[200,]\n\nOr together:\n\npetdata[c(47,200),]\n\n    license_year license_number animals_name species       primary_breed\n47          2018      LNS140233     Hooligan     Dog Retriever, Labrador\n200         2017       LN584186  Maple Syrup     Cat  Domestic Shorthair\n    secondary_breed weight_kg\n47          Unknown     12.27\n200         Unknown      4.66\n\n\nOr we can extract the names only:\n\n# These all do the same\npetdata[c(47,200),\"animals_name\"]\npetdata[c(47,200),3]\npetdata$animals_name[c(47,200)]\n\nThe will all give us these names:\n\n\n[1] \"Hooligan\"    \"Maple Syrup\"\n\n\nIn the last one, we use the $ to access the animals_name variable. In this case, we don’t need to specify [rows, columns] inside the square brackets, because it’s a single variable - there are no columns.\n\ndataframe[rows, columns]\n\nvariable[entries]\n\n\n\n\n\nQuestion 3\n\n\nSubset the data to only the animals which are dogs, and store this subset as another named object in your environment.\nDo the same for the cats.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou’ll want to think about how we access data via asking for those entries that meet a specific condition (see 1B #accessing-by-a-condition)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe can ask “which entries of species variable are equal to ‘Dog’?” by using pet$species==\"Dog\".\nThis will give us a TRUE for each dog, and a FALSE for each non-dog.\nWe can then use this set of TRUEs and FALSEs to access those rows for which it is TRUE in our data:\n\ndogdata &lt;- petdata[petdata$species==\"Dog\", ]\ncatdata &lt;- petdata[petdata$species==\"Cat\", ]\n\n\n\n\n\nQuestion 4\n\n\nFind the name and weight of the heaviest cat, and of the lightest dog.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou could do this using the original data you read in from question 1, or use the subsets you created in question 3. You’ll again want to supply a condition within square brackets data[?==?]. That condition may well have something to do with being equal to the min() or the max() of some variable.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe can use min() and max() to return the minimum and maximum of a variable:\n\nmin(dogdata$weight_kg)\n\n[1] 0.39\n\nmax(catdata$weight_kg)\n\n[1] 5.48\n\n\nWe could then ask for each entry “is this cat’s weight the maximum cat’s weight?” with catdata$weight_kg == max(catdata$weight_kg) and then use that condition to access the rows in our dataset where the weight_kg variable is at its maximum:\n\ncatdata[catdata$weight_kg == max(catdata$weight_kg), ]\n\n    license_year license_number animals_name species      primary_breed\n414         2018      LNS101014       Smokey     Cat Domestic Shorthair\n    secondary_breed weight_kg\n414             Mix      5.48\n\ndogdata[dogdata$weight_kg == min(dogdata$weight_kg), ]\n\n     license_year license_number animals_name species  primary_breed\n1126         2017      LNS139134       Claire     Dog Great Pyrenees\n     secondary_breed weight_kg\n1126         Unknown      0.39\n\n\n\n\n\n\nQuestion 5\n\n\nDoes the original dataset contain only dogs and cats?\n\n\n\n\n\n\nHints\n\n\n\n\n\nGiven what you did in question 3, you might be able to answer this by just looking at your environment.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nIn the environment, we can see that the entire dataset has 1956 observations, the Dog’s data frame has 1322, and the Cat’s has 632.\nSo there are 2 missing!\n\n\n\n\nQuestion 6\n\n\nExtract the entries of the original dataset for which the species is neither “Dog” nor “Cat”?\nWhat are the names and species of these animals?\n\n\n\n\n\n\nHints\n\n\n\n\n\nThis is a slightly complex one. 1B #more-complex-conditions might help you here.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAs always, there are lots of different ways.\nHere are three:\n\n\n“not a dog AND not a cat”\nWe can ask if something is not a dog by using petdata$species != \"Dog\". But we want the rows where the species is not a dog and it’s not a cat. So it’s two conditions:\n\npetdata[petdata$species != \"Cat\" & petdata$species != \"Dog\", ]\n\n     license_year license_number     animals_name species primary_breed\n1505         2018      LNS147013    Billy the Kid    Goat     Miniature\n1655         2018      LNS132953 Vincent Van Goat    Goat     Miniature\n     secondary_breed weight_kg\n1505         Unknown    103.48\n1655         Unknown     73.96\n\n\n\n\n“not (dog OR cat)”\nWe could also do this in other ways, such as asking for all the entries which are either “Dog” or “Cat”, and then negating them:\n\npetdata[!(petdata$species == \"Cat\" | petdata$species == \"Dog\"), ]\n\n     license_year license_number     animals_name species primary_breed\n1505         2018      LNS147013    Billy the Kid    Goat     Miniature\n1655         2018      LNS132953 Vincent Van Goat    Goat     Miniature\n     secondary_breed weight_kg\n1505         Unknown    103.48\n1655         Unknown     73.96\n\n\n\n\n“not one of [Dog, Cat]”\nAnother clever little operator is the %in% operator, which asks whether something is in a set of things. Unfortunately, we can’t use !%in% to mean “not in”, so we need to put the ! right at the start of the condition:\n\npetdata[!petdata$species %in% c(\"Cat\",\"Dog\"), ]\n\n     license_year license_number     animals_name species primary_breed\n1505         2018      LNS147013    Billy the Kid    Goat     Miniature\n1655         2018      LNS132953 Vincent Van Goat    Goat     Miniature\n     secondary_breed weight_kg\n1505         Unknown    103.48\n1655         Unknown     73.96\n\n\n\n\n\n\n\n\nQuestion 7\n\n\nCreate a new variable in the data, which contains the weights of all the animals, but rounded to the nearest kg.\n\n\n\n\n\n\nHints\n\n\n\n\n\nTry looking up the help documentation for the function round(). Try playing with it in the console, e.g. round(c(3.5, 4.257, 1.1111)). You may find it helpful to look back at 1B #adding/changing-a-variable.\n\n“to the nearest kg” would mean we want no decimal points. Note that round() has a digits argument. e.g. round(22.324, digits = 2) and round(22.324, digits = 1) do different things.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe’re wanting this variable as a new column in the data, so don’t forget the dataframe$newvariable &lt;- ...... bit.\n\npetdata$weight_rounded &lt;- round(petdata$weight_kg)\n\n\n\n\n\nQuestion 8\n\n\nTry giving the dataset to the function summary(). You’ll get out some information on each of the variables. It is likely that you’ll get more useful information for the variables containing information on the animal’s weights than for those containing their names, breeds etc because these variables are vectors of “characters”. We’ll start to look more about different types of data next week.\n\n\n\n\n\nSolution\n\n\n\nEasy to do!\n\nsummary(petdata)\n\n  license_year  license_number     animals_name         species         \n Min.   :2015   Length:1956        Length:1956        Length:1956       \n 1st Qu.:2017   Class :character   Class :character   Class :character  \n Median :2018   Mode  :character   Mode  :character   Mode  :character  \n Mean   :2018                                                           \n 3rd Qu.:2018                                                           \n Max.   :2018                                                           \n primary_breed      secondary_breed      weight_kg       weight_rounded \n Length:1956        Length:1956        Min.   :  0.390   Min.   :  0.0  \n Class :character   Class :character   1st Qu.:  4.707   1st Qu.:  5.0  \n Mode  :character   Mode  :character   Median : 16.630   Median : 17.0  \n                                       Mean   : 15.312   Mean   : 15.3  \n                                       3rd Qu.: 22.500   3rd Qu.: 22.0  \n                                       Max.   :103.480   Max.   :103.0  \n\n\n\n\n\n\n\n\n\n\nSimulating Dice\n\nQuestion 9\n\n\nCopy the code from the lecture which creates a custom function called dice() (copied below).\nBe sure to run the code (highlight it all with your cursor, and hit “run” in the top right, or press Ctrl/Cmd+Enter).\n\ndice &lt;- function(num = 1) {\n  sum(sample(1:6, num, replace=TRUE))\n}\n\n\n\n\n\nWhat did that code do?\nIn a sense, this code does nothing: It won’t give you any output when you run it. What it is actually doing, though, is defining a function called dice(). If you look at your environment panel (top right), you’ll see dice appear when you run the code.\nTo produce some output, we have to call the function dice() (by writing it into code: dice(4), for example). dice() wants to be supplied with some information (in the argument num). If no information is supplied, num will take a default value of 1. (So writing dice() is equivalent to writing dice(1)).\nWhat does dice() do with num? It calls another function, sample(), with 3 arguments. We didn’t write sample(): it’s a function that’s “supplied with” R. To find out more about what sample() does:\n\nclick inside the brackets just after sample() in your R script;\npress TAB (⇥), then F1\nyou should see some help appear in the bottom right-hand panel of RStudio.\n\nYou will find that “sample() takes a sample … from the elements of x …” If you compare the code in RStudio to the code under “Usage” you’ll see that where the help has x, we have 1:6. So what does 1:6 mean? One way to find out is to open the console in RStudio (bottom left) and just type stuff in. What happens when you type 1:6? What about 2:17? (What about 6:1?)\nRemember: The console is the place to “try stuff out” (don’t worry, you can’t break it).\nWhat you will discover is that 1:6 creates a vector (list of similar things, in this case numbers) of the numbers 1-6. The next bit of the sample() function is size. In the dice() function, the num passes down to the size of the sample(): Looking through the help, size is the number of items to choose. So sample(1:6, 1) would choose one number from the numbers 1-6 at random; sample(1:6, 3) would choose 3, and so on. The last argument, replace=TRUE, tells sample() what to do with a number once it’s been picked: Does it go ‘back into the bag’ to be picked again (TRUE) or not? (FALSE)?\nAround the outside is sum() which simply sums the numbers on however many (num) dice you “rolled”.\nPutting it all together, our dice() function “throws num dice” by sample()ing from the numbers 1-6 num times, replaceing each number when it’s been picked, and sums the numbers of all the dice.\n\n\nQuestion 10\n\n\nUse the function you just made to ‘roll a die’ a few times. Check that it works like you expect.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou just need to run dice() a few times. A single die means num = 1, which is the default.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\ndice()\n\n[1] 6\n\ndice()\n\n[1] 2\n\ndice()\n\n[1] 2\n\ndice()\n\n[1] 5\n\n\n\n\n\n\nQuestion 11\n\n\nLook up the function replicate(). We can use it to do something in R lots of times! For instance, replicate(20, 1+1) will evaluate 1+1 twenty times.\nUse replicate() to simulate 20 rolls of a single die, and store the results in an object in your environment. Give it an easily identifiable name.\nWhat does each value in this object represent?\n\n\n\n\n\nSolution\n\n\n\n\nrolls20 &lt;- replicate(20, dice(num = 1))\nrolls20\n\n [1] 2 2 6 3 6 4 5 4 6 4 1 6 5 3 3 3 5 1 6 4\n\n\nEach value in rolls20 represents the simulated roll of a single die. We roll our die, and get a 2, we roll it again and get 2, the third roll we get 6, and so on..\n\n\n\n\nQuestion 12\n\n\nCreate a barplot showing the frequency with which each number was landed on in the 20 rolls.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThe functions table() and barplot() were used to do this in the lecture.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nYour plots will look slightly different to these, because all of our dice are random!\n\n# We can get the frequency table using table()\ntable(rolls20)\n\nrolls20\n1 2 3 4 5 6 \n2 2 4 4 3 5 \n\n# Which we can then pass to the barplot() function:\nbarplot(table(rolls20))\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 13\n\n\nDo the same for 100 rolls, and then for 1,000. What do you notice?\n\n\n\n\n\nSolution\n\n\n\n\nmorerolls &lt;- replicate(100, dice(1))\nbarplot(table(morerolls))\n\n\n\n\n\n\n\nmorerolls2 &lt;- replicate(1000, dice(1))\nbarplot(table(morerolls2))\n\n\n\n\n\n\n\n\nThe more rolls we do of the dice, the flatter the graph becomes. This is because there is an equal probability of the die landing on any of the responses - there is a uniform probability.\n\n\n\n\nQuestion 14\n\n\nCopy the code below into your script and run it. It creates a new function called wdice() which simulates the rolling of num dice which are slightly weighted.\nRoll a single weighted die 20 times and plot the frequency distribution. Do the same for 100 and 1,000 rolls of a single die. Does a pattern emerge? At how many rolls?\n\nwdice &lt;- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n\n\n\n\n\n\nSolution\n\n\n\n\nwdice &lt;- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.15,0.15,0.15,0.15,0.15,0.25)))\n}\n\nwd &lt;- replicate(20, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\nwd &lt;- replicate(1000, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\nwd &lt;- replicate(10000, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\n\nThe die is clearly weighted towards landing on 6. However, is 20 rolls enough to reliably observe this? In our 20 rolls above, it landed on 3 quite a bit too (yours will be different)! The pattern becomes clearer after 1000 rolls.\n\n\n\n\nQuestion 15\n\n\nRemember, wdice() and dice() are really just relying on different functions, like sample(). Try playing around with sample() in the console again - what does the prob = c(....) bit do?\n\n\n\n\n\nSolution\n\n\n\nThe prob bit is defining the probabilities of observing each outcome - i.e. there is a 25% chance of rolling a 6.\n\n\n\n\nQuestion 16\n\n\nLet’s try to modify the wdice() function. Edit the code for wdice() so that 50% of the time it lands on number 6.\n\n\n\n\n\n\nHints\n\n\n\n\n\n\nTo test out your modified function, you will need to re-run the code which defines the function. When we use wdice() we use the function which is in our environment. If we want to edit the function, we need to then overwrite (or “replace”/“reassign”) the object in our environment.\n\nWe need to be careful to remember that the probability of different outcomes should sum to 1 (i.e., it’s not possible to “50% of the time land on 6” as well as “70% of the time land on 5”!).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nwdice &lt;- function(num = 1){\n    sum(sample(1:6, num, replace=TRUE, prob = c(0.1,0.1,0.1,0.1,0.1,0.5)))\n}\n\n\n\n\n\nQuestion 17\n\n\nCan you observe the weighting in your new die (the one which 50% of the time lands on number 6) in only 20 rolls?\n\n\n\n\n\nSolution\n\n\n\n\nwd &lt;- replicate(20, wdice(1))\nbarplot(table(wd))\n\n\n\n\n\n\n\n\nThe die is very clearly weighted to land on 6. We can see this in just 20 rolls. Presumably it will become even clearer if we increased how many times we roll it.\n\n\n\n\nQuestion 18\n\n\nConceptually, what can we learn from this toy example?\n\n\n\n\n\nSolution\n\n\n\nThe more highly weighted a die is, the less we have to roll it in order to observe that weighting."
  },
  {
    "objectID": "01a_R.html",
    "href": "01a_R.html",
    "title": "1A: A first look at R & RStudio",
    "section": "",
    "text": "This reading:\n\nHow does R work?\nHow do we use the Rstudio interface?\n\n\nThe best way to learn R is to use it. Try following along with these reading by typing the code into your R script and running them. You will hopefully get the same output as is presented on this page below each bit of code. If you get errors and warnings, don’t panic - read them!\n\n\n\nR is a calculator\nWhen we first open RStudio, we should see something which looks more or less like the image in Figure 1, where there are several little windows. We are going to explore what each of these little windows offer by just diving in and starting to do things.\n\n\n\n\n\nFigure 1: RStudio, freshly opened\n\n\n\n\nStarting in the left-hand window, you’ll notice the blue sign &gt;.\nThis is where we R code gets executed.\nType 2+2, and hit Enter ↵.\nYou should discover that R is a calculator - R responds by telling us the answer (4).\nLet’s work through some basic operations (adding, subtracting, etc). For instance, can you work out what R will give you for each of these operations?\n\n\nArithmetic operations\n\n\n\n\n\n\n\nCode\n\n\n\n\n\n2 + 5\n\n\n\n10 - 4\n\n\n\n2 * 5\n\n\n\n10 - (2 * 5)\n\n\n\n(10 - 2) * 5\n\n\n\n10 / 2\n\n\n\n3^2\n(the ^ symbol is “to the power of”)\n\n\n\n\n\nShow me the output\n\n\n\nCode\nOutput\n\n\n\n\n2 + 5\n7\n\n\n10 - 4\n6\n\n\n2 * 5\n10\n\n\n10 - (2 * 5)\n0\n\n\n(10 - 2) * 5\n40\n\n\n10 / 2\n5\n\n\n3^2\n9(the ^ symbol is “to the power of”)\n\n\n\n\n\n\nR can get stuck\nWhenever you see the blue sign &gt;, it means R is ready and waiting for you to provide a command.\nIf you type 10 + and press Enter, you’ll see that instead of &gt; you are left with +. This means that R is waiting for more.\nEither give it more (finish the command), or cancel the command by pressing the Escape key on your keyboard.\n\nAs well as performing arithmetic calculations, we can ask R things for which the answer is TRUE or FALSE, such as “Is 3 less than 5?”. If we type 3 &lt; 5 and press Enter, then R should tell us that the statement we gave it is TRUE.\nThese computations don’t return numbers, but instead return logical values. There are few operators that we need to learn about here:\n\nEquality/Inequality: We use the symbols == to mean “is equal to”, and the symbols != for “is not equal to”.\n\nLess Than/Greater Than: To determine whether a value is less/greater than another value, we have our typical symbols &lt; and &gt;. We also have &lt;= and &gt;= when we want to include “less/greater than or equal to”.\n\nWe can combine these with & for “and”, | for “or”, and ! for “not”, to ask R all sorts of things.\nTry and work out what R should give you for each of these (or try it out yourself!):\n\n\nLogical operations\n\n\n\nCode\nOutput\n\n\n\n\n3 &gt; 5\n\n\n\n3 &lt;= 5\n\n\n\n3 &gt;= 3\n\n\n\n3 == 5\n\n\n\n(2 * 5) == 10\n\n\n\n(2 * 5) != 11\n\n\n\n(2 == 2) & (3 == 4)\n\n\n\n(2 == 2) | (3 == 4)\n\n\n\n(2 == 2) & !(3 == 4)\nTRUE\n\n\n\n\n\nShow me the output\n\n\n\nCode\nOutput\n\n\n\n\n3 &gt; 5\nFALSE\n\n\n3 &lt;= 5\nTRUE\n\n\n3 &gt;= 3\nTRUE\n\n\n3 == 5\nFALSE\n\n\n(2 * 5) == 10\nTRUE\n\n\n(2 * 5) != 11\nTRUE\n\n\n(2 == 2) & (3 == 4)\nFALSE\n\n\n(2 == 2) | (3 == 4)\nTRUE\n\n\n(2 == 2) & !(3 == 4)\nTRUE\n\n\n\n\n\n\nFALSE and TRUE as 0 and 1\nIt will become useful to think of these logical values (TRUE and FALSE) as also having intrinsic numeric values of 0 and 1.\nThis is how R will treat them if you ask it to do something that requires the values to be numeric.\nFor example, the code TRUE + 3 will return 4, and FALSE + 3 will return 3.\n\n\n\n\n\n\nR has a memory\nWe can also store things in R’s memory, and to do that we just need to give them a name.\nType x &lt;- 5 and press Enter.\nWhat has happened? We don’t get given an answer like we did with calculations such as 2 + 4. What we’ve done is stored in R’s memory something named x which has the value 5. We can now refer to the name and it will give us the value!\nIf we now type x and press Enter, it gives us whatever we assigned to the name “x”. So it gives us the number 5.\n\nx\n\n[1] 5\n\n\nWhat is going to happen when we type x * 3? It will give us 15!\n\nAssigning names to things in R\nThe &lt;- symbol, pronounced arrow, is what we use to assign a value to a named object:\n\nname &lt;- value\n\n\nNote, there are a few rules about names in R:\n\nNo spaces - spaces inside a name are not allowed (the spaces around the &lt;- don’t matter):\nlucky_number &lt;- 5 ✔ lucky number &lt;- 5 ❌\nNames must start with a letter:\nlucky_number &lt;- 5 ✔ 1lucky_number &lt;- 5 ❌\nCase sensitive:\nlucky_number is different from Lucky_Number\nhere is a set of words you can’t use as names, including: if, else, for, in, TRUE, FALSE, NULL, NA, NaN, function\n(Don’t worry about remembering these, R will tell you if you make the mistake of trying to name a variable after one of these).\n\n\n\n\n\n\nThe Console and The Environment\nIf you are working along with us, you might have also noticed that something else happened when we executed the code x &lt;- 5. The thing we named x with a value of 5 suddenly appeared in the top-right window. This is known as the environment (Figure 2), and it shows everything that we store in R.\n\n\n\n\n\nFigure 2: Assigning names to objects stores them in R’s environment.\n\n\n\n\nSo we’ve now made use of two of the panes that we see in RStudio:\nWhere code is run: When we’ve been writing and running R code (e.g. typing 2+5 or x&lt;-5 and pressing Enter), we’ve been doing it in the “console”.\nThe console is where R code gets executed (i.e. where our coded instruction to R code is interpreted and acted on), but as we’ll see below, it isn’t where all R code gets written.\nWhere things get stored: We’ve also been learning about how we can store things in R’s memory (the environment) by assigning a name to them using the &lt;- operator. The top-right pane of RStudio shows us the environment, where we can see everything that we have stored in R. Note that this also means we can keep track of what objects we have saved that are available for our use. If we never stored an object named “peppapig”, then R will give us an error when we do something like:\n\n2*peppapig\n\nError in eval(expr, envir, enclos): object 'peppapig' not found\n\n\nNow that we have an idea of what the console and the environment are for, we are well on our way. If you want a silly analogy, the console is like R’s mouth, where we feed it things, and the environment is just its memory, where it remembers what things are what. We can see these in Figure 3. Note however, that the console has been moved down to the bottom-left, as we are introducing a new pane above it. This is where we move to next.\n\n\n\n\n\nFigure 3: RStudio panes: Code is executed in the console, and objects are stored in the environment.\n\n\n\n\n\n\n\n\n\nR Scripts and the Editor\nWhat if we want to edit our code? Whatever we write in the console just disappears upwards. What if we want to change things we did earlier on?\nWhile the console is where code gets executed, it doesn’t have to be where code gets written.. We can write and edit our code in a separate place before we then send it to the console to be executed!!\nThe standard place to write and edit things is in an R scipt. We can open one by doing File &gt; New File &gt; R script, and a new file will open in the top-left pane of RStudio. The console will be shoved down to the bottom-left.\nIn the R script, we can write code. For instance, we might write:\n\nx &lt;- 210\ny &lt;- 15\nx / y\n\nNotice that nothing happens when we write each line. It’s not like writing in the console where R tells us the answers. This is because this code is not yet being executed. We haven’t actually fed it to R.\nThere are a couple of useful ways we can send the code to R.\n\nPosition your text-cursor (blinking vertical line) on the line of code we wish to run and press Ctrl+Enter (Windows) or Cmd+Enter (MacOS)\n\nPosition your text-cursor (blinking vertical line) on the line of code we wish to run and press the “Run” button in the top right of the script.\n\nWhen we do this, the line of code will be sent down to the console, where it will be executed, and R will do it’s thing.\nFor example, if we had sent the line x &lt;- 210 down to the console, R would then store the number 210 with the name x in our environment (as in Figure 4). Additionally, it will move the text-cursor to the next line, so we can just press Ctrl+Enter again to run the next line (and so on.).\n\n\n\n\n\nFigure 4: Code written in the script can be sent down to the console, where it is executed. In this example, the execution of the code stores an object in the environment.\n\n\n\n\nBy writing our code in a file such as an R script before sending it to the console we can edit, save, and share our code. This makes it so much more useful than just using the console (which is more like writing on scratch paper, where we can’t keep anything).\nFor instance, let’s say we made a mistake earlier, and instead of “x” being 210, it should have been 211. Well, we can just edit the script, and re-run it.\n\nRegularly save your scripts!\nTo save an R script that is open, we just\n\nFile &gt; Save (or Ctrl+S)\nLocate to the folder where we want to save the file.\n\ngive it an appropriate name, and click save.\n\nNOTE: When you save R script files, they terminate with a .R extension.\n\n\n\n\n\n\n\nLooking ahead to RMarkdown\n\n\n\n\n\n\nIn addition to R scripts, there is another type of document we can create, known as “Rmarkdown”.\nRmarkdown documents combine the analytical power of R and the utility of a text-processor. We can have one document which contains all of our analysis as well as our written text, and can be compiled into a nicely formatted report. This saves us doing analysis in R and copying results across to Microsoft Word. It ensures our report accurately reflects our analysis. Everything that you’re reading now has all been written in Rmarkdown!\n\n\n\nFigure 5: An example RMarkdown document\n\n\nWe’re going to learn more about Rmarkdown documents and how to write them later on, but the broad idea is that we can writing normal text interspersed with “code-chunks” (i.e., chunks of code!). RMarkdown documents looks much like an R script, only the code is contained within the grey-boxes, and text is written in between (see Figure 5). RMarkdown documents can then be compiled to create a lovely .pdf, .html, or .docx file.\n\n\n\n\n\nFigure 6: RMarkdown Workflow\n\n\n\n\n\n\n\n\n\n\n\n\nThe Four RStudio Panes\nWe’ve now seen almost all the different panes in RStudio:\n\n\nThe console is where R code gets executed\nThe environment is R’s memory, you can assign something a name and store it here, and then refer to it by name in your code.\nThe editor is where you can write and edit R code in R scripts and Rmarkdown documents. You can then send this to the console for it to be executed.\n\n\n\n\n\n\n\n\nFigure 7: The Four Panes of RStudio\n\n\n\n\n\nWe are yet to use the bottom-right window, but this is an easy one to explain. It is where we can see any plots that we create, where we can browse our files, and where we can ask R for some help documentation. We’ll make more use of this later on, but for now try typing plot(x = 4, y = 2) into the console and seeing what happens.\n\n\nProjects and file organisation\nWe’re not going to speak too much about this here but one key thing to remember is that R is working from a specific place in your computer. You can find out where by typing getwd() into the console.\nAn easy way to keep things organised is to set up an “R project”. This basically associates a specific folder on your computer with your working in R, and it means it will automatically look for things in that folder.\nWe recommend that you start a project for this course (call it something like “usmr”). This will the be project that you open whenever you work on this course (RStudio will usually re-open the previous project you were working on when you closed it).\nWith that project open, we suggest that you start a new script for each week, in which you complete your exercises, and which you then remember to save!\nIf you haven’t already, we suggest you start an R project by using (in the top menu of RStudio), File &gt; New Project and following the instructions. It will create a folder on your computer somewhere of your choosing, and you will now notice that if you click in the “Files” tab in the bottom right pane of RStudio, you can see the project folder!\n\n\n\n\n\n\nGood Habits\nAlong with regular saving of work and organising your files, it will be very useful in the long-run if we get used to always “starting fresh” when we open R.\nWe need to start thinking of the code that we write in an R script as a set of consecutive instructions that we can give to R in order to achieve our goal. It’s just a blank slate on which we write (in language R understands) “do this. now do this. now do this..” and so on.\nThis means that the script contains all the information needed.\nSo we can now:\n\nEmpty our environment\nRestart R\nRun all the code in our script (highlight multiple lines of code to run them all at once)\n\nand we’re back to where we are! This is great for when we make mistakes (we’re going to make many many mistakes!), because we can just clear everything, start at the top of our script, and work downwards to figure out what has gone wrong.\n\nTidying up\n\nTo empty our environment, we can click on the little broomstick icon: .\nTo restart the R Session (not always necessary, but good practice) in the top menu, we choose Session &gt; Restart R (or press Ctrl+Shift+F10).\n\n\nThe other very useful thing that we can do in a script is to write comments for ourselves or for others. By starting a line with a #, R will know that that entire line is not code, and so it won’t try to do anything with it. For instance, if we write these lines in our script, and send them both down to the console, nothing happens for the first line:\n\n\nComments\n\n# The line below will add 5 to 2. \n2+5\n\n[1] 7\n\n\n\n\nIf we forget the #\n\nThe line below will add 5 to 2. \n2+5\n\n\nError: unexpected symbol in “The line”\n\n\n\n\n\n\n\n\nUseful Settings\nBelow are a couple of our recommended settings for you to change as you begin your journey in R. After you’ve changed them, take a 5 minute break before moving on to the next reading.\n\n1. Clean environments\nAs you use R more, you will store lots of things with different names. Throughout this course alone, you’ll probably name hundreds of different things. This could quickly get messy within our project.\nWe can make it so that we have a clean environment each time you open RStudio. This will be really handy.\n\nIn the top menu, click Tools &gt; Global Options…\nThen, untick the box for “Restore .RData into workspace at startup”, and change “Save workspace to .RData on exit” to Never:\n\n\n\n\n2. Wrapping code\nIn the editor, you might end up with a line of code which is really long, but you can make RStudio ‘wrap’ the line, so that you can see it all, without having to scroll:\n\nx &lt;- 1+2+3+6+3+45+8467+356+8565+34+34+657+6756+456+456+54+3+78+3+3476+8+4+67+456+567+3+34575+45+2+6+9+5+6\n\n\nIn the top menu, click Tools &gt; Global Options…\nIn the left menu of the box, click “Code”\nTick the box for “Soft-wrap R source files”"
  },
  {
    "objectID": "01b_data.html",
    "href": "01b_data.html",
    "title": "1B: More R - Basic Data Skills",
    "section": "",
    "text": "This reading:\n\nHow does R store data?\n\nWhat can R do with data?\n\nHow can we use R to access and manipulate data?"
  },
  {
    "objectID": "01b_data.html#accessing-subsets-of-data",
    "href": "01b_data.html#accessing-subsets-of-data",
    "title": "1B: More R - Basic Data Skills",
    "section": "Accessing subsets of data",
    "text": "Accessing subsets of data\nWhat if we want to extract certain subsections of our dataset, such as specific observational units or variables? This is where we learn about two important bits of R code used to access parts of data - the dollar sign $, and the square brackets [].\n\nThe dollar sign $\nThe dollar sign allows us to extract a specific variable from a dataframe. For instance, we can pull out the variable named “eye_color” in the data, by using $eye_color after the name that we gave our dataframe.\nRemember that each variable in a dataframe is a vector (a set of values). Once extracted, we will have a vector and not a dataframe.\n\nstarwars2$eye_color\n\n [1] \"blue\"          \"yellow\"        \"red\"           \"yellow\"       \n [5] \"brown\"         \"blue\"          \"blue\"          \"red\"          \n [9] \"brown\"         \"blue-gray\"     \"blue\"          \"blue\"         \n[13] \"blue\"          \"brown\"         \"black\"         \"orange\"       \n[17] \"hazel\"         \"blue\"          \"yellow\"        \"brown\"        \n[21] \"red\"           \"brown\"         \"blue\"          \"orange\"       \n[25] \"blue\"          \"brown\"         \"black\"         \"red\"          \n[29] \"blue\"          \"orange\"        \"orange\"        \"orange\"       \n[33] \"yellow\"        \"orange\"        NA              \"brown\"        \n[37] \"yellow\"        \"pink\"          \"hazel\"         \"yellow\"       \n[41] \"black\"         \"orange\"        \"brown\"         \"yellow\"       \n[45] \"black\"         \"brown\"         \"blue\"          \"orange\"       \n[49] \"yellow\"        \"black\"         \"blue\"          \"brown\"        \n[53] \"brown\"         \"blue\"          \"yellow\"        \"blue\"         \n[57] \"blue\"          \"brown\"         \"brown\"         \"brown\"        \n[61] \"brown\"         \"yellow\"        \"yellow\"        \"black\"        \n[65] \"black\"         \"blue\"          \"unknown\"       \"unknown\"      \n[69] \"gold\"          \"black\"         \"green, yellow\" \"blue\"         \n[73] \"brown\"         \"black\"         NA             \n\n\n\n\nThe square brackets []\nSquare brackets are used to do what is known as indexing (finding specific entries in your data).\nWe can retrieve bits of data by identifying the \\(i^{th}\\) entry(s) inside the square brackets, for instance:\n\n# assign the numbers 10, 20 ... 100 to the name \"somevalues\"\nsomevalues &lt;- c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100)\n\n# pull out the 3rd entry\nsomevalues[3]\n\n[1] 30\n\n\nIn the above example, we have a vector (a single sequence of values), and so we can retrieve entries with the syntax:\n\nvector[entry]\n\n In a dataframe we have an extra dimension - we have rows and columns. Using square brackets with a dataframe needs us to specify both:\n\n\ndataframe[rows, columns]\n\n\nLet’s look at some examples:\n\n\nExamples of Indexing\n\nSpecifying row number and column number:\n\n\n# first row, fourth column\nstarwars2[1, 4]\n# tenth row, first column\nstarwars2[10, 1]\n\n\nIf we leave either rows or columns blank, then we will get out all of them:\n\n\n# tenth row, all columns\nstarwars2[10, ]\n# all rows, 2nd column\nstarwars2[ , 2]\n\n\nThere are is another way to identify column - we can use the name in quotation marks:\n\n\n# first row, \"species\" column\nstarwars2[1, \"species\"]\n\n\nWe can also ask for multiple rows, or multiple columns, or both! To do that, we use c():\n\n\n# the 1st AND the 6th rows, and the 1st AND 3rd columns\nstarwars2[c(1,6), c(1,3)] \n\n\nAnd we can specify a sequence using the colon, from:to: 2\n\n\n# FROM the 1st TO the 6th row, all columns\nstarwars2[1:6, ] \n\n\nWe can even use the two accessors in combination:3\n\n\n# extract the variable called \"name\" and show the 20th entry\nstarwars2$name[20]  \n\n\n\nShow me the output\n\nSpecifying row number and column number:\n\n\n# first row, fourth column\nstarwars2[1, 4]\n\n[1] \"blue\"\n\n# tenth row, first column\nstarwars2[10, 1]\n\n[1] \"Obi-Wan Kenobi\"\n\n\n\nIf we leave either rows or columns blank, then we will get out all of them:\n\n\n# tenth row, all columns\nstarwars2[10, ]\n\n             name height    hair_color eye_color homeworld species\n10 Obi-Wan Kenobi    182 auburn, white blue-gray   Stewjon   Human\n\n# all rows, 2nd column\nstarwars2[ , 2]\n\n [1] 172 167  96 202 150 178 165  97 183 182 188 180 228 180 173 175 170 180 170\n[20] 183 190 177 175 180 150  88 160 191 170 196 224 206 137 112 170 163 175 180\n[39] 178  94 122 163 188 198 196 171 184 188 264 188 196 185 157 183 183 170 166\n[58] 165 193 191 183 168 198 229 213 167  79 193 191 178 216 234 188 206 180\n\n\n\nThere are is another way to identify column - we can use the name in quotation marks:\n\n\n# first row, \"species\" column\nstarwars2[1, \"species\"]\n\n[1] \"Human\"\n\n\n\nWe can also ask for multiple rows, or multiple columns, or both! To do that, we use c():\n\n\n# the 1st AND the 6th rows, and the 1st AND 3rd columns\nstarwars2[c(1,6), c(1,3)] \n\n            name  hair_color\n1 Luke Skywalker       blond\n6      Owen Lars brown, grey\n\n\n\nAnd we can specify a sequence using the colon, from:to:\n\n\n# FROM the 1st TO the 6th row, all columns\nstarwars2[1:6, ] \n\n            name height  hair_color eye_color homeworld species\n1 Luke Skywalker    172       blond      blue  Tatooine   Human\n2          C-3PO    167        &lt;NA&gt;    yellow  Tatooine   Human\n3          R2-D2     96        &lt;NA&gt;       red     Naboo   Droid\n4    Darth Vader    202        none    yellow  Tatooine   Human\n5    Leia Organa    150       brown     brown  Alderaan   Human\n6      Owen Lars    178 brown, grey      blue  Tatooine   Human\n\n\n\nWe can even use the two accessors in combination:\n\n\n# extract the variable called \"name\" and show the 20th entry\nstarwars2$name[20]  \n\n[1] \"Boba Fett\"\n\n\n\n\n\nThe dollar sign $\nUsed to extract a variable from a dataframe:\n\ndataframe$variable\n\nThe square brackets []\nUsed to extract parts of an R object by identifying rows and/or columns, or more generally, “entries”. Left blank will return all.\n\nvector[entries]\ndataframe[rows, columns]"
  },
  {
    "objectID": "01b_data.html#accessing-by-a-condition",
    "href": "01b_data.html#accessing-by-a-condition",
    "title": "1B: More R - Basic Data Skills",
    "section": "Accessing by a condition",
    "text": "Accessing by a condition\nWe can also do something really useful, which is to access all the entries in the data for which a specific condition is true.\nLet’s take a simple example to start:\n\nsomevalues &lt;- c(10, 10, 0, 20, 15, 40, 10, 40, 50, 35)\n\nTo only select values which are greater than 20, we can use:\n\nsomevalues[somevalues &gt; 20]\n\n[1] 40 40 50 35\n\n\n\nUnpacking: somevalues[somevalues &gt; 20]\n First, let’s look at what somevalues &gt; 20 does. It returns TRUE for the entries of somevalues which are greater than 20, and FALSE for the entries of somevalues that are not (that is, which are less than, or equal to, 20.\nThis statement somevalues &gt; 20 is called the condition.\n\nsomevalues &gt; 20\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n\n\nNow consider putting that sequence of TRUEs and FALSEs inside the square brackets in somevalues[]. This returns only the entries of somevalues for which the condition is TRUE.\n\nsomevalues[c(FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,TRUE,TRUE,TRUE)]\n\n[1] 40 40 50 35\n\n\nSo what we’re doing is using a condition inside the square brackets to return all the values for which that condition is TRUE.\nAnd we’re being super efficient, because we don’t want to write out TRUEs and FALSEs all day, so we just give the conditional question inside the brackets directly:\n\nsomevalues[somevalues &gt; 20]\n\n[1] 40 40 50 35\n\n\n\n We can extend this same logic to a dataframe. Let’s suppose we want to access all the entries in our Star Wars data who have the value “Droid” in the species variable. To work out how to do this, we first need a line of code which defines our condition - one which returns TRUE for each entry of the species variable which is “Droid”, and FALSE for those that are not “Droid”.\nWe can use the dollar sign to pull out the species variable:\n\nstarwars2$species\n\n [1] \"Human\"        \"Human\"        \"Droid\"        \"Human\"        \"Human\"       \n [6] \"Human\"        \"Human\"        \"Droid\"        \"Human\"        \"Human\"       \n[11] \"Human\"        \"Human\"        \"Wookiee\"      \"Human\"        \"Rodian\"      \n[16] \"Hutt\"         \"Human\"        \"Human\"        \"Human\"        \"Human\"       \n[21] \"Trandoshan\"   \"Human\"        \"Human\"        \"Mon Calamari\" \"Human\"       \n[26] \"Ewok\"         \"Sullustan\"    \"Neimodian\"    \"Human\"        \"Gungan\"      \n[31] \"Gungan\"       \"Gungan\"       \"Toydarian\"    \"Dug\"          \"unknown\"     \n[36] \"Human\"        \"Zabrak\"       \"Twi'lek\"      \"Twi'lek\"      \"Vulptereen\"  \n[41] \"Xexto\"        \"Toong\"        \"Human\"        \"Cerean\"       \"Nautolan\"    \n[46] \"Zabrak\"       \"Tholothian\"   \"Iktotchi\"     \"Quermian\"     \"Kel Dor\"     \n[51] \"Chagrian\"     \"Human\"        \"Human\"        \"Human\"        \"Geonosian\"   \n[56] \"Mirialan\"     \"Mirialan\"     \"Human\"        \"Human\"        \"Human\"       \n[61] \"Human\"        \"Clawdite\"     \"Besalisk\"     \"Kaminoan\"     \"Kaminoan\"    \n[66] \"Human\"        \"Aleena\"       \"Skakoan\"      \"Muun\"         \"Togruta\"     \n[71] \"Kaleesh\"      \"Wookiee\"      \"Human\"        \"Pau'an\"       \"unknown\"     \n\n\nAnd we can ask R whether each value is equal to “Droid”\n\nRemember: in R, we ask whether something is equal to something else by using a double-equals, ==. A single equal sign would be wrong, as it denotes assignment.\n\n\nstarwars2$species == \"Droid\"\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[73] FALSE FALSE FALSE\n\n\nFinally, we can use this condition inside our square brackets to access the entries of the data for which this condition is TRUE:\n\n# I would read the code below as: \n# \"In the starwars2 dataframe, give me all the rows \n# for which the condition starwars2$species==\"Droid\"\n# is TRUE, and give me all the columns.\"\n\nstarwars2[starwars2$species == \"Droid\", ]\n\n   name height hair_color eye_color homeworld species\n3 R2-D2     96       &lt;NA&gt;       red     Naboo   Droid\n8 R5-D4     97       &lt;NA&gt;       red  Tatooine   Droid"
  },
  {
    "objectID": "01b_data.html#more-complex-conditions",
    "href": "01b_data.html#more-complex-conditions",
    "title": "1B: More R - Basic Data Skills",
    "section": "More complex conditions",
    "text": "More complex conditions\nThinking back to Reading 1A when we first introduced R, we talked briefly about “logical operators”. Specifically, the operators &, |, and ! (for “and”, “or”,” and “not”), will come in handy now.\nFor instance, we can now extract all those in the dataset which are humans and taller than 190cm:\n\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$species==\"Human\" AND starwars2$height &gt; 190 are TRUE, \n# and give me all the columns.\"\nstarwars2[starwars2$species == \"Human\" & starwars2$height &gt; 190, ]\n\n                  name height hair_color eye_color homeworld species\n4          Darth Vader    202       none    yellow  Tatooine   Human\n59               Dooku    193      white     brown   Serenno   Human\n60 Bail Prestor Organa    191      black     brown  Alderaan   Human\n\n\nOr we can extract all those in the dataset which are either droids or ewoks:\n\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$species==\"Droid\" OR starwars2$species==\"Ewok\" is TRUE, \n# and give me all the columns.\"\nstarwars2[starwars2$species == \"Droid\" | starwars2$species == \"Ewok\", ]\n\n                    name height hair_color eye_color homeworld species\n3                  R2-D2     96       &lt;NA&gt;       red     Naboo   Droid\n8                  R5-D4     97       &lt;NA&gt;       red  Tatooine   Droid\n26 Wicket Systri Warrick     88      brown     brown     Endor    Ewok"
  },
  {
    "objectID": "01b_data.html#editing-specific-entries",
    "href": "01b_data.html#editing-specific-entries",
    "title": "1B: More R - Basic Data Skills",
    "section": "Editing specific entries",
    "text": "Editing specific entries\nNow that we’ve seen a few ways of accessing sections of data, we can learn how to edit them! One of the most common reasons you will need to modify entries in your data is in data cleaning. This is the process of identifying incorrect / incomplete / irrelevant data, and replacing / modifying / deleting them.\nAbove, we looked at the subsection of the data where the species variable had the entry “Droid”. Some of you may have noticed earlier that we had some data on C3PO. Are they not also a droid?\n\n\n\n(Looks pretty Droid-y to me! disclaimer: I know nothing about Star Wars 🙂 )\nJust as we saw above how to access specific entries, e.g.:\n\n# 2nd row, all columns\nstarwars2[2, ]\n\n   name height hair_color eye_color homeworld species\n2 C-3PO    167       &lt;NA&gt;    yellow  Tatooine   Human\n\n# 2nd row, 6th column (the \"species\" column)\nstarwars2[2,6]\n\n[1] \"Human\"\n\n\nWe can change these by assigning them a new value (remember the &lt;- symbol). In doing so, we overwrite4 the entry in the 2nd row and 6th column of the data (starwars2[2,6]) with the value “Droid”.\n\n# C3PO is a droid, not a human\nstarwars2[2,6] &lt;- \"Droid\"\n# Look at the 2nd row now -\n# the entry in the \"species\" column has changed:\nstarwars2[2, ]\n\n   name height hair_color eye_color homeworld species\n2 C-3PO    167       &lt;NA&gt;    yellow  Tatooine   Droid"
  },
  {
    "objectID": "01b_data.html#editing-entries-via-a-condition",
    "href": "01b_data.html#editing-entries-via-a-condition",
    "title": "1B: More R - Basic Data Skills",
    "section": "Editing entries via a condition",
    "text": "Editing entries via a condition\nWe saw above how to access parts of data by means of a condition, with code such as:\n\n# \"In the starwars2 dataframe, give me all the rows for which the\n# condition starwars2$homeworld==\"Naboo\" is TRUE, and give me all the columns.\"\nstarwars2[starwars2$homeworld==\"Naboo\", ]\n\n            name height hair_color eye_color homeworld species\n3          R2-D2     96       &lt;NA&gt;       red     Naboo   Droid\n19     Palpatine    170       grey    yellow     Naboo   Human\n30 Jar Jar Binks    196       none    orange     Naboo  Gungan\n31  Roos Tarpals    224       none    orange     Naboo  Gungan\n32    Rugor Nass    206       none    orange     Naboo  Gungan\n52  Gregar Typho    185      black     brown     Naboo   Human\n53         Cordé    157      brown     brown     Naboo   Human\n58         Dormé    165      brown     brown     Naboo   Human\n\n\nWhat if we wanted to modify it so that every character from “Naboo” was actually of species “Nabooian”?\nWe can do that in a number of ways, all of which do the same thing - namely, they access parts of the data and assign them the new value “Nabooian”.\nThe lines of code below all do exactly that, in different ways. We’ve also tried to give a way of interepreting each line.\n\n# In the starwars2 data, give the rows for which condition \n# starwars2$homeworld==\"Naboo\" is TRUE, and select only the \"species\" column. \n# Assign to these selected entries the value \"Nabooian\".\nstarwars2[starwars2$homeworld==\"Naboo\", \"species\"] &lt;- \"Nabooian\"\n\n\n# In the starwars2 data, give the rows for which condition \n# starwars2$homeworld==\"Naboo\" is TRUE, and select only the 6th column. \n# Assign to these selected entries the value \"Nabooian\".\nstarwars2[starwars2$homeworld==\"Naboo\", 6] &lt;- \"Nabooian\"\n\n\n# Extract the species variable from the starwars2 data (it's a vector).\n# Pick the entries for which the condition starwars2$homeworld==\"Naboo\" is TRUE.\n# Assign to these selected entries the value \"Nabooian\".\nstarwars2$species[starwars2$homeworld==\"Naboo\"] &lt;- \"Nabooian\"\n\n\n\n\n\n\n\noptional: a little extra…\n\n\n\n\n\nIn a similar way, we could have changed C-3PO to a Droid without ever having to know what row of the data they were in!\n\n# for the row(s) where the name variable in starwars2\n# is equal to \"C-3PO\", in the species variable we assign\n# that entry to be \"Droid\"\nstarwars2[starwars2$name==\"C-3PO\", \"species\"] &lt;- \"Droid\""
  },
  {
    "objectID": "01b_data.html#addingchanging-a-variable",
    "href": "01b_data.html#addingchanging-a-variable",
    "title": "1B: More R - Basic Data Skills",
    "section": "Adding/Changing a variable",
    "text": "Adding/Changing a variable\nAnother thing we might want to do is change a whole variable (a whole column) in some way.\nThe logic is exactly the same, for instance, we can take the variable “height” from the dataframe “starwars2”, dividing it by 100 via starwars2$height / 100, and then assign the result to the same variable name in the data, i.e. we overwrite the column:\n\nstarwars2$height &lt;- starwars2$height / 100\n\nWe could instead have added a new column named “height_m” with those values if we did not want to overwrite “height”:\n\nstarwars2$height_m &lt;- starwars2$height / 100\n\nThis would have left the “height” variable as-is, and created a new one called “height2” which was the values in “height” divided by 100."
  },
  {
    "objectID": "01b_data.html#removing-rows-or-columns",
    "href": "01b_data.html#removing-rows-or-columns",
    "title": "1B: More R - Basic Data Skills",
    "section": "Removing rows or columns",
    "text": "Removing rows or columns\nLastly, we might want to change the data by removing a row or a column. Again, the logic remains the same, in that we use &lt;- to assign the edited data to a name (either a new name, thus creating a new object, or an existing name, thereby overwriting that object).\nFor instance, notice that the 35th and 75th rows of our data probably aren’t a valid observation - I’m reasonably sure that Marge and Homer Simpson never appeared in Star Wars:\n\nstarwars2[c(35,75), ]\n\n            name height hair_color eye_color   homeworld species\n35 Marge Simpson    1.7       Blue      &lt;NA&gt; Springfield unknown\n75 Homer Simpson    1.8       &lt;NA&gt;      &lt;NA&gt; Springfield unknown\n\n\nWe can remove a certain row(s) by using a minus sign - inside the square brackets\n\n# everything minus the 75th row\nstarwars2[-75, ]\n# everything minus the (35th and 75th rows)\nstarwars2[-c(35, 75), ]\n\nAnd we can simply re-use the name “starwars2” to overwrite the data and make this change take effect (rather than just print out the result, which the code above did):\n\nstarwars2 &lt;- starwars2[-c(35, 75), ]\n\n(now, in the environment pane of Rstudio, the object named “starwars2” will say 73 observations, rather than 75, which it had before - we’ve removed the 2 rows)\n The same logic applies for columns:\n\n# Create a new object called \"anonymous_starwars2\" and assign it \n# to the values which are the \"starwars2\" dataframe minus the \n# 1st column (the \"name\" column):\nanonymous_starwars2 &lt;- starwars2[, -1]\n# dimensions of our initial data\ndim(starwars2)\n\n[1] 73  6\n\n# the data we just assigned has one fewer columns\ndim(anonymous_starwars2)\n\n[1] 73  5"
  },
  {
    "objectID": "01b_data.html#footnotes",
    "href": "01b_data.html#footnotes",
    "title": "1B: More R - Basic Data Skills",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTo save as .csv in Microsoft Excel, we go to File &gt; Save as, and then in the Save as Type box, choose to save the file as CSV (Comma delimited)↩︎\nThe colon operator, from:to, creates a vector from the value from to the value to in steps of 1.\nFor instance, 1:6 is the same as c(1,2,3,4,5,6).↩︎\nNote: When we do this, we don’t have the comma inside the square brackets.\nWhen we use the $ to pull out a variable, such as starwars2$name, we no longer have a dataframe.\nstarwars2$name doesn’t have rows and columns, it just has a series of values - it’s a vector!\nSo when you are using [] with a vector (1 dimension) rather than a dataframe (2 dimensions), you don’t specify [rows, columns], but simply [entry].↩︎\nyou could think of this as replacing / overwriting / reassigning the entry↩︎"
  },
  {
    "objectID": "02_ex.html",
    "href": "02_ex.html",
    "title": "Exercises: More R; Estimates & Intervals",
    "section": "",
    "text": "Question 0"
  },
  {
    "objectID": "02_ex.html#optional-extras",
    "href": "02_ex.html#optional-extras",
    "title": "Exercises: More R; Estimates & Intervals",
    "section": "Optional Extras",
    "text": "Optional Extras\n\nOptional Extra\n\n\nNote that the confidence interval from the previous question is concerned with describing the abstract and theoretical distribution of “what the mean sleep quality rating would look like from all possible samples of this size that I could take”. In order to do this we used a formula to describe the spread of this distribution, and in doing so had to assume that the standard deviation of our sample is a good approximation of the standard deviation of the population, and that the population is normally distributed.\nWe can also avoid ever using the standard deviation of our sample (sd(usmr2022$sleeprating)), and instead approximate the sampling distribution of the mean by “bootstrapping” - taking repeated resamples with replacement from the original sample (see 2B#standard-error.\n\nbootstrap_means &lt;- replicate(1000, mean(sample(observed_sample, replace = TRUE)))\n\n\nCreate an object that contains the 10,000 means from 10,000 resamples of our sleep ratings.\n\nThe distribution of resample means is the ‘bootstrap distribution’. Plot a histogram of it. What is the standard deviation? How does it compare to the standard error you calculated in the previous question with the formula?\n\nAt what values does the middle 95% of the bootstrap distribution fall?\n\n\n\n\n\n\n\nHints\n\n\n\n\n\nFor 3, look up quantile(). We saw this in 2B #confidence-intervals.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nResample means\nHere is our sample of sleep ratings:\n\nsleeprates &lt;- usmr2022$sleeprating\n\nAnd we can get rid of the NA’s:\n\nsleeprates &lt;- sleeprates[!is.na(sleeprates)]\n\nWe can resample with replacement from this set of numbers by using the replace = TRUE argument in the sample() function.\nNote, we’re leaving size = blank, which means it will stop at the same length as the original vector we give it.\n\nsample(sleeprates, replace = TRUE)\n\nand the mean of a given resample is calculated by wrapping mean() around the above code:\n\nmean(sample(sleeprates, replace = TRUE))\n\n[1] 63.79739\n\n\nfinally, we’ll do it lots and lots of times, using replicate():\n\nBSmeans &lt;- replicate(10000, mean(sample(sleeprates, replace = TRUE)))\n\n\n\nBootstrap Distribution\nHere’s the histogram of the bootstrap distribution:\n\nhist(BSmeans)\n\n\n\n\n\n\n\n\nAnd here’s the standard deviation of that distribution. This is a bootstrapped estimate of the standard error.\n\nsd(BSmeans)\n\n[1] 1.869135\n\n\nRecall our standard error calculated using \\(\\frac{s}{\\sqrt{n}}\\) from the previous question was 1.88\n\n\nPercentiles\nWe can get the 2.5% and 97.5% percentiles (i.e. getting the middle 95%), using the code below. Recall our confidence intervals that we computed analytically were 61.46 and 68.82.\n\nquantile(BSmeans, c(.025,.975))\n\n    2.5%    97.5% \n61.41160 68.72549 \n\n\n\n\n\n\n\n\n\n\n\nbootstraps\n\n\n\n\n\nBootstrapping is a great way to learn about sampling variability because it allows us to actually plot, summarise and describe what would otherwise be an abstract conceptual distribution.\nIt can also be a useful tool in practice, but it doesn’t come without its own problems/complexities. One important thing to note is that it often works worse than traditional methods for small samples, especially skewed samples (i.e. bootstrapping a “95% CI” for a small sample will often be too narrow and &lt;95%)."
  },
  {
    "objectID": "02a_measurement.html",
    "href": "02a_measurement.html",
    "title": "2A: Measurement & Distributions",
    "section": "",
    "text": "This reading:\n\nWhat different types of data can we collect?\nHow can we summarise and visualise distributions of different types of data?\n\nAlso:\n\nThe “tidyverse”: a different style of coding in R"
  },
  {
    "objectID": "02a_measurement.html#categorical",
    "href": "02a_measurement.html#categorical",
    "title": "2A: Measurement & Distributions",
    "section": "Categorical",
    "text": "Categorical\n\nCategorical variables tell us what group or category each individual belongs to. Each distinct group or category is called a level of the variable.\n\n\n\n\n\n\n\n\nType\nDescription\nExample\n\n\n\n\nNominal (Unordered categorical)\nA categorical variable with no intrinsic ordering among the levels.\nSpecies: Dog, Cat, Parrot, Horse, …\n\n\nOrdinal (Ordered categorical)\nA categorical variable which levels possess some kind of order\nLevel: Low, Medium, High\n\n\nBinary categorical\nA special case of categorical variable with only 2 possible levels\nisDog: Yes or No.\n\n\n\n\nIf we want to summarise a categorical variable into a single number, then the simplest approach is to use the mode:\n\nMode: The most frequent value (the value that occurs the greatest number of times).\n\nWhen we have ordinal variables, there is another option, and that is to use the median:\n\nMedian: This is the value for which 50% of observations are lower and 50% are higher. It is the mid-point of the values when they are rank-ordered. (Note that “lower” and “higher” requires our values to have an order to them)\n\nWhen we use the median as our measure of central tendency (i.e. the middle of the distribution) and we want to discuss how spread out the spread are around it, then we will want to use quartiles. The Inter-Quartile Range (IQR) is obtained by rank-ordering all the data, and finding the points at which 25% (one quarter) and 75% (three quarters) of the data falls below (this makes the median the “2nd quartile”).\nIn our dataset on passwords, we have various categorical variables, such as the type of password (categories like “animal”, “fluffy” etc).\nThere are various ways we might want to summarise categorical variables like this. We have already seen the code to do this in our example of the dice simulation - we can simply counting the frequencies in each level:\n\ntable(pwords$type)\n\n\n             animal          cool-macho              fluffy                food \n                 29                  79                  44                  11 \n               name           nerdy-pop    password-related     rebellious-rude \n                183                  30                  15                  11 \nsimple-alphanumeric               sport \n                 61                  37 \n\n\nThis shows us that the mode (most common) is “name” related passwords.\nWe could also convert these to proportions, by dividing each of these by the total number of observations. For instance, here are the percentages of passwords of each type1:\n\ntable(pwords$type) / sum(table(pwords$type)) * 100\n\n\n             animal          cool-macho              fluffy                food \n                5.8                15.8                 8.8                 2.2 \n               name           nerdy-pop    password-related     rebellious-rude \n               36.6                 6.0                 3.0                 2.2 \nsimple-alphanumeric               sport \n               12.2                 7.4 \n\n\n\nOften, if the entries in a variable are characters (letters), then many functions in R (like table()) will treat it the same as if it is a categorical variable.\nHowever, this is not always the case, so it is good to tell R specifically that each variable is a categorical variable.\nThere is a special way that we tell R that a variable is categorical - we set it to be a “factor”. Note what happens when we make the “type” and “strength_cat” variables to be a factor:\n\npwords$type &lt;- factor(pwords$type)\npwords$strength_cat &lt;- factor(pwords$strength_cat)\nsummary(pwords)\n\n      rank         password                          type        cracked      \n Min.   :  1.0   Length:500         name               :183   Min.   : 1.290  \n 1st Qu.:125.8   Class :character   cool-macho         : 79   1st Qu.: 3.430  \n Median :250.5   Mode  :character   simple-alphanumeric: 61   Median : 3.720  \n Mean   :250.5                      fluffy             : 44   Mean   : 5.603  \n 3rd Qu.:375.2                      sport              : 37   3rd Qu.: 3.720  \n Max.   :500.0                      nerdy-pop          : 30   Max.   :92.270  \n                                    (Other)            : 66                   \n    strength      strength_cat\n Min.   : 1.000   medium:402  \n 1st Qu.: 6.000   strong: 25  \n Median : 7.000   weak  : 73  \n Mean   : 6.768               \n 3rd Qu.: 8.000               \n Max.   :10.000               \n                              \n\n\nR now recognises that there a set number of possible response options, or “levels”, for these variables. We can see what they are using:\n\nlevels(pwords$strength_cat)\n\n[1] \"medium\" \"strong\" \"weak\"  \n\n\nThe “strength_cat” variable specifically has an ordering to the levels, so we might be better off also telling R about this ordering. We do this like so:\n\npwords$strength_cat &lt;- factor(pwords$strength_cat, ordered = TRUE, levels = c(\"weak\",\"medium\",\"strong\"))\n\n\nSometimes, we might have a variable that we know is categorical, but we might want to treat it as a set of numbers instead. A very common example in psychological research is Likert data (questions measured on scales such as “Strongly Disagree”&gt;&gt;“Disagree”&gt;&gt;…&gt;&gt;“Strongly Agree”).\nIt is often useful to have these responses as numbers (e.g. 1 = “Strongly Disagree” to 5 = “Strongly Agree”), as this allows us to use certain functions and analyses more easily. For instance, the median() and IQR() functions require the data to be numbers.\nThis will not work:\n\nmedian(pwords$strength_cat)\n\nError in median.default(pwords$strength_cat): need numeric data\n\n\nWhen we ask R to convert a factor to a numeric variable, it will give turn the first category into 1, the second category to 2, and so on. As R knows that our strength_cat variable is the ordered categories “weak”&gt;&gt;“medium”&gt;&gt;“strong”, then as.numeric(pwords$strength_cat) will turn these to 1s, 2s, and 3s.\n\nmedian(as.numeric(pwords$strength_cat))\n\n[1] 2\n\n\n\nConverting between types of data:\nIn R, we can use various functions to convert between different types of data, such as:\n\nfactor() / as.factor() - to turn a variable into a factor\nas.numeric() - to turn a variable into numbers\nas.character() - to turn a variable into letters\n\nand we can check what type of data something is coded as, by using is.factor(), is.numeric(), is.character().\n\n\n\n\n\n\nbe careful with conversions\n\n\n\n\n\nStudy the code below and the output.\nThink carefully about why this happens:\n\nvec &lt;- c(1,2,4,7)\nas.numeric(as.factor(vec))\n\n[1] 1 2 3 4\n\n\nWhy is the output different here?\n\nas.numeric(as.character(as.factor(vec)))\n\n[1] 1 2 4 7"
  },
  {
    "objectID": "02a_measurement.html#numeric",
    "href": "02a_measurement.html#numeric",
    "title": "2A: Measurement & Distributions",
    "section": "Numeric",
    "text": "Numeric\n\nNumeric (or quantitative) variables consist of numbers, and represent a measurable quantity. Operations like adding and averaging make sense only for numeric variables.\n\n\n\n\n\n\n\n\nType\nDescription\nExample\n\n\n\n\nContinuous\nVariables which can take any real number within the specified range of measurement\nHeight: 172, 165.2, 183, …\n\n\nDiscrete\nVariables which can only take integer number values. For instance, a counts can only take positive integer values (0, 1, 2, 3, etc.)\nNumber_of_siblings: 0, 1, 2, 3, 4, …\n\n\n\n\nOne of the most frequently used measures of central tendency for numeric data is the mean. The mean is calculated by summing all of the observations together and then dividing by the total number of obervations (\\(n\\)).\n\nMean: \\(\\bar{x}\\)\nWhen we have sampled some data, we denote the mean of our sample with the symbol \\(\\bar{x}\\) (sometimes referred to as “x bar”). The equation for the mean is:\n\\[\\bar{x} = \\frac{\\sum\\limits_{i = 1}^{n}x_i}{n}\\]\n\n\n\n\n\n\nHelp reading mathematical formulae\n\n\n\n\n\nThis might be the first mathematical formula you have seen in a while, so let’s unpack it.\nThe \\(\\sum\\) symbol is used to denote a series of additions - a “summation”.\nWhen we include the bits around it: \\(\\sum\\limits_{i = 1}^{n}x_i\\) we are indicating that we add together all the terms \\(x_i\\) for values of \\(i\\) between \\(1\\) and \\(n\\): \\[\\sum\\limits_{i = 1}^{n}x_i \\qquad = \\qquad x_1+x_2+x_3+...+x_n\\]\nSo in order to calculate the mean, we do the summation (adding together) of all the values from the \\(1^{st}\\) to the \\(n^{th}\\) (where \\(n\\) is the total number of values), and we divide that by \\(n\\).\n\n\n\n\nIf we are using the mean as our as our measure of central tendency, we can think of the spread of the data in terms of the deviations (distances from each value to the mean).\nRecall that the mean is denoted by \\(\\bar{x}\\). If we use \\(x_i\\) to denote the \\(i^{th}\\) value of \\(x\\), then we can denote deviation for \\(x_i\\) as \\(x_i - \\bar{x}\\).\nThe deviations can be visualised by the red lines in Figure 1.\n\n\n\n\n\nFigure 1: Deviations from the mean\n\n\n\n\n\nThe sum of the deviations from the mean, \\(x_i - \\bar x\\), is always zero\n\\[\n\\sum\\limits_{i = 1}^{n} (x_i - \\bar{x}) = 0\n\\]\nThe mean is like a center of gravity - the sum of the positive deviations (where \\(x_i &gt; \\bar{x}\\)) is equal to the sum of the negative deviations (where \\(x_i &lt; \\bar{x}\\)).\n\nBecause deviations around the mean always sum to zero, in order to express how spread out the data are around the mean, we must we consider squared deviations.\nSquaring the deviations makes them all positive. Observations far away from the mean in either direction will have large, positive squared deviations. The average squared deviation is known as the variance, and denoted by \\(s^2\\)\n\nVariance: \\(s^2\\)\nThe variance is calculated as the average of the squared deviations from the mean.\nWhen we have sampled some data, we denote the mean of our sample with the symbol \\(\\bar{x}\\) (sometimes referred to as “x bar”). The equation for the variance is:\n\\[s^2 = \\frac{\\sum\\limits_{i=1}^{n}(x_i - \\bar{x})^2}{n-1}\\]\n\n\n\n\n\n\noptional: why n minus 1?\n\n\n\n\n\nThe top part of the equation \\(\\sum\\limits_{i=1}^{n}(x_i - \\bar{x})^2\\) can be expressed in \\(n-1\\) terms, so we divide by \\(n-1\\) to get the average.\n Example: If we only have two observations \\(x_1\\) and \\(x_2\\), then we can write out the formula for variance in full quite easily. The top part of the equation would be: \\[\n\\sum\\limits_{i=1}^{2}(x_i - \\bar{x})^2 \\qquad = \\qquad (x_1 - \\bar{x})^2 + (x_2 - \\bar{x})^2\n\\]\nThe mean for only two observations can be expressed as \\(\\bar{x} = \\frac{x_1 + x_2}{2}\\), so we can substitute this in to the formula above. \\[\n(x_1 - \\bar{x})^2 + (x_2 - \\bar{x})^2\n\\] becomes: \\[\n\\left(x_1 - \\frac{x_1 + x_2}{2}\\right)^2 + \\left(x_2 - \\frac{x_1 + x_2}{2}\\right)^2\n\\] Which simplifies down to one value: \\[\n\\left(\\frac{x_1 - x_2}{\\sqrt{2}}\\right)^2\n\\]  So although we have \\(n=2\\) datapoints, \\(x_1\\) and \\(x_2\\), the top part of the equation for the variance has 1 fewer units of information. In order to take the average of these bits of information, we divide by \\(n-1\\).\n\n\n\n\nOne difficulty in interpreting variance as a measure of spread is that it is in units of squared deviations. It reflects the typical squared distance from a value to the mean.\nConveniently, by taking the square root of the variance, we can translate the measure back into the units of our original variable. This is known as the standard deviation.\n\nStandard Deviation: \\(s\\)\nThe standard deviation, denoted by \\(s\\), is a rough estimate of the typical distance from a value to the mean.\nIt is the square root of the variance (the typical squared distance from a value to the mean).\n\\[\ns = \\sqrt{\\frac{\\sum\\limits_{i=1}^{n}(x_i - \\bar{x})^2}{n-1}}\n\\]\n\nIn the passwords dataset, we only have one continuous variable, and that is the “cracked” variable, which if we recall is the “Time to crack by online guessing”. You might be questioning whether the “strength” variable, which ranges from 1 to 10 is numeric? This depends on whether we think that statements like “a password of strength 10 is twice as strong as a password of strength 5”.\nFor now, we’ll just look at the “cracked” variable.\nTo calculate things like means and standard deviations in R is really easy, because there are functions that do them all for us.\nFor instance, we can do the calculation by summing the cracked variable, and dividing by the number of observations (in our case we have 500 passwords):\n\n# get the values in the \"cracked\" variable from the \"pwords\" dataframe, and\n# sum them all together. Then divide this by 500\nsum(pwords$cracked)/500\n\n[1] 5.60266\n\n\nOr, more easily, we can use the mean() function:\n\nmean(pwords$cracked)\n\n[1] 5.60266\n\n\nWe can get R to calculate the variance and standard deviation with the var() and sd() functions:\n\nvar(pwords$cracked)\n\n[1] 71.16618\n\nsd(pwords$cracked)\n\n[1] 8.436005\n\n\nand just to prove to ourselves:\n\nsd(pwords$cracked)^2 == var(pwords$cracked)\n\n[1] TRUE\n\n\n\nIf a column of our dataset contains only numbers, R will typically just interpret it as a numeric variable. However, we should still be careful; remember what happens if we have just one erroneous entry in there - they can all change to be characters (surrounded by quotation marks):\n\nc(1,3,6,\"peppapig\",3)\n\n[1] \"1\"        \"3\"        \"6\"        \"peppapig\" \"3\"       \n\n\nWe can force a variable to be numeric by using as.numeric(), which will also coerce any non-numbers to be NA (not applicable):\n\nas.numeric(c(1,3,6,\"peppapig\",3))\n\n[1]  1  3  6 NA  3\n\n\nIf there is an NA in the variable, many functions like mean(), var() and sd() will not compute:\n\nx &lt;- c(1, 3, 6, NA, 3)\nmean(x)\n\n[1] NA\n\n\nHowever, we can ask these functions to remove the NAs prior to the computation:\n\nmean(x, na.rm = TRUE)\n\n[1] 3.25\n\n\n\n\n\n\n\n\nFigure 2: Artwork by @allison_horst"
  },
  {
    "objectID": "02a_measurement.html#this-is-a-pipe",
    "href": "02a_measurement.html#this-is-a-pipe",
    "title": "2A: Measurement & Distributions",
    "section": "This is a pipe!",
    "text": "This is a pipe!\nWe have seen already seen a few examples of code such as:\n\ndim(somedata)\ntable(somedata$somevariable)\n\n\n\n\nAnd we have seen how we might wrap functions inside functions:\n\nbarplot(table(somedata$somevariable))\n\nThis sort of writing (functions inside functions inside functions) involves R evaluating code from the inside out. But a lot of us don’t intuitively think that way, and actually find it easier to think in terms of a sequence. The code barplot(table(somedata$somevariable)) could be read as “take this variable, then make a table of it, then make a barplot of that table”.\nWe can actually write code that better maps to this way of reading, using a nice little symbol called a “pipe”:\n\nPiping\nWe can write in a different style, however, and this may help to keep code tidy and easily readable - we can write sequentially:\n\nNotice that what we are doing is using a new symbol: |&gt;\nThis symbol takes the output of whatever is on it’s left-hand side, and uses it as an input for whatever is on the right-hand side.\nThe |&gt; symbol gets called a “pipe”.\n\nLet’s see it in action with the passwords dataset we’ve been using.\n\n\ninside-out\nThe typical way of writing code is requires reading from the inside-out:\n\nbarplot(table(pwords$type))\n\n\n\n\n\n\n\n\n\n\npiped\nWhen we pipe code, we can read it from left to right:\n\npwords$type |&gt;\n    table() |&gt;\n    barplot()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOther pipes: |&gt; and %&gt;%\n\n\n\n\n\nThe |&gt; pipe is a relatively recent addition to R, but will likely be replacing the older %&gt;% pipe that was in a specific set of packages, and has been around since about 2014.\nThese two pipes do basically the same thing\nThere are some subtle differences between the two that only become apparent in very specific situations, none of which are likely to arise on this course.\nHowever, it’s important to be aware of them both, because you will like see them both in resources/online forums etc. You can usually just use them interchangeably.\n\n\n# for %&gt;% we need the tidyverse\nlibrary(tidyverse)\n1:10 %&gt;% mean()\n\n\n\n\n# the new base R pipe\n1:10 |&gt; mean()"
  },
  {
    "objectID": "02a_measurement.html#the-tidyverse",
    "href": "02a_measurement.html#the-tidyverse",
    "title": "2A: Measurement & Distributions",
    "section": "The Tidyverse",
    "text": "The Tidyverse\nWe’re going to use pipes a lot throughout this course, and it pairs really well with a group of functions in the tidyverse packages, which were designed to be used in conjunction with a pipe:\n\nselect() extracts columns\n\nfilter() subsets data based on conditions\n\nmutate() adds new variables\n\ngroup_by() group related rows together\n\nsummarise()/summarize() reduces values down to a single summary\n\nTypically, the tidyverse means that we no longer have to keep telling R in which dataframe to look for the variable. The tidyverse functions are designed to make things is a bit easier. The examples below show how.\nYou’ll notice that the code has lots of indentations to make it more readable, which RStudio does for you when you press enter!\nBefore anything else, however, we need to load the tidyverse package:\n\nlibrary(tidyverse)\n\n\nselect()\nWe know about using $ to extract a column from a dataframe. The select() function is a little bit like that - it allows us to choose certain columns in a dataframe. It will return all rows.\nBecause we can select multiple columns this way, it doesn’t return us a vector (in the way dataframe$variable does), but returns a dataframe:\n\n# take the data\n# and select the \"variable1\" and \"variable2\" columns\ndata |&gt;\n  select(variable1, variable2)\n\n\n\nTidyverse\n\npwords |&gt;\n  select(type, strength)\n\n\n\nBase R\n\npwords[, c(\"type\",\"strength\")]\n\n\n\n\n\nfilter()\nThe filter() function is a bit like the [] to choose rows that meet certain conditios - it allows us to filter a dataframe down to those rows which meet a given condition. It will return all columns.\n\n# take the data\n# and filter it to only the rows where the \"variable1\" column is \n# equal to \"value1\". \ndata |&gt; \n  filter(variable1 == value1)\n\n\n\nTidyverse\n\npwords |&gt;\n    filter(strength_cat == \"strong\")\n\n\n\nBase R\n\npwords[pwords$strength_cat == \"strong\", ]\n\n\n\n\n\nmutate()\nThe mutate() function is used to add or modify variables to data.\n\n# take the data\n# |&gt;\n# mutate it, such that there is a variable called \"newvariable\", which\n# has the values of a variable called \"oldvariable\" multiplied by two.\ndata |&gt;\n  mutate(\n    newvariable = oldvariable * 2\n  )\n\nTo ensure that our additions/modifications of variables are stored in R’s environment (rather than simply printed out), we need to reassign the name of our dataframe:\n\ndata &lt;- \n  data |&gt;\n  mutate(\n    ...\n  )\n\nNote: Inside functions like mutate(), we don’t have to keep using the dollar sign $, as we have already told it what data to look for variables in.\n\n\nTidyverse\n\npwords &lt;- pwords |&gt; \n    mutate(\n        cracked_min = cracked / 60\n    )\n\n\n\nBase R\n\npwords$cracked_min &lt;- pwords$cracked / 60\n\n\n\n\n\nsummarise()\nThe summarise() function is used to reduce variables down to a single summary value.\n\n# take the data |&gt;\n# summarise() it, such that there is a value called \"summary_value\", which\n# is the sum() of \"variable1\" column, and a value called \n# \"summary_value2\" which is the mean() of the \"variable2\" column.\ndata |&gt;\n  summarise(\n    summary_value = sum(variable1),\n    summary_value2 = mean(variable2)\n  )\n\n\n\nTidyverse\n\npwords |&gt; \n    summarise(\n        mean_cracked = mean(cracked),\n        sd_cracked = sd(cracked),\n        nr_strong = sum(strength_cat == \"strong\")\n    )\n\n\n\nBase R\nTo store these all in the same object (like the tidyverse way) we would have to create a data.frame() and add these as variables.\n\nmean(pwords$cracked)\nsd(pwords$cracked)\nsum(pwords$strength_cat == \"strong\")\n\n\n\n\n\ngroup_by()\nThe group_by() function is often used as an intermediate step in order to do something. For instance, if we want to summarise a variable by calculating its mean, but we want to do that for several groups, then we first group_by() and then summarise():\n\n# take the data |&gt; \n# and, grouped by the levels of the \"mygroups\" variable,\n# summarise() it so that there is a column called \"summary_col\", which\n# is the mean of the \"variable1\" column for each group. \ndata |&gt;\n    group_by(mygroups) |&gt;\n    summarise(\n        summary_col = mean(variable1)\n    )\n\n\n\nTidyverse\n\npwords |&gt; \n    group_by(strength_cat) |&gt;\n    summarise(\n        mean_cracked = mean(cracked)\n    )\n\n\n\nBase R\nThis is less easy. There are functions in Base R that can do similar things, but we’re not going to teach those here. You could envisage getting all the same values by doing:\n\nmean(pwords$cracked[pwords$strength_cat == \"weak\"])\nmean(pwords$cracked[pwords$strength_cat == \"medium\"])\nmean(pwords$cracked[pwords$strength_cat == \"strong\"])"
  },
  {
    "objectID": "02a_measurement.html#boxplots",
    "href": "02a_measurement.html#boxplots",
    "title": "2A: Measurement & Distributions",
    "section": "Boxplots",
    "text": "Boxplots\nBoxplots provide a useful way of visualising the interquartile range (IQR). You can see what each part of the boxplot represents in Figure Figure 4.\n\n\n\n\n\nFigure 4: Anatomy of a boxplot\n\n\n\n\nWe can create a boxplot of our age variable using the following code:\n\n# Notice, we put strength on the x axis, making the box plot vertical. \n# If we had set aes(y = strength) instead, then it would simply be rotated 90 degrees \nggplot(data = pwords, aes(x = strength)) +\n  geom_boxplot()"
  },
  {
    "objectID": "02a_measurement.html#histograms",
    "href": "02a_measurement.html#histograms",
    "title": "2A: Measurement & Distributions",
    "section": "Histograms",
    "text": "Histograms\nNow that we have learned about the different measures of central tendency and of spread, we can look at how these map to how visualisations of numeric variables look.\nWe can visualise numeric data using a histogram, which shows the frequency of values which fall within bins of an equal width.\nTo do this, we’re going to use some new data, on 120 participants’ IQ scores (measured on the Wechsler Adult Intelligence Scale (WAIS)), their ages, and their scores on 2 other tests. The data are available at https://uoepsy.github.io/data/wechsler.csv\n\nwechsler &lt;- read_csv(\"https://uoepsy.github.io/data/wechsler.csv\")\n\n\n# make a ggplot with the \"wechsler\" data. \n# on the x axis put the possible values in the \"iq\" variable,\n# add a histogram geom (will add bars representing the count \n# in each bin of the variable on the x-axis)\nggplot(data = wechsler, aes(x = iq)) + \n  geom_histogram()\n\n\n\n\n\n\n\n\nWe can specifiy the width of the bins:\n\nggplot(data = wechsler, aes(x = iq)) + \n  geom_histogram(binwidth = 5)\n\n\n\n\n\n\n\n\nLet’s take a look at the means and standard deviations of participants’ scores on the other tests (the test1 and test2 variables).\nNote how nicely we can do this with our newfound tidyverse skills!\n\nwechsler |&gt; \n  summarise(\n    mean_test1 = mean(test1),\n    sd_test1 = sd(test1),\n    mean_test2 = mean(test2),\n    sd_test2 = sd(test2)\n  )\n\n# A tibble: 1 × 4\n  mean_test1 sd_test1 mean_test2 sd_test2\n       &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n1       49.3     7.15       51.2     14.4\n\n\nTests 1 and 2 have similar means (around 50), but the standard deviation of Test 2 is almost double that of Test 1. We can see this distinction in the visualisation below - the histograms are centered at around the same point (50), but the one for Test 2 is a lot wider than that for Test 1.\n\n\n\n\n\n\n\n\n\n\nDefining moments\nThe “moments” of a distribution are the metrics that relate to the shape of that distribution. We’ve already seen the primary two moments that define the shapes of these distributions: the mean and the variance. The mean moves the distribution right or left, and the variance makes the distribution wider or narrower.\nThere are two more, “skewness” and “kurtosis” which tend to be of less focus of investigation (the questions we ask tend to be mainly concerned with means and variances). Skewness is a measure of asymmetry in a distribution. Distributions can be positively skewed or negatively skewed, and this influences our measures of central tendency and of spread to different degrees. The kurtosis is a measure of how “pointy” vs “rounded” the shape of a distribution is."
  },
  {
    "objectID": "02a_measurement.html#density",
    "href": "02a_measurement.html#density",
    "title": "2A: Measurement & Distributions",
    "section": "Density",
    "text": "Density\nIn addition to grouping numeric data into bins in order to produce a histogram, we can also visualise a density curve.\nBecause there are infinitely many values that numeric variables could take (e.g., 50, 50.1, 50.01, 5.001, …), we could group the data into infinitely many bins. This is essentially what we are doing with a density curve.\nYou can think of “density” as a bit similar to the notion of “relative frequency” (or “proportion”), in that for a density curve, the values on the y-axis are scaled so that the total area under the curve is equal to 1. In creating a curve for which the total area underneath is equal to one, we can use the area under the curve in a range of values to indicate the proportion of values in that range.\n\nggplot(data = wechsler, aes(x = iq)) + \n  geom_density()\n\n\n\n\n\n\n\n\n\nArea under the curve\nThink about the barplots we have been looking at in the exercises where we simulate dice rolling :\n\n# our function to simulate the roll of a die/some dice\ndice &lt;- function(num = 1) {\n  sum(sample(1:6, num, replace=TRUE))\n}\n# simulate 1000 rolls of a single die\nroll1000 &lt;- replicate(1000, dice(1))\n# tabulate and plot:\ntable(roll1000) |&gt;\n  barplot(ylab=\"count\")\n\n\n\n\n\n\n\n\nTo think about questions like “what proportion of 1000 rolls does the die land on 6?”, we are simply interested in the count of 6s divided by the count of all rolls:\n\ntab1000 &lt;- table(roll1000)\ntab1000\n\nroll1000\n  1   2   3   4   5   6 \n162 169 167 189 152 161 \n\ntab1000[6] / sum(tab1000)\n\n    6 \n0.161 \n\n\nSo Another way of thinking of this is that we are just dividing the count in each category by the total number. Or, Put another way, imagine we divide the area of each bar by the total area. The area now sums to 1, and our question is asking about the ratio of the red area to the total area (grey + red):\n\n\n\n\n\n\n\n\n\nNothing really changes with a density curve! If we want to ask what proportion of our distribution of IQ scores is &gt;120, then we are asking about the area under the curve that is to the right of 120:\n\n\n\n\n\n\n\n\n\nIt looks like about a third, maybe a little less. Let’s calculate this proportion directly:\n\nsum(wechsler$iq&gt;110) / length(wechsler$iq)\n\n[1] 0.2\n\n\nIt might seem a little odd to think about area under the curve when we are asking about “what proportion of the data is …?”. If we have the data, then we can just calculate the answer (like we did above). However, a lot of statistics is really concerned with the probability of events. When we discuss probability, we move from talking about a specific set of observed data to thinking about a theoretical/mathematical model that defines the way in which data is generated. This where it becomes more useful to think about distributions in a more abstract sense.\nFor instance, with a fair six-sided die, we have a probability distribution (Figure 5) in which each side is given the probability \\(\\frac{1}{6}\\): \\[\n\\begin{gather*}\nP(x) = \\begin{cases}\n  \\frac{1}{6} & \\text{if $x \\in \\{1,2,3,4,5,6\\}$}\\\\\n  0 & \\text{otherwise.}\n  \\end{cases}\n\\end{gather*}\n\\] Instead of rolling a die, suppose that we are picking a person off the street and measuring their IQ. Given that IQ scales are designed to have a mean of 100 and standard deviation of 15, what is the probability that we pick a person with an IQ of greater than 110?\n\n\n\n\n\nFigure 5: Left: Discrete probability distribution of a fair six-sided die. Right: Continuous probability distribution of IQ scores"
  },
  {
    "objectID": "02a_measurement.html#footnotes",
    "href": "02a_measurement.html#footnotes",
    "title": "2A: Measurement & Distributions",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nthink about what sum(table(pwords$type)) is doing. it’s counting all the values in the table. so it’s going to give us the total↩︎"
  },
  {
    "objectID": "02b_sampling.html",
    "href": "02b_sampling.html",
    "title": "2B: Curves & Sampling",
    "section": "",
    "text": "This reading:\n\nWhat are probability distributions and why are they relevant?\n\nHow does using a sample to approximate a population lead to uncertainty?\nHow can we quantify uncertainty due to sampling?"
  },
  {
    "objectID": "02b_sampling.html#the-standard-normal-distribution",
    "href": "02b_sampling.html#the-standard-normal-distribution",
    "title": "2B: Curves & Sampling",
    "section": "The Standard Normal Distribution",
    "text": "The Standard Normal Distribution\nNote that if we translate our “IQ &gt;120” to being in terms of standard deviations - \\(\\frac{120 - 100}{15} = 1\\frac{1}{3}\\) - then we can perform the same computations as we have done above, but comparing against against a normal distribution with mean of 0 and standard deviation of 1 (which are the defaults for the pnorm() function):\n\npnorm((120-100)/15, lower.tail = FALSE)\n\n[1] 0.09121122\n\n\n\n\n\n\n\nFigure 7: pnorm() with the ‘standard normal distribution’: the normal distribution with mean = 0 and sd = 1\n\n\n\n\nWhat we’re doing here is re-expressing the observed distribution into one which has mean of 0 and standard deviation of 1 - we are standardising them. This idea will become incredibly useful. For one thing it makes comparisons possible, for example, consider the two statements below:\n\n“I am 15 IQ points higher than average, and 24cm taller than average”\n“I am 1 standard deviation above the average IQ, and 2 standard deviations above average height”\n\nThe standard normal distribution - the normal distribution with mean = 0, sd = 1, is going to be seen a lot more frequently."
  },
  {
    "objectID": "02b_sampling.html#the-relevance-of-the-normal-distribution",
    "href": "02b_sampling.html#the-relevance-of-the-normal-distribution",
    "title": "2B: Curves & Sampling",
    "section": "The relevance of the normal distribution?",
    "text": "The relevance of the normal distribution?\nWe can motivate the relevance of the normal distribution in various ways. For instance, when we take a measurement of something such as the length of a stick, then we always have a bit of imprecision - our measurements will vary a bit. Assuming that our measurement tool is unbiased and this imprecision is purely random, we would expect the measurements of the stick to be ‘normally distributed’ around the true length of the stick (Figure 8).\n\n\n\n\n\nFigure 8: Snapshots from 21/22 lecture slides on measurement\n\n\n\n\nIn this way, the normal distribution captures the idea of random deviations around a central point. As we will see below, this becomes extremely relevant for statistics because we tend to collect data on a random sample of people, and all of the samples we could have taken will randomly deviate a bit in how well they represents the bigger group that we take them from."
  },
  {
    "objectID": "02b_sampling.html#footnotes",
    "href": "02b_sampling.html#footnotes",
    "title": "2B: Curves & Sampling",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nremember that standard deviation is \\(\\sqrt{\\text{variance}}\\)↩︎\nOften in neuropsychological testing, a set of “normative values” are provided in order to define “what is expected” (sometimes in reference to a specific population).↩︎\nand the statements may not hold for all individuals - for certain people, some drugs just won’t work! but what is important for a healthcare system deciding on whether or not to purchase supplies of a drug is the average treatment effect.↩︎\nIf you’re working along with this, yours will be different, because it’s random!↩︎\nImagine a bag full of coloured marbles. If we sample with replacement, then we take a marble out, record its colour, and put it back. Then we take a marble out, record its colour, and put it back. And so on. This means we might get the same marble more than once.↩︎\nusing the formula \\(\\frac{\\sigma}{\\sqrt{n}}\\) for standard error↩︎"
  },
  {
    "objectID": "03_ex.html",
    "href": "03_ex.html",
    "title": "Exercises: T-tests",
    "section": "",
    "text": "Question 1\n\n\nAt the end of last week’s exercises, we estimated the mean sleep-quality rating, and computed a confidence interval, using the formula below.\n\\[\n\\begin{align}\n\\text{95\\% CI: }& \\bar x \\pm 1.96 \\times SE \\\\\n\\end{align}\n\\]\nCan you use R to show where the 1.96 comes from?\n\n\n\n\n\n\nHints\n\n\n\n\n\nqnorm! (see the end of 03A #uncertainty-due-to-sampling)\n\n\n\n\n\n\n\n\nSolution\n\n\n\nThe 1.96 comes from 95% of the normal distribution falling within 1.96 standard deviations of the mean:\n\nqnorm(c(0.025, 0.975))\n\n[1] -1.959964  1.959964\n\n\n\n\n\n\nQuestion 2\n\n\nAs we learned in 3B #t-distributions, the sampling distribution of a statistic has heavier tails the smaller the size of the sample it is derived from. In practice, we are better using \\(t\\)-distributions to construct confidence intervals and perform statistical tests.\nThe code below creates a dataframe that contains the number of books read by 7 people in 2023.\n(Note tibble is just a tidyverse version of data.frame):\n\nbookdata &lt;- \n  tibble(\n    person = c(\"Martin\",\"Umberto\",\"Monica\",\"Emma\",\"Josiah\",\"Dan\",\"Aja\"),\n    books_read = c(12,19,9,11,8,28,13)\n  )\n\nCalculate the mean number of books read in 2023, and construct an appropriate 95% confidence interval.\n\n\n\n\n\nSolution\n\n\n\nHere is our estimated average number of books read:\n\nmean(bookdata$books_read)\n\n[1] 14.28571\n\n\nAnd our standard error is still \\(\\frac{s}{\\sqrt{n}}\\):\n\nsd(bookdata$books_read)/sqrt(nrow(bookdata))\n\n[1] 2.652171\n\n\nWith \\(n = 7\\) observations, and estimating 1 mean, we are left with \\(6\\) degrees of freedom.\nFor our 95% confidence interval, the \\(t^*\\) in the formula below is obtained via:1\n\nqt(0.975, df = 6)\n\n[1] 2.446912\n\n\nOur confidence interval is therefore:\n\\[\n\\begin{align}\n\\text{CI} &= \\bar{x} \\pm t^* \\times SE \\\\\n\\text{95\\% CI} &= 14.286 \\pm 2.447 \\times 2.652 \\\\\n\\text{95\\% CI} &= [7.80,\\, 20.78] \\\\\n\\end{align}\n\\]\n\n\n\n\nQuestion 3\n\n\nWill a 90% confidence interval be wider or narrow?\nCalculate it and see.\n\n\n\n\n\nSolution\n\n\n\nA 90% confidence interval will be narrower:\n\nqt(0.95, df = 6)\n\n[1] 1.94318\n\n\n\\[\n\\begin{align}\n\\text{CI} &= \\bar{x} \\pm t^* \\times SE \\\\\n\\text{90\\% CI} &= 14.286 \\pm 1.943 \\times 2.652 \\\\\n\\text{90\\% CI} &= [9.13,\\, 19.44] \\\\\n\\end{align}\n\\]\nThe intuition behind this is that our level of confidence is inversely related to the width of the interval.\nTake it to the extremes:\n\nI have 100% confidence that the interval \\([-Infinity, +Infinity]\\) contains the true population mean.\nIf I want an narrower interval, then I have to sacrifice confidence. e.g. a 10% CI: \\([13.94, 14.63]\\)\n\nImagine playing a game of ringtoss. A person throwing a 2-meter diameter hoop will have much more confidence that they are going to get it over the pole than a person throwing a 10cm diameter ring."
  },
  {
    "objectID": "03_ex.html#footnotes",
    "href": "03_ex.html#footnotes",
    "title": "Exercises: T-tests",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n(Why 97.5? and not 95? We want the middle 95%, and \\(t\\)-distributions are symmetric, so we want to split that 5% in half, so that 2.5% is on either side. We could have also used qt(0.025, df = 6), which will just give us the same number but negative: -2.4469119)↩︎"
  },
  {
    "objectID": "03a_inference.html",
    "href": "03a_inference.html",
    "title": "3A: Foundations of Inference",
    "section": "",
    "text": "This reading:\n\nHow do we quantify uncertainty due to sampling?\n\nHow can we make decisions (what to believe/how to act, etc) that take uncertainty into account?\n\nHow likely are we to make the wrong decision?\nWe use statistics primarily to estimate parameters in a population. Whether we are polling people to make predictions about the proportion of people who will vote for a certain party in the next election, or conducting a medical trial and assessing the change in blood pressure for patients given drug X vs those given a placebo in order to decide whether to put the drug into circulation in health service.\nWe have seen this already last week: We observed a sample of peoples’ life satisfaction ratings (scale 0-100), and we wanted to use these to make some statement about the wider population, such as “the average life-satisfaction rating is ?? out of 100”. So we use the mean of our sample, as an estimate of the mean of the population."
  },
  {
    "objectID": "03a_inference.html#test-statistics-p-values",
    "href": "03a_inference.html#test-statistics-p-values",
    "title": "3A: Foundations of Inference",
    "section": "Test-statistics & p-values",
    "text": "Test-statistics & p-values\nThe p-value is a formal way of testing a statistic against a null hypothesis. To introduce the p-value, instead of thinking first about what we have observed in our sample, we need to think about what we would expect to observe if our null hypothesis is true.\nWith our Stroop Task example, our null hypothesis is that there is no difference between matching and mismatching conditions (\\(H_0: \\mu = 0\\)). Under \\(H_0\\), the average ‘mismatching-matching’ score in the population is zero, and we would expect most of the samples we might take to have a mean score of close to this (not exactly 0, but centered around 0). We saw above that we could express the sampling distribution of means taken from samples of size \\(n=131\\) using the standard error. Under \\(H_0\\) we would expect the samples of \\(n=131\\) we might take to have means that follow something like the distribution in Figure 3. We can think of this as the sampling distribution of \\(\\bar{x}\\), but centered on our null hypothesis (in this case, \\(\\mu = 0\\)). We call this the ‘null distribution’.\n\n\n\n\n\nFigure 3: Sampling distribution for mean of sample size 131, assuming population mean = 0. Observed sample mean shown in red\n\n\n\n\n\nTest-statistic\nThe first step now is to create a test-statistic. That is, a statistic that tell us, in some standardised units, how big our observed effect is from the null hypothesis (i.e. in this case, how far from \\(\\mu=0\\) our sample mean is).\nThe straightforward way to do this is to express how far away from \\(\\mu=0\\) our sample mean is in terms of standard errors. We’ll call our test statistic \\(Z\\):\n\\[\nZ = \\frac{\\text{estimate}-\\text{null}}{SE}\n\\]\nOur mean and standard error are:\n\nmean(stroopdata$diff)\n\n[1] 2.402977\n\nsd(stroopdata$diff) / sqrt(nrow(stroopdata))\n\n[1] 0.4382302\n\n\nSo our test-statistic is \\[\nZ = \\frac{2.40 - 0}{0.438} = 5.479\n\\]\n\n\np-value\nWe can now calculate how likely it is to see values at least as extreme as our observed test-statistic, if the null is true.\nIf the null hypothesis is true (there was no ‘mismatching-matching’ difference) then we would expect Z-statistics to be normally distributed with a mean of 0 and a standard deviation of 1.\nWe have seen the process of how we might calculate a probability from a distribution like this already: the pnorm() function gives us the area of a distribution to the one side of a given value:\n\npnorm(??, mean = 0, sd = 1, lower.tail = FALSE)\n\n\n\n\n\n\nFigure 4: pnorm() provides us with a p-value for a z-statistic\n\n\n\n\nRemember, our Z-statistic we calculated above is 5.479. If the null hypothesis were true then the probability that we would see a sample (\\(n=131\\)) with a Z-statistic at least that large is:\n\npnorm(5.479, lower.tail = FALSE)\n\n[1] 2.138682e-08\n\n\nwhich is R’s way of printing 0.00000002138682.\nThere is one last thing, and that the direction of our hypotheses. Recall from earlier that we stated \\(H_0: \\mu = 0\\) and \\(H_1: \\mu \\neq 0\\). This means that we are interested in the probability of getting results this far away from 0 in either direction.\nWe are interested in both tails:\n\n\n\n\n\nFigure 5: 2*pnorm gives the two tails\n\n\n\n\n\n2 * pnorm(5.479, lower.tail = FALSE)\n\n[1] 4.277364e-08\n\n\nor \\(p =\\) 0.00000004277364.\n\np-value\nThe p-value is the probability4 that we observe a test statistic at least as extreme as the one we observed, assuming the null hypothesis \\(H_0\\) to be true."
  },
  {
    "objectID": "03a_inference.html#making-decisions",
    "href": "03a_inference.html#making-decisions",
    "title": "3A: Foundations of Inference",
    "section": "Making Decisions",
    "text": "Making Decisions\nNow that we have our p-value of 0.00000004277364, we need to use it to make a decision about our hypotheses.\nTypically, we pre-specify the probability level at which we will consider results to be so unlikely to have arisen from the null distribution that we will take them as evidence to reject the null hypothesis. This pre-specified level is commonly referred to as \\(\\alpha\\) (“alpha”). Setting \\(\\alpha = 0.05\\) means that we will reject \\(H_0\\) when we get a result which is extreme enough to only occur 0.05 (5%) of the time or less if the \\(H_0\\) is true.\nIn our case, 0.00000004277364 \\(&lt; 0.05\\), so we reject the null hypothesis that there is no difference in the mismatching/matching conditions of the Stroop Task.\n\nThere’s a lot of convention to how we talk about NHST, but the typical process is as follows:\n\nClearly specify the null and alternative hypotheses.\n\nSpecify \\(\\alpha\\)\nCalculate statistic\nCompute p-value\n\nIf \\(p&lt;\\alpha\\), then reject the null hypothesis.\nIf \\(p\\geq\\alpha\\), then fail to reject* the null hypothesis.\n\n\n*Note, we don’t “accept” anything, we just “reject” or “fail to reject” the null hypothesis. Think of it like a criminal court, and we are trying the null hypothesis - \\(H_0\\) is “innocent until proven guilty”."
  },
  {
    "objectID": "03a_inference.html#making-mistakes",
    "href": "03a_inference.html#making-mistakes",
    "title": "3A: Foundations of Inference",
    "section": "Making Mistakes",
    "text": "Making Mistakes\nWhether our eventual decision is a) reject the null hypothesis, or b) fail to reject the null hypothesis, there’s always a chance that we might be making a mistake. There are actually two different types of mistakes we might make. An often used analogy (Figure 6) is the idea of criminal trials in which an innocent person can be wrongfully convicted, or a guilty person can be set free.\n\n\n\n\n\nFigure 6: Making errors in NHST is like a criminal court making errors in its decision on the defendent\n\n\n\n\nWe can actually quantify the chance that we’re making errors in our different decisions. Thinking back to the definition of a p-value, it is the probability of seeing our results if the null hypothesis is true. If we make a decision to reject the null hypothesis based on whether \\(p&lt;\\alpha\\), then the probability that this decision is a mistake is \\(\\alpha\\).\nThe probability that we the other sort of error (failing to reject the null hypothesis when the null hypothesis is actually false), we denote with \\(\\beta\\).\nDoing statistics is partly a matter of balancing these possibilities. If we used a very low \\(\\alpha\\)-level (e.g. we reject when \\(p&lt;.0001\\) rather than \\(p&lt;.05\\)) then we increase the probability of making a type II error.\n\nTypes of Errors in NHST\n\n\n\n\n\nFigure 7: Probabilities of making different errors in NHST\n\n\n\n\n\n\nPower (\\(1-\\beta\\))\nA key notion in conducting studies is “statistical power”. Studies want to increase the probability of correctly rejecting the null hypothesis (i.e. correctly identifying that there is something more than chance going on).\nThis is the bottom right cell of the tables in Figure 6 and Figure 7. We know that this will depend on the \\(\\alpha\\)-level that we choose, but there are other important factors that influence \\(1-\\beta\\):\n\npower increases as sample size increases\n\ne.g. it’s easier to determine that cats weigh less than dogs if we measure 100 animals vs if we measure only 10 animals\n\npower increases the farther away the true value is from the null hypothesis value\n\ne.g. it’s easier to determine that cats weigh less than elephants than it is to determine that cats weigh less than dogs"
  },
  {
    "objectID": "03a_inference.html#footnotes",
    "href": "03a_inference.html#footnotes",
    "title": "3A: Foundations of Inference",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nYou can try out the experiment at https://faculty.washington.edu/chudler/java/ready.html↩︎\n For other intervals, such as a 90% interval, we need to know the point at which 5% is either side of a normal distribution (i.e., giving us the middle 90%). qnorm(c(0.05,0.95)) will give us 1.64, which we then put into our construction of the interval: \\(90\\%\\, CI = \\bar{x} \\pm 1.64 \\times SE\\).↩︎\nThink about an example where our question is about whether there is a difference in variable \\(Y\\) between groups A, B, C and D. Around what should we construct our interval? Around the difference \\(\\bar{Y}_A - \\bar{Y}_B\\) (difference between A and B’s average scores on \\(Y\\)), or \\(\\bar{Y}_A - \\bar{Y}_C\\), or \\(\\bar{Y}_B - \\bar{Y}_D\\)?↩︎\nWhat we have been seeing is that probabilities in NHST are defined as the relative frequency of an event over many trials (as “many” \\(\\to \\infty\\)). This requires assuming some features of the data generating process which guides what the “many trials” would look like (e.g., that there is no effect). The \\(p\\)-value is the probability of observing results as or more extreme than the data, if the data were really generated by a hypothesised chance process.↩︎"
  },
  {
    "objectID": "03b_inference2.html",
    "href": "03b_inference2.html",
    "title": "3B: Practical Inference",
    "section": "",
    "text": "This reading:\n\nHow does hypothesis testing work in practice?\n\nHow do we do all this in R?\n\nspoiler: it’s easier than you think\n\nWhat are some basic hypothesis tests that we can conduct?\n\nTests of a single continuous variable\nTests of the relationship between a continuous variable and a binary categorical variable\nIn 3A we learned about the logic of Null Hypothesis Significance Testing (NHST), allowing us to draw perform inferentials tests about parameters in the population, based on statistics computed on the sample that we have collected.\nWhile in practice NHST follows the logic described above, there is something important that we have been sweeping under the carpet.\nIn our estimation of the standard error we have used the formula that includes \\(\\sigma\\), which refers to the population standard deviation. However, we never know this value (because we don’t have data for the population), so we have been using the sample standard deviation \\(s\\) instead. This is an approximation, and might be okay when we have a very large \\(n\\) (meaning \\(s\\) provides an accurate estimate of \\(\\sigma\\)), but in practice this is not always feasible. \\[\nSE = \\frac{\\sigma}{\\sqrt{n}} \\approx \\frac{s}{\\sqrt{n}}\n\\]"
  },
  {
    "objectID": "03b_inference2.html#one-sample-t-test",
    "href": "03b_inference2.html#one-sample-t-test",
    "title": "3B: Practical Inference",
    "section": "One sample t-test",
    "text": "One sample t-test\n\nPurpose\nThe one sample t-test is what we have already seen above. We use it to test whether the mean is different from/greater than/less than some hypothesised value.\n\nExamples:\n\nIs the mean age of USMR students different from 20?\nIs the mean IQ different from 100?\n\nDo people read more than 250 words per minute?\n\n\nAssumptions:\n\nThe data are continuous (not discrete)\nThe data are independent (i.e. the value of a datapoint does not depend on the value of another datapoint in any way)\nThe data are normally distributed (can be relaxed somewhat if the sample size is “large enough” (rule-of-thumb n = 30) and the data are not strongly skewed)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResearch Question & Data\n\n\n\n\n\n\nResearch Question: Do people read more than 250 words per minute?\n\nFifty participants were recruited and tasked with reading a passage of text that was 2000 words long. Their reading times (in words per minute) was recorded, and these are accessible at https://uoepsy.github.io/data/usmr_tread.csv.\n\nwpmtime &lt;- read_csv(\"https://uoepsy.github.io/data/usmr_tread.csv\")\nhead(wpmtime)\n\n# A tibble: 6 × 2\n  id      wpm\n  &lt;chr&gt; &lt;dbl&gt;\n1 ppt_1   307\n2 ppt_2   265\n3 ppt_3   205\n4 ppt_4   300\n5 ppt_5   207\n6 ppt_6   300\n\n\n\n\n\n\n\n\n\n\n\nDescriptives and Assumptions\n\n\n\n\n\nBelow are some quick descriptives.\n\nmean(wpmtime$wpm)\n\n[1] 258.36\n\nsd(wpmtime$wpm)\n\n[1] 32.08646\n\nhist(wpmtime$wpm)\n\n\n\n\n\n\n\n\nOur histogram looks roughly normally distributed. We can (if we like), test this using the Shapiro-Wilk test.\n\nshapiro.test(wpmtime$wpm)\n\n\n    Shapiro-Wilk normality test\n\ndata:  wpmtime$wpm\nW = 0.9636, p-value = 0.1258\n\n\nThe \\(p\\)-value of 0.126 is \\(&gt;.05\\), so we fail to reject the null hypothesis that the data come from a normal distribution. In other words, we have no reason to consider our assumption to be violated.\n\n\n\n\n\n\n\n\n\nQuick and easy t.test()\n\n\n\n\n\nPaying careful attention to the research question (“Do people read more than 250 words per minute?”), our null hypothesis here is that reading time is \\(\\leq 250\\) words per minute (wpm), and our alternative hypothesis is that it is \\(&gt;250\\) wpm.\nThis means that we will reject our null hypothesis if we get a test statistic indicating the mean is \\(&gt;250\\). We won’t reject it if the mean is \\(&lt;250\\).\nWe specify the direction of the alternative in the t.test() function:\n\nt.test(wpmtime$wpm, mu = 250, alternative = \"greater\")\n\n\n    One Sample t-test\n\ndata:  wpmtime$wpm\nt = 1.8423, df = 49, p-value = 0.03574\nalternative hypothesis: true mean is greater than 250\n95 percent confidence interval:\n 250.7523      Inf\nsample estimates:\nmean of x \n   258.36 \n\n\n\n\n\n\n\n\n\n\n\nStep-by-step calculations\n\n\n\n\n\nOur test-statistic is calculated as \\[\nt =  \\frac{\\bar x - \\mu_0}{\\frac{s}{\\sqrt{n}}}\n\\]\nThere’s a lot of brackets in the code below, so go through it piece by piece if you are unsure of how it matches to the formula above\n\n(mean(wpmtime$wpm) - 250 ) / (sd(wpmtime$wpm) / sqrt(nrow(wpmtime)))\n\n[1] 1.842338\n\n\nThe test we are performing is against the null hypothesis that \\(\\mu_0 \\leq 250\\). So we will only reject the null hypothesis if we get a test statistic indicating the mean is \\(&gt;250\\). This means that our p-value will be just the one tail of the \\(t\\)-distribution:\n\npt(1.842338, df = 49, lower.tail = FALSE)\n\n[1] 0.0357404\n\n\n\n\n\n\n\n\n\n\n\nWrite-up\n\n\n\n\n\n\nA one-sample t-test was conducted in order to determine if the average reading time was significantly (\\(\\alpha=.05\\)) higher than 250 words per minute (wpm).\nThe sample of 50 participants read on average at 258 words per minute (Mean=258, SD=32). This was significantly above 250 (\\(t(49)=1.84, p = .036\\), one-tailed)."
  },
  {
    "objectID": "03b_inference2.html#two-sample-t-test",
    "href": "03b_inference2.html#two-sample-t-test",
    "title": "3B: Practical Inference",
    "section": "Two sample t-test",
    "text": "Two sample t-test\n\nPurpose\nThe two sample t-test is used to test whether the mean of one group is different from/greater than/less than the mean of another.\n\nExamples:\n\nIs the mean age of cat people different from the mean age of dog people?\nDo people who identify as “morning people” have a higher average rating of sleep quality than those who identify as “evening people”?\nIs the average reaction time different between people who do and don’t drink caffeinated drinks?\n\n\nAssumptions:\n\nThe data are continuous (not discrete)\nThe data are independent (i.e. the value of a datapoint does not depend on the value of another datapoint in any way)\nThe data are normally distributed for each group (can be relaxed somewhat if the sample size is “large enough” (rule-of-thumb n = 30) and the data are not strongly skewed)\nThe variance is equal across groups*.\n\n*We can relax this assumption by using an adjusted test called the “Welch \\(t\\)-test”, which calculates the standard error slightly differently, and estimates the degrees of freedom differently too. This is actually the default in R, and we change this easily in R using t.test(...., var.equal = FALSE/TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResearch Question & Data\n\n\n\n\n\n\nResearch Question: Is the average reaction time different between people who do and don’t drink caffeinated drinks?\n\nOne hundred participants were recruited and completed a simple reaction time task. They were also surveyed on whether they regularly drank caffeine in any form. The data are accessible at https://uoepsy.github.io/data/usmr_tcaff.csv.\n\ntcaff &lt;- read_csv(\"https://uoepsy.github.io/data/usmr_tcaff.csv\")\nhead(tcaff)\n\n# A tibble: 6 × 2\n     rt caff \n  &lt;dbl&gt; &lt;chr&gt;\n1  482. yes  \n2  389. yes  \n3  484. no   \n4  601. no   \n5  409. yes  \n6  368. no   \n\n\n\n\n\n\n\n\n\n\n\nDescriptives and Assumptions\n\n\n\n\n\nFirst some quick descriptive stats. We’ll calculate the mean and standard deviation of reaction times for each group:\n\ntcaff |&gt; \n  group_by(caff) |&gt;\n  summarise(\n    m = mean(rt),\n    s = sd(rt)\n  )\n\n# A tibble: 2 × 3\n  caff      m     s\n  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 no     408.  88.9\n2 yes    465. 109. \n\n\nAnd we can make a plot here:\n\nggplot(tcaff, aes(x = rt)) +\n  geom_histogram() + \n  facet_wrap(~caff)\n\n\n\n\n\n\n\n\nThe data look fairly close to normally distributed for each group here. One thing to note is that the variances look like they may be different between the two groups. The caffeine drinkers’ reaction time’s have a standard deviation of 109ms, and the non-caffeine drinkers have an sd of only 89ms.\nAs before, we can (if we are so inclined) rely on specific tests of these assumptions, such as using shapiro.test() for the distribution in each group separately.\nSimilarly, the var.test() function performs a test to compare two variances (the null hypothesis of this test being that they are equal). However, it is more common to simply perform the Welch test straight away, and thus not have to worry about this assumption.\n\n\n\n\n\n\n\n\n\nQuick and easy t.test()\n\n\n\n\n\nWe can give R the two sets of data in two ways. Either by extracting the relevant entries:\n\nt.test(x = tcaff$rt[tcaff$caff==\"no\"], \n       y = tcaff$rt[tcaff$caff==\"yes\"])\n\nOr using the formula notation, with the ~ (“tilde”) symbol. In R, you can interpret y ~ x as “y is modeled as a function of x”. By splitting the numeric values (rt variable) by the categories of the caff variable, we can conduct a \\(t\\)-test using:\n\nt.test(rt ~ caff, data = tcaff)\n\n\n    Welch Two Sample t-test\n\ndata:  rt by caff\nt = -2.8497, df = 93.971, p-value = 0.005377\nalternative hypothesis: true difference in means between group no and group yes is not equal to 0\n95 percent confidence interval:\n -96.20205 -17.19423\nsample estimates:\n mean in group no mean in group yes \n         408.0505          464.7486 \n\n\nNote that the default behaviour of t.test() is to perform the Welch test - so we don’t have to assume equal variances. If we want to override this, we can use t.test(rt ~ caff, data = tcaff, var.equal = TRUE).\n\n\n\n\n\n\n\n\n\nStep-by-step calculations\n\n\n\n\n\nOur test statistic here is:4\n\\[\n\\begin{align}\n& t =  \\frac{\\bar x_1 - \\bar x_2}{SE}\\\\\n\\ \\\\\n& \\text{where:} \\\\\n& \\bar x_1 : \\text{sample mean group 1} \\\\\n& \\bar x_2 : \\text{sample mean group 2} \\\\\n& SE : \\sqrt{\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}} \\\\\n& s_1 : \\text{sample standard deviation of group 1} \\\\\n& s_2 : \\text{sample standard deviation of group 2} \\\\\n& n_1 : \\text{sample size group 1} \\\\\n& n_2 : \\text{sample size group 2} \\\\\n\\end{align}\n\\]\nWe can calculate each part:\n\ntcaff |&gt;\n  group_by(caff) |&gt;\n  summarise(\n    xbar = mean(rt),\n    s = sd(rt),\n    s2 = var(rt),\n    n = n()\n  )\n\n# A tibble: 2 × 5\n  caff   xbar     s     s2     n\n  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;\n1 no     408.  88.9  7906.    40\n2 yes    465. 109.  11892.    60\n\n\nplugging these bits in gives us: \\[\n\\begin{align}\nSE & = \\sqrt{\\frac{s^2_1}{n_1} + \\frac{s^2_2}{n_2}} = \\sqrt{\\frac{7906}{40} + \\frac{11892}{60}} = \\sqrt{395.85} \\\\\n\\qquad \\\\\n& = 19.9\n\\end{align}\n\\] and \\[\n\\begin{align}\nt & =  \\frac{\\bar x_1 - \\bar x_2}{SE} = \\frac{408.1 - 464.8}{19.9} \\\\\n\\qquad \\\\\n& = -2.849 \\\\\n\\end{align}\n\\]\nOur \\(p\\)-value is determined against a \\(t\\)-distribution with a specific number of degrees of freedom. We are estimating two means here, the standard two-sample t-test uses \\(df = n-2\\). However, the Welch t-test, which we performed quickly with t.test(), where we don’t assume equal variances, makes the calculation of the degrees of freedom much more complicated.5\nUsing the same degrees of freedom as was used in the quick use of t.test() above, we get out our same p-value (or thereabouts - we have some rounding error):\n\n2*pt(abs(-2.849), df = 93.971, lower.tail = FALSE)\n\n[1] 0.005388563\n\n\n\n\n\n\n\n\n\n\n\nWrite-up\n\n\n\n\n\n\nA Welch two sample t-test was used to assess whether the mean reaction time of people who regularly drink caffeine (\\(n = 60\\)) was different to that of people who do not (\\(n=40\\)). There was a significant difference in average reaction time between the caffeine (Mean=465; SD=109) and non-caffeine (Mean=408; SD=89) groups (\\(t(93.97)=-2.85, p = 0.005\\), two-tailed). Therefore, we reject the null hypothesis that there is no difference in reaction times between caffeine drinkers and non-caffeine drinkers.\n\n\nCode\nggplot(tcaff, aes(x = caff, y = rt)) +\n  geom_boxplot()+\n  labs(x=\"drinks caffeine\",y=\"reaction time (ms)\")"
  },
  {
    "objectID": "03b_inference2.html#paired-sample-t-test",
    "href": "03b_inference2.html#paired-sample-t-test",
    "title": "3B: Practical Inference",
    "section": "Paired sample t-test",
    "text": "Paired sample t-test\n\nPurpose\nThe paired sample t-test is used to test whether the mean difference between two sets of paired observations is different from 0.\n\nExamples:\n\nIs the mean cognitive score of participants at age 60 different from when they are re-tested at age 70?\n\nAre scores on test 1 different on average from scores on test 2 (with participants completing both tests).\n\n\nAssumptions:\n\nThe data are continuous (not discrete)\nThe differences are independent (i.e. the value of a the difference for one pair does not depend on the values of another pair in any way)\nThe differences are normally distributed OR the sample size is large enough (rule-of-thumb n = 30) and the data are not strongly skewed\n\n\n\n\n\n\n\n\nResearch Question & Data\n\n\n\n\n\n\nResearch Question: Is the mean cognitive score of participants at age 60 different from when they are re-tested at age 70?\n\nAddenbrooke’s Cognitive Examination-III (ACE-III) is a brief cognitive test that assesses five cognitive domains: attention, memory, verbal fluency, language and visuospatial abilities. The total score is 100 with higher scores indicating better cognitive functioning. A research project is examining changes in cognitive functioning with age, and administers the ACE-III to a set of participants at age 60, then again at age 70. The data is accessible at https://uoepsy.github.io/data/usmr_tcaff.csv.\n\nacedata &lt;- read_csv(\"https://uoepsy.github.io/data/acedata.csv\")\nhead(acedata)\n\n# A tibble: 6 × 3\n  participant ace_60 ace_70\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 sub1            93     85\n2 sub2            95     92\n3 sub3            93     90\n4 sub4            93     95\n5 sub5            96     88\n6 sub6            91     85\n\n\n\n\n\n\n\n\n\n\n\nThe paired t test is the one sample t test in disguise\n\n\n\n\n\nWe can either perform this with the data exactly as it is:\n\nt.test(x = acedata$ace_60, y = acedata$ace_70, \n       paired = TRUE)\n\n\n    Paired t-test\n\ndata:  acedata$ace_60 and acedata$ace_70\nt = 2.2542, df = 24, p-value = 0.03359\nalternative hypothesis: true mean difference is not equal to 0\n95 percent confidence interval:\n 0.2093364 4.7506636\nsample estimates:\nmean difference \n           2.48 \n\n\nOr we can compute the differences, and perform a one sample test on the mean of those differences being different from 0.\nIt’s just the same result:\n\nacedata &lt;- acedata |&gt;\n  mutate(diff_score = ace_60 - ace_70)\n\nt.test(acedata$diff_score, mu = 0)\n\n\n    One Sample t-test\n\ndata:  acedata$diff_score\nt = 2.2542, df = 24, p-value = 0.03359\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n 0.2093364 4.7506636\nsample estimates:\nmean of x \n     2.48"
  },
  {
    "objectID": "03b_inference2.html#footnotes",
    "href": "03b_inference2.html#footnotes",
    "title": "3B: Practical Inference",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nRemember that confidence intervals provide a range of plausible values for the population mean. In this case, zero is a plausible value.↩︎\nThis is because with smaller samples we have less certainty in the estimate of the population standard deviation, and our estimates of mean and standard deviation are more dependent on one another. The bottom part of \\(\\frac{\\bar x - \\mu}{SE}\\) has a greater chance of being smaller than the top part, meaning that our resulting our test statistics will tend to be slightly bigger. To better represent this greater chance of seeing bigger test statistics from small samples, our \\(t\\)-distributions have heavier tails.↩︎\nThis is because, practically speaking, what we really need in order to make useful, defensible conclusions, is not that the population itself is normally distributed, but that the sampling distribution of the statistic is close enough to the \\(t\\)-distribution. This can often be the case when we have a large sample without much skew.↩︎\nThe formula here is for the Welch test.\nFor a standard two sample t-test that assumes equal variances, we first calculate the “pooled standard deviation” - \\(s_p = \\sqrt\\frac{(n_1 - 1)s_1^2 + (n_2 - 1)s_2^2}{n_1 + n_2 - 2}\\).\nWe then use this to calculate the standard error - \\(SE_{(\\bar{x}_1 - \\bar{x}_2)} = s_p \\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}\\)↩︎\nIf you really want it, the formula is: \\(\\text{df}=\\frac{\\left(\\dfrac{s_1^2}{n_1}+\\dfrac{s_2^2}{n_2}\\right)^2}{\\dfrac{\\left(\\dfrac{s_1^2}{n_1}\\right)^2}{n_1-1}+\\dfrac{\\left(\\dfrac{s_2^2}{n_2}\\right)^2}{n_2-1}}\\)↩︎"
  },
  {
    "objectID": "04_ex.html",
    "href": "04_ex.html",
    "title": "Exercises: Binomial & Chi-Square Tests",
    "section": "",
    "text": "Research Question: Is the probability that a student prefers Dogs over Cats greater than 50%?\n\n\nData: Past Surveys\nIn the last few years, we have asked students of the statistics courses in the Psychology department to fill out a little survey.\nAnonymised data are available at https://uoepsy.github.io/data/surveydata_historical.csv.\nNote: this does not contain the responses from this year.\n\nsurveydata &lt;- \n  read_csv(\"https://uoepsy.github.io/data/surveydata_historical.csv\")\n\n\n\nQuestion 1\n\n\nCalculate the proportion of students who chose cats vs dogs in the survey. If the probability that a student prefers dogs to cats is 50%, what would we expect to see?\n\n\n\n\n\n\nHints\n\n\n\n\n\ntable() |&gt; prop.table() might be the quickest way here.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nI sometimes like adding a |&gt; print() |&gt; in the middle of these sequences of pipes to print out the intermediary output as well:\n\ntable(surveydata$catdog) |&gt;\n  print() |&gt;\n  prop.table()\n\n\ncat dog \n222 317 \n\n\n\n      cat       dog \n0.4118738 0.5881262 \n\n\nIf the probability was 50%, or 0.5, then we would expect the numbers to be equal. We have 539 responses here, so we would expect 269.5 to be team cats, and 269.5 to be team dogs!\n\n\n\n\nQuestion 2\n\n\n\nResearch Question: Is the probability that a student prefers Dogs over Cats greater than 50%?\n\nConduct a test to address the research question.\n\n\n\n\n\n\nHints\n\n\n\n\n\n\nNote the “tailedness” of the question. Just like t.test(), the function we use here should allow us to specify our hypothesis.\n\nYou can see an example of this test in 4A #binomials.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe’re going to want to use the binom.test() function. This is just like the reading, where we tested the proportion of our sample who were left-handed.\nWe can either type in the numbers of “Dog” people out of our total number:\n\nbinom.test(317, 539, p = 0.5, alternative = \"greater\")\n\n\n    Exact binomial test\n\ndata:  317 and 539\nnumber of successes = 317, number of trials = 539, p-value = 2.468e-05\nalternative hypothesis: true probability of success is greater than 0.5\n95 percent confidence interval:\n 0.5520308 1.0000000\nsample estimates:\nprobability of success \n             0.5881262 \n\n\nOr give the function a table.\nBUT we need to make sure that it is picking up the right value as “successes”.\nNotice that this gives us a different result:\n\n\n\n    Exact binomial test\n\ndata:  table(surveydata$catdog)\nnumber of successes = 222, number of trials = 539, p-value = 1\nalternative hypothesis: true probability of success is greater than 0.5\n95 percent confidence interval:\n 0.3764991 1.0000000\nsample estimates:\nprobability of success \n             0.4118738 \n\n\nThis is because it is taking the first entry as the number of successes. So it is saying that Cat people = 1 and Dog people = 0. But we want it the other way around! You could either create a different table (or switch its order), or simply switch to the alternative being “less” (because in this unrealistic binary world, the question “is the probability of being Dog person &gt;0.5?” is the same thing as “is probability of being Cat person &lt;0.5?”)"
  },
  {
    "objectID": "04_ex.html#cats-n-dogs",
    "href": "04_ex.html#cats-n-dogs",
    "title": "Exercises: Binomial & Chi-Square Tests",
    "section": "",
    "text": "Research Question: Is the probability that a student prefers Dogs over Cats greater than 50%?\n\n\nData: Past Surveys\nIn the last few years, we have asked students of the statistics courses in the Psychology department to fill out a little survey.\nAnonymised data are available at https://uoepsy.github.io/data/surveydata_historical.csv.\nNote: this does not contain the responses from this year.\n\nsurveydata &lt;- \n  read_csv(\"https://uoepsy.github.io/data/surveydata_historical.csv\")\n\n\n\nQuestion 1\n\n\nCalculate the proportion of students who chose cats vs dogs in the survey. If the probability that a student prefers dogs to cats is 50%, what would we expect to see?\n\n\n\n\n\n\nHints\n\n\n\n\n\ntable() |&gt; prop.table() might be the quickest way here.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nI sometimes like adding a |&gt; print() |&gt; in the middle of these sequences of pipes to print out the intermediary output as well:\n\ntable(surveydata$catdog) |&gt;\n  print() |&gt;\n  prop.table()\n\n\ncat dog \n222 317 \n\n\n\n      cat       dog \n0.4118738 0.5881262 \n\n\nIf the probability was 50%, or 0.5, then we would expect the numbers to be equal. We have 539 responses here, so we would expect 269.5 to be team cats, and 269.5 to be team dogs!\n\n\n\n\nQuestion 2\n\n\n\nResearch Question: Is the probability that a student prefers Dogs over Cats greater than 50%?\n\nConduct a test to address the research question.\n\n\n\n\n\n\nHints\n\n\n\n\n\n\nNote the “tailedness” of the question. Just like t.test(), the function we use here should allow us to specify our hypothesis.\n\nYou can see an example of this test in 4A #binomials.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nWe’re going to want to use the binom.test() function. This is just like the reading, where we tested the proportion of our sample who were left-handed.\nWe can either type in the numbers of “Dog” people out of our total number:\n\nbinom.test(317, 539, p = 0.5, alternative = \"greater\")\n\n\n    Exact binomial test\n\ndata:  317 and 539\nnumber of successes = 317, number of trials = 539, p-value = 2.468e-05\nalternative hypothesis: true probability of success is greater than 0.5\n95 percent confidence interval:\n 0.5520308 1.0000000\nsample estimates:\nprobability of success \n             0.5881262 \n\n\nOr give the function a table.\nBUT we need to make sure that it is picking up the right value as “successes”.\nNotice that this gives us a different result:\n\n\n\n    Exact binomial test\n\ndata:  table(surveydata$catdog)\nnumber of successes = 222, number of trials = 539, p-value = 1\nalternative hypothesis: true probability of success is greater than 0.5\n95 percent confidence interval:\n 0.3764991 1.0000000\nsample estimates:\nprobability of success \n             0.4118738 \n\n\nThis is because it is taking the first entry as the number of successes. So it is saying that Cat people = 1 and Dog people = 0. But we want it the other way around! You could either create a different table (or switch its order), or simply switch to the alternative being “less” (because in this unrealistic binary world, the question “is the probability of being Dog person &gt;0.5?” is the same thing as “is probability of being Cat person &lt;0.5?”)"
  },
  {
    "objectID": "04_ex.html#birth-months",
    "href": "04_ex.html#birth-months",
    "title": "Exercises: Binomial & Chi-Square Tests",
    "section": "Birth-Months",
    "text": "Birth-Months\n\nResearch Question: Are students more likely to be born in certain months than others?\n\n\nData: Past Surveys\nIn the last few years, we have asked students of the statistics courses in the Psychology department to fill out a little survey.\nAnonymised data are available at https://uoepsy.github.io/data/surveydata_historical.csv.\nNote: this does not contain the responses from this year.\n\nsurveydata &lt;- \n  read_csv(\"https://uoepsy.github.io/data/surveydata_historical.csv\")\n\n\n\nQuestion 3\n\n\nWhat is your intuition about the distribution of all students’ birth-months?\nDo you think they will be spread uniformly across all months of the year (like a fair 12-sided dice), or do you think people are more likely to be born in certain months more than others?\nPlot the distribution and get an initial idea of how things are looking.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou can do this quickly with barplot() and table(), or you could create try using ggplot() and looking into geom_bar().\n\n\n\n\n\n\n\n\nSolution\n\n\n\nThe quick and dirty way to plot:\n\nbarplot(table(surveydata$birthmonth))\n\n\n\n\n\n\n\n\nA ggplot option:\n\nggplot(data = surveydata, aes(x = birthmonth)) +\n    geom_bar() +\n    labs(x = \"- Birth Month -\")\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4\n\n\nWe’re going to perform a statistical test to assess the extent to which our data conforms to the hypothesis that people are no more likely to be born on one month than another.\nUnder this hypothesis, what would be the proportional breakdown of observed births in each of the months?\n\n\n\n\n\nSolution\n\n\n\nIf people are no more likely to be born in one month than another, then we would expect the same proportion of observed births in each month.\nThere are 12 months, so we would expect \\(\\frac{1}{12}\\) observations in each month.\nWe can write these as: \\[\n\\begin{align}\n& p_{jan} = 1/12 \\\\\n& p_{feb} = 1/12 \\\\\n& ... \\\\\n& p_{dec} = 1/12 \\\\\n\\end{align}\n\\]\n\n\n\n\nQuestion 5\n\n\nHow many observations in our sample would we expect to find with a birthday in January? And in February? … and so on?\n\n\n\n\n\n\nHints\n\n\n\n\n\nHow many responses (i.e. not missing values) do we have for this question?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nThere are 544 people who have non-NA values (sum(!is.na(surveydata$birthmonth))).\nUnder the null hypothesis, we would expect \\(\\frac{1}{12} \\times\\) 544 = 45.33 observations born in each month.\n\n\n\n\nQuestion 6\n\n\nThe code below creates counts for each month. Before doing that, it removes the rows which have an NA in them for birthmonth:\n\nsurveydata |&gt;\n  filter(!is.na(birthmonth)) |&gt;\n  group_by(birthmonth) |&gt;\n  summarise(\n      observed = n()\n  )\n\n(A shortcut for this would be surveydata |&gt; filter(!is.na(birthmonth)) |&gt; count(birthmonth))\nAdd to the code above to create columns showing:\n\nthe expected counts \\(E_i\\)\nobserved-expected (\\(O_i - E_i\\))\nthe squared differences \\((O_i - E_i)^2\\)\nthe standardised square differences \\(\\frac{(O_i - E_i)^2}{E_i}\\)\n\nThen calculate the \\(\\chi^2\\) statistic (the sum of the standardised squared differences).\nIf your observed counts matched the expected counts perfectly, what would the \\(\\chi^2\\) statistic be?\n\n\n\n\n\n\nHints\n\n\n\n\n\nThis was all done in the step-by-step example of a \\(\\chi^2\\) test in 4A #chi2-goodness-of-fit-test\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nchi_table &lt;- \n    surveydata |&gt;\n    filter(!is.na(birthmonth)) |&gt;\n    group_by(birthmonth) |&gt;\n    summarise(\n        observed = n(),\n        expected = sum(!is.na(surveydata$birthmonth))/12,\n        diff = observed-expected,\n        sq_diff = diff^2,\n        std_sq_diff = sq_diff / expected\n    )\nchi_table\n\n# A tibble: 12 × 6\n   birthmonth observed expected    diff sq_diff std_sq_diff\n   &lt;chr&gt;         &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 apr              37     45.3  -8.33   69.4       1.53   \n 2 aug              42     45.3  -3.33   11.1       0.245  \n 3 dec              42     45.3  -3.33   11.1       0.245  \n 4 feb              35     45.3 -10.3   107.        2.36   \n 5 jan              49     45.3   3.67   13.4       0.297  \n 6 jul              54     45.3   8.67   75.1       1.66   \n 7 jun              46     45.3   0.667   0.444     0.00980\n 8 mar              47     45.3   1.67    2.78      0.0613 \n 9 may              49     45.3   3.67   13.4       0.297  \n10 nov              46     45.3   0.667   0.444     0.00980\n11 oct              50     45.3   4.67   21.8       0.480  \n12 sep              47     45.3   1.67    2.78      0.0613 \n\n\nAnd we can calculate our \\(\\chi^2\\) test statistic by simply summing the values in the last column we created:\n\nsum(chi_table$std_sq_diff)\n\n[1] 7.25\n\n\nIf all our observed counts are equal to our expected counts, then the diff column above will be all \\(0\\), and \\(0^2=0\\), and \\(\\frac{0}{E_i}\\) will be \\(0\\). So \\(\\chi^2\\) will be \\(0\\).\n\n\n\n\nQuestion 7\n\n\nYou can see the distribution of \\(\\chi^2\\) statistics with different degrees of freedom below.\n\n\n\n\n\nFigure 1: Chi-Square Distributions\n\n\n\n\nWe can find out the proportion of the distribution which falls to either side of a given value of \\(\\chi^2\\) using pchisq(). We need to give it our calculated \\(\\chi^2\\) statistic, our degrees of freedom (df), which is equal to the number of categories minus 1. We also need to specify whether we want the proportion to the left (lower.tail=TRUE) or to the right (lower.tail=FALSE).\n\nUsing pchisq(), calculate the probability of observing a \\(\\chi^2\\) statistic as least as extreme as the one we have calculated.\n\nCheck that these results match with those provided by R’s built-in function: chisq.test(table(surveydata$birthmonth)) (the table function will ignore NAs by default, so we don’t need to do anything extra for this).\n\n\n\n\n\n\nSolution\n\n\n\n\nsum(chi_table$std_sq_diff)\n\n[1] 7.25\n\npchisq(sum(chi_table$std_sq_diff), df = 11, lower.tail = FALSE)\n\n[1] 0.7784916\n\n\n\nchisq.test(table(surveydata$birthmonth))\n\n\n    Chi-squared test for given probabilities\n\ndata:  table(surveydata$birthmonth)\nX-squared = 7.25, df = 11, p-value = 0.7785\n\n\n\n\n\n\nQuestion 8\n\n\nWhich months of year had the highest contributions to the chi-square test statistic?\n\n\n\n\n\n\nHints\n\n\n\n\n\nThink about your standardised squared deviations.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nStandardized squared deviations\nOne possible way to answer this question is to look at the individual contribution of each category to the \\(\\chi^2\\) statistic. We computed these values in an earlier question.\n\nchi_table |&gt;\n  select(birthmonth, std_sq_diff)\n\n# A tibble: 12 × 2\n   birthmonth std_sq_diff\n   &lt;chr&gt;            &lt;dbl&gt;\n 1 apr            1.53   \n 2 aug            0.245  \n 3 dec            0.245  \n 4 feb            2.36   \n 5 jan            0.297  \n 6 jul            1.66   \n 7 jun            0.00980\n 8 mar            0.0613 \n 9 may            0.297  \n10 nov            0.00980\n11 oct            0.480  \n12 sep            0.0613 \n\n\nFrom the barplot we created earlier on, we can see which months make up higher/lower proportions than expected:\n\nggplot(chi_table, aes(x = birthmonth, y = observed/nrow(surveydata))) +\n  geom_col(fill = 'lightblue') +\n  geom_hline(yintercept = 1/12, color = 'red') +\n  theme_classic(base_size = 15)\n\n\n\n\n\n\n\n\nPearson residuals\nEquivalently, you could answer by looking at Pearson residuals:\n\nchisq.test(table(surveydata$birthmonth))$residuals\n\n\n        apr         aug         dec         feb         jan         jul \n-1.23768443 -0.49507377 -0.49507377 -1.53472869  0.54458115  1.28719181 \n        jun         mar         may         nov         oct         sep \n 0.09901475  0.24753689  0.54458115  0.09901475  0.69310328  0.24753689 \n\n\nThe greatest absolute values are for feb and jul, showing that for these months the deviations from expected to observed were the greatest."
  },
  {
    "objectID": "04_ex.html#childrens-favourite-colours",
    "href": "04_ex.html#childrens-favourite-colours",
    "title": "Exercises: Binomial & Chi-Square Tests",
    "section": "Children’s Favourite Colours",
    "text": "Children’s Favourite Colours\n\nResearch Question: Do childrens’ favourite colours correspond to the those suggested by the internet?\n\n\nAccording to one part of the internet, 30% of children have red as their favourite colour, 20% have blue, 15% yellow, 11% purple, 9% green, and 15% prefer some other colour.\nWe collected data from 50 children aged between 2 and 5, and got them to choose one of a set of objects that were identical apart from colour. You can see the data in Table 1\n\n\n\n\n\n\nTable 1:  Colour preferences of 50 children aged between 2 and 5 \n  \n    \n      colour\n      Freq\n    \n  \n  \n    blue\n10\n    green\n6\n    other\n3\n    purple\n8\n    red\n8\n    yellow\n15\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 9\n\n\nPerform a \\(\\chi^2\\) goodness of fit test to assess the extent to which our sample of children conform to this theorised distribution of colour preferences.\nNo need to do this manually - once is enough. Just go straight to using the chisq.test() function.\nHowever, we will need to get the numbers into R somehow..\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou can make a table from scratch using, for example: as.table(c(1,2,3,4,5)).\nFor the test, try using chisq.test(..., p = c(?,?,?,...) ).\nWe saw the use of chisq.test() in the example goodness of fit test, 4A #chi2-goodness-of-fit-test\n\n\n\n\n\n\n\n\nSolution\n\n\n\nLet’s get the data in:\n\nchildcols &lt;- as.table(c(10,6,3,8,8,15))\nnames(childcols) &lt;- c(\"blue\",\"green\",\"other\",\"purple\",\"red\",\"yellow\")\nchildcols\n\n  blue  green  other purple    red yellow \n    10      6      3      8      8     15 \n\n\nOur theoretical probabilities of different colours must match the order in the table which we give chisq.test(). They must also always sum to 1.\n\nchisq.test(childcols, p = c(.20,.09,.15,.11,.30,.15))\n\nWarning in chisq.test(childcols, p = c(0.2, 0.09, 0.15, 0.11, 0.3, 0.15)):\nChi-squared approximation may be incorrect\n\n\n\n    Chi-squared test for given probabilities\n\ndata:  childcols\nX-squared = 15.103, df = 5, p-value = 0.009931\n\n\nNote, we get a warning here of “Chi-squared approximation may be incorrect”. This is because some of the expected cell counts are &lt;5.\n\nchisq.test(childcols, \n           p = c(.20,.09,.15,.11,.30,.15))$expected\n\n  blue  green  other purple    red yellow \n  10.0    4.5    7.5    5.5   15.0    7.5 \n\n\nThere are a couple of options here, but the easiest is to use the functionality of chisq.test() that allows us to compute the p-value by using a simulation (similar to the idea we saw in 2B#sampling-&-sampling-distributions), rather than by comparing it to a theoretical \\(\\chi^2\\) distribution. We can do this by using:\n\nchisq.test(childcols, p = c(.20,.09,.15,.11,.30,.15),\n           simulate.p.value = TRUE)\n\n\n    Chi-squared test for given probabilities with simulated p-value (based\n    on 2000 replicates)\n\ndata:  childcols\nX-squared = 15.103, df = NA, p-value = 0.01249\n\n\n\n\n\n\nQuestion 10\n\n\nWhat are the observed proportions of children who prefer each colour?\n\n\n\n\n\n\nHints\n\n\n\n\n\nLook up the prop.table() function?\n\n\n\n\n\n\n\n\nSolution\n\n\n\nFrom the help documentation (?prop.table()), we see that we can pass prop.table() the argument x, which needs to be a table.\n\nprop.table(childcols)*100\n\n  blue  green  other purple    red yellow \n    20     12      6     16     16     30 \n\n\n\nbarplot(prop.table(childcols)*100)"
  },
  {
    "objectID": "04_ex.html#jokes-and-tips",
    "href": "04_ex.html#jokes-and-tips",
    "title": "Exercises: Binomial & Chi-Square Tests",
    "section": "Jokes and Tips",
    "text": "Jokes and Tips\n\nData: TipJokes\n\nResearch Question: Can telling a joke affect whether or not a waiter in a coffee bar receives a tip from a customer?\n\nA study published in the Journal of Applied Social Psychology1 investigated this question at a coffee bar of a famous seaside resort on the west Atlantic coast of France. The waiter randomly assigned coffee-ordering customers to one of three groups. When receiving the bill, one group also received a card telling a joke, another group received a card containing an advertisement for a local restaurant, and a third group received no card at all.\nThe data are available at https://uoepsy.github.io/data/TipJoke.csv.\nThe dataset contains the variables:\n\nCard: None, Joke, Ad.\nTip: 1 = The customer left a tip, 0 = The customer did not leave tip.\n\n\n\nQuestion 11\n\n\nProduce a plot and a table to display the relationship between whether or not the customer left a tip, and what (if any) card they received alongside the bill.\nDon’t worry about making it all pretty. Mosaic plots in R are a bit difficult.\n\n\n\n\n\n\nHints\n\n\n\n\n\nplot(table(...)) will give you something. You can see one in the example \\(\\chi^2\\) test of independence,4A #chi2-test-of-independence.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\ntipjoke &lt;- read_csv('https://uoepsy.github.io/data/TipJoke.csv')\n\ntable(tipjoke$Card, tipjoke$Tip)\n\n      \n        0  1\n  Ad   60 14\n  Joke 42 30\n  None 49 16\n\nplot(table(tipjoke$Card, tipjoke$Tip))\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 12\n\n\nWhat would you expect the cell counts to look like if there were no relationship between what the waiter left and whether or not the customer tipped?\n\n\n\n\n\n\nHints\n\n\n\n\n\nThink about what proportion of customers tipped. Then work out how many customers got each type of card. If there were no relationship, then the proportions would be the same in each group.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nIn total, 60 customers tipped (14+30+16), and 151 did not. So overall, 0.28 (\\(\\frac{60}{(60+151)}\\)) of customers tip.\n74 customers got an Ad card, 72 customers got a Joke, and 65 got None. If this were independent of whether or not they left a tip, we would expect equal proportions of tippers in each group.\nSo we would expect 0.28 of each group to leave a tip.\n\n\n\n\n\n\nsome calculations\n\n\n\n\n\nYou can think about observed vs expected by looking at the two-way table along with the marginal row and column totals given:\n\n\n\n\n\n\n0\n1\n\n\n\n\n\nAd\n\n\n74\n\n\nJoke\n\n\n72\n\n\nNone\n\n\n65\n\n\n\n151\n60\n211\n\n\n\n\n\n\n\nFor a given cell of the table we can calculate the expected count as \\(\\text{row total} \\times \\frac{\\text{column total}}{\\text{samplesize}}\\):\nExpected:\n\n\n\n\n\n\n0\n1\n\n\n\n\n\nAd\n52.96\n21.04\n74\n\n\nJoke\n51.53\n20.47\n72\n\n\nNone\n46.52\n18.48\n65\n\n\n\n151.00\n60.00\n211\n\n\n\n\n\n\n\nIf you’re wondering how we do this in R.. here’s our table:\n\nt &lt;- tipjoke |&gt;\n  select(Card, Tip) |&gt; table()\nt\n\n      Tip\nCard    0  1\n  Ad   60 14\n  Joke 42 30\n  None 49 16\n\n\nHere are the row totals:\n\nrowSums(t)\n\n  Ad Joke None \n  74   72   65 \n\n\nand column totals divided by total:\n\ncolSums(t) / sum(t)\n\n        0         1 \n0.7156398 0.2843602 \n\n\nthere’s a complicated bit of code using %o% which could do this for us. You don’t need to remember %o%, it’s very rarely used):\n\ne &lt;- rowSums(t) %o% colSums(t) / sum(t)\ne\n\n            0        1\nAd   52.95735 21.04265\nJoke 51.52607 20.47393\nNone 46.51659 18.48341\n\n\nOr, alternatively, do it one by one:\n\nrowSums(t) * (colSums(t) / sum(t))[1]\n\n      Ad     Joke     None \n52.95735 51.52607 46.51659 \n\nrowSums(t) * (colSums(t) / sum(t))[2]\n\n      Ad     Joke     None \n21.04265 20.47393 18.48341 \n\n\n\n\n\n\n\n\n\nQuestion 13\n\n\nJust like we gave the chisq.test() function a table of observed frequencies when we conducted a goodness of fit test in earlier exercises, we can give it a two-way table of observed frequencies to conduct a test of independence.\nTry it now.\n\n\n\n\n\nSolution\n\n\n\n\nchisq.test(table(tipjoke$Card, tipjoke$Tip))\n\n\n    Pearson's Chi-squared test\n\ndata:  table(tipjoke$Card, tipjoke$Tip)\nX-squared = 9.9533, df = 2, p-value = 0.006897"
  },
  {
    "objectID": "04_ex.html#footnotes",
    "href": "04_ex.html#footnotes",
    "title": "Exercises: Binomial & Chi-Square Tests",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nGueaguen, N. (2002). The Effects of a Joke on Tipping When It Is Delivered at the Same Time as the Bill. Journal of Applied Social Psychology, 32(9), 1955-1963.↩︎"
  },
  {
    "objectID": "04a_chisq.html",
    "href": "04a_chisq.html",
    "title": "4A: Binomial & Chi-Square Tests",
    "section": "",
    "text": "This reading:\n\nWhat are the basic hypothesis tests that we can conduct when we are interested in variables that have categories instead of numbers?\n\nTests of a proportion\nTests of the distribution of a single categorical variable\nTests of the relationship between two categorical variables\nJust like we did with the various types of \\(t\\)-test, we’re going to continue with some more brief explainers of different basic statistical tests. The past few weeks have focused on tests for numeric outcome variables, where we have been concerned with the mean of that variable (e.g. whether that mean is different from some specific value, or whether it is different between two groups). We now turn to investigate tests for categorical outcome variables.\nWhen studying categorical variables, we tend to be interested in counts (or “frequencies”), and these can be presented in tables:\ntimehands &lt;- read_csv(\"https://uoepsy.github.io/data/timehands.csv\") |&gt;\n  mutate(\n    isLeft = ifelse(handed==\"left\", \"left\", \"other\")\n  )\n\ntable(timehands$isLeft) \n\n\n left other \n   12    88"
  },
  {
    "objectID": "04a_chisq.html#footnotes",
    "href": "04a_chisq.html#footnotes",
    "title": "4A: Binomial & Chi-Square Tests",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nthe conventional \\(\\alpha\\) level used in psychology↩︎"
  },
  {
    "objectID": "04b_revisitnhst.html",
    "href": "04b_revisitnhst.html",
    "title": "4B: Revisiting NHST",
    "section": "",
    "text": "This reading:\n\nWhy is “statistical significance” only one part of the picture?\nIn the last couple of weeks we have performed a number of different types of statistical hypothesis test, and it is worth revisiting the general concept in order to consolidate what we’ve been doing."
  },
  {
    "objectID": "04b_revisitnhst.html#footnotes",
    "href": "04b_revisitnhst.html#footnotes",
    "title": "4B: Revisiting NHST",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe could instead make the group variable a factor and specify the order of the levels↩︎\nFor those of you who are interested in what alternative definitions there are, do a google search for “frequentist vs bayesian”. Be prepared that this will open a big can of worms!↩︎"
  },
  {
    "objectID": "05_ex.html",
    "href": "05_ex.html",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "",
    "text": "Question 1\n\n\nGo to http://guessthecorrelation.com/ and play the “guess the correlation” game for a little while to get an idea of what different strengths and directions of \\(r\\) can look like.\n\n\n\n\n\n\nData: Sleep levels and daytime functioning\nA researcher is interested in the relationship between hours slept per night and self-rated effects of sleep on daytime functioning. She recruited 50 healthy adults, and collected data on the Total Sleep Time (TST) over the course of a seven day period via sleep-tracking devices.\nAt the end of the seven day period, participants completed a Daytime Functioning (DTF) questionnaire. This involved participants rating their agreement with ten statements (see Table 1). Agreement was measured on a scale from 1-5. An overall score of daytime functioning can be calculated by:\n\nreversing the scores for items 4,5 and 6 (because those items reflect agreement with positive statements, whereas the other ones are agreement with negative statement);\nsumming the scores on each item; and\nsubtracting the sum score from 50 (the max possible score). This will make higher scores reflect better perceived daytime functioning.\n\nThe data is available at https://uoepsy.github.io/data/sleepdtf.csv.\n\n\n\n\n\n\nTable 1:  Daytime Functioning Questionnaire \n  \n    \n      Item\n      Statement\n    \n  \n  \n    Item_1\nI often felt an inability to concentrate\n    Item_2\nI frequently forgot things\n    Item_3\nI found thinking clearly required a lot of effort\n    Item_4\nI often felt happy\n    Item_5\nI had lots of energy\n    Item_6\nI worked efficiently\n    Item_7\nI often felt irritable\n    Item_8\nI often felt stressed\n    Item_9\nI often felt sleepy\n    Item_10\nI often felt fatigued\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 2\n\n\nLoad the required libraries (probably just tidyverse for now), and read in the data.\nCalculate the overall daytime functioning score, following the criteria outlined above, and make this a new column in your dataset.\n\n\n\n\n\n\nHints\n\n\n\n\n\nTo reverse items 4, 5 and 6, we we need to make all the scores of 1 become 5, scores of 2 become 4, and so on… What number satisfies all of these equations: ? - 5 = 1, ? - 4 = 2, ? - 3 = 3?\nTo quickly sum across rows, you might find the rowSums() function useful (you don’t have to use it though)\nIf my items were in columns between 4 to 15:\n\ndataframe$sumscore = rowSums(dataframe[, 4:15])\n\n\n\n\n\n\n\n\n\nSolution Part 1 - Reversing Items\n\n\n\n\nsleepdtf &lt;- read_csv(\"https://uoepsy.github.io/data/sleepdtf.csv\")\nsummary(sleepdtf)\n\n      TST             item_1         item_2         item_3         item_4    \n Min.   : 4.900   Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.00  \n 1st Qu.: 7.225   1st Qu.:1.00   1st Qu.:2.00   1st Qu.:1.25   1st Qu.:1.00  \n Median : 7.900   Median :1.00   Median :2.00   Median :2.00   Median :1.00  \n Mean   : 8.004   Mean   :1.58   Mean   :2.46   Mean   :2.38   Mean   :1.26  \n 3rd Qu.: 9.025   3rd Qu.:2.00   3rd Qu.:3.00   3rd Qu.:3.00   3rd Qu.:1.00  \n Max.   :11.200   Max.   :3.00   Max.   :5.00   Max.   :5.00   Max.   :3.00  \n     item_5         item_6         item_7         item_8        item_9    \n Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.0   Min.   :1.00  \n 1st Qu.:2.00   1st Qu.:2.00   1st Qu.:1.00   1st Qu.:2.0   1st Qu.:2.00  \n Median :2.00   Median :3.00   Median :2.00   Median :2.5   Median :3.00  \n Mean   :2.36   Mean   :2.78   Mean   :2.04   Mean   :2.5   Mean   :2.96  \n 3rd Qu.:3.00   3rd Qu.:4.00   3rd Qu.:3.00   3rd Qu.:3.0   3rd Qu.:4.00  \n Max.   :4.00   Max.   :5.00   Max.   :4.00   Max.   :4.0   Max.   :5.00  \n    item_10    \n Min.   :1.00  \n 1st Qu.:2.00  \n Median :3.00  \n Mean   :2.54  \n 3rd Qu.:3.00  \n Max.   :5.00  \n\n\nTo reverse the items, we can simply do 6 minus the score:\n\nsleepdtf &lt;- \n  sleepdtf |&gt; mutate(\n    item_4=6-item_4,\n    item_5=6-item_5,\n    item_6=6-item_6\n  ) \n\n\n\n\n\n\nSolution Part 2 - Creating a scale score\n\n\n\nNow we can use rowSums(), and subtract the sum scores from from 50 (the max score):\n\nsleepdtf$dtf = 50-rowSums(sleepdtf[, 2:11])\n\nAn alternative way to do this would be:\n\nsleepdtf |&gt; \n  mutate(\n    dtf = 50 - (item_1 + item_2 + item_3 + item_4 + item_5 + item_6 + item_7 + item_8 + item_9 + item_10)\n  )\n\n\n\n\n\nQuestion 3\n\n\nCalculate the correlation between the total sleep time (TST) and the overall daytime functioning score calculated in the previous question.\nConduct a test to establish the probability of observing a correlation this strong in a sample of this size assuming the true correlation to be 0.\nWrite a sentence or two summarising the results.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou can do this all with one function, see 5A #correlation-test.\n\n\n\n\n\n\n\n\ncor.test(sleepdtf$TST, sleepdtf$dtf)\n\n\n    Pearson's product-moment correlation\n\ndata:  sleepdtf$TST and sleepdtf$dtf\nt = 6.244, df = 48, p-value = 1.062e-07\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.4807039 0.7989417\nsample estimates:\n      cor \n0.6694741 \n\n\n\nThere was a strong positive correlation between total sleep time and self-reported daytime functioning score (\\(r\\) = 0.67, \\(t(48)\\) = 6.24, \\(p &lt; .001\\)) in the current sample. As total sleep time increased, levels of self-reported daytime functioning increased.\n\n\n\n\n\nQuestion 4 (open-ended)\n\n\nThink about this relationship in terms of causation.\n Claim: Less sleep causes poorer daytime functioning.\n Why might it be inappropriate to make the claim above based on these data alone? Think about what sort of study could provide stronger evidence for such a claim.\n\n\n\n\n\n\nThings to think about:\n\n\n\n\n\n\ncomparison groups.\n\nrandom allocation.\n\nmeasures of daytime functioning.\n\nmeasures of sleep time.\n\nother (unmeasured) explanatory variables.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData: Education SIMD Indicators\nThe Scottish Government regularly collates data across a wide range of societal, geographic, and health indicators for every “datazone” (small area) in Scotland.\nThe dataset at https://uoepsy.github.io/data/simd20_educ.csv contains some of the education indicators (see Table 2).\n\n\n\n\n\n\nTable 2:  Education indicators from the 2020 SIMD data \n  \n    \n      variable\n      description\n    \n  \n  \n    intermediate_zone\nAreas of scotland containing populations of between 2.5k-6k household residents\n    attendance\nAverage School pupil attendance\n    attainment\nAverage attainment score of School leavers (based on Scottish Credit and Qualifications Framework (SCQF))\n    university\nProportion of 17-21 year olds entering university\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 5\n\n\nConduct a test of whether there is a correlation between school attendance and school attainment in Scotland.\nPresent and write up the results.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThe readings have not included an example write-up for you to follow. Try to follow the logic of those for t-tests and \\(\\chi^2\\)-tests.\n\ndescribe the relevant data\nexplain what test was conducted and why\npresent the relevant statistic, degrees of freedom (if applicable), statement on p-value, etc.\nstate the conclusion.\n\nBe careful figuring out how many observations your test is conducted on. cor.test() includes only the complete observations.\n\n\n\n\n\n\n\n\nsimd &lt;- read_csv(\"https://uoepsy.github.io/data/simd20_educ.csv\")\n\nHere are the means of the two variables. We should remember that these calculations will include some observations which have missing data on the other variable.\n\nsimd |&gt; \n  summarise(\n    m_attendance = mean(attendance, na.rm = TRUE),\n    m_attainment = mean(attainment, na.rm = TRUE)\n)\n\n# A tibble: 1 × 2\n  m_attendance m_attainment\n         &lt;dbl&gt;        &lt;dbl&gt;\n1        0.811         5.53\n\n\nInstead, to match with our analysis, we might be inclined to filter our data to complete data:\n\nsimd_comp &lt;- simd |&gt; \n  filter(!is.na(attendance) & !is.na(attainment))\n\nsimd_comp |&gt;\n  summarise(\n    m_attendance = mean(attendance),\n    m_attainment = mean(attainment),\n    sd_attendance = sd(attendance),\n    sd_attainment = sd(attainment)\n)\n\n# A tibble: 1 × 4\n  m_attendance m_attainment sd_attendance sd_attainment\n         &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1        0.811         5.53        0.0696         0.386\n\n\n\ncor.test(simd_comp$attendance, simd_comp$attainment)\n\n\n    Pearson's product-moment correlation\n\ndata:  simd_comp$attendance and simd_comp$attainment\nt = 51.495, df = 1242, p-value &lt; 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.8066637 0.8421951\nsample estimates:\n      cor \n0.8252442 \n\n\n\nA correlation test was conducted to assess whether there is a relationship between an area’s average school attendance, and its average school attainment level. A total of 1244 geographical areas were included in the analysis, with a mean school attendance of 0.81 (SD = 0.07) and a mean school attainment score of 5.53 (SD = 0.39).\nThere was a strong positive correlation between a geographical area’s level of school attendance and its school attainment (\\(r\\) = 0.83, \\(t(1242)\\) = 51.5, \\(p &lt; 0.001\\)). We therefore reject the null hypothesis that there is no correlation between an area’s school attendance and attainment. Figure 1 provides a visualisation of the relationship.\n\n\nCode\nggplot(simd_comp, aes(x=attendance, y=attainment)) + \n  geom_point() + \n  labs(x = \"School attendance\",\n       y = \"School attainment\")\n\n\n\n\n\nFigure 1: Positive relationship between geographical areas’ level of school attendance and school attainment\n\n\n\n\n\n\n\n\n\n\n\nOptional: some extra plotting bits\n\n\n\n\n\nSometimes we may want to highlight certain parts of a plot. We can do that using the gghighlight package, and giving it a set of conditions (like we do for filter()) in order for it to decide which points to highlight.\nYou can see an example below.\nWe have also created the title by referring to the cor() function, and ’paste’ing it together to “r =”\n\nlibrary(gghighlight)\n\nggplot(simd_comp, aes(x=attendance, y=attainment)) + \n  geom_point() + \n  gghighlight( (attainment&gt;6 & attendance&lt;.75) | \n               attendance &gt; .95 | \n               (attendance &gt; .82 & attainment&lt;5),\n               label_key = intermediate_zone) + \n  labs(x = \"School attendance\",\n       y = \"School attainment\",\n       title = paste0(\"r = \",\n                       round(\n                         cor(simd_comp$attendance,\n                                  simd_comp$attainment),\n                         2)\n                       ))"
  },
  {
    "objectID": "05_ex.html#sleepy-time",
    "href": "05_ex.html#sleepy-time",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "",
    "text": "Data: Sleep levels and daytime functioning\nA researcher is interested in the relationship between hours slept per night and self-rated effects of sleep on daytime functioning. She recruited 50 healthy adults, and collected data on the Total Sleep Time (TST) over the course of a seven day period via sleep-tracking devices.\nAt the end of the seven day period, participants completed a Daytime Functioning (DTF) questionnaire. This involved participants rating their agreement with ten statements (see Table 1). Agreement was measured on a scale from 1-5. An overall score of daytime functioning can be calculated by:\n\nreversing the scores for items 4,5 and 6 (because those items reflect agreement with positive statements, whereas the other ones are agreement with negative statement);\nsumming the scores on each item; and\nsubtracting the sum score from 50 (the max possible score). This will make higher scores reflect better perceived daytime functioning.\n\nThe data is available at https://uoepsy.github.io/data/sleepdtf.csv.\n\n\n\n\n\n\nTable 1:  Daytime Functioning Questionnaire \n  \n    \n      Item\n      Statement\n    \n  \n  \n    Item_1\nI often felt an inability to concentrate\n    Item_2\nI frequently forgot things\n    Item_3\nI found thinking clearly required a lot of effort\n    Item_4\nI often felt happy\n    Item_5\nI had lots of energy\n    Item_6\nI worked efficiently\n    Item_7\nI often felt irritable\n    Item_8\nI often felt stressed\n    Item_9\nI often felt sleepy\n    Item_10\nI often felt fatigued\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 2\n\n\nLoad the required libraries (probably just tidyverse for now), and read in the data.\nCalculate the overall daytime functioning score, following the criteria outlined above, and make this a new column in your dataset.\n\n\n\n\n\n\nHints\n\n\n\n\n\nTo reverse items 4, 5 and 6, we we need to make all the scores of 1 become 5, scores of 2 become 4, and so on… What number satisfies all of these equations: ? - 5 = 1, ? - 4 = 2, ? - 3 = 3?\nTo quickly sum across rows, you might find the rowSums() function useful (you don’t have to use it though)\nIf my items were in columns between 4 to 15:\n\ndataframe$sumscore = rowSums(dataframe[, 4:15])\n\n\n\n\n\n\n\n\n\nSolution Part 1 - Reversing Items\n\n\n\n\nsleepdtf &lt;- read_csv(\"https://uoepsy.github.io/data/sleepdtf.csv\")\nsummary(sleepdtf)\n\n      TST             item_1         item_2         item_3         item_4    \n Min.   : 4.900   Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.00  \n 1st Qu.: 7.225   1st Qu.:1.00   1st Qu.:2.00   1st Qu.:1.25   1st Qu.:1.00  \n Median : 7.900   Median :1.00   Median :2.00   Median :2.00   Median :1.00  \n Mean   : 8.004   Mean   :1.58   Mean   :2.46   Mean   :2.38   Mean   :1.26  \n 3rd Qu.: 9.025   3rd Qu.:2.00   3rd Qu.:3.00   3rd Qu.:3.00   3rd Qu.:1.00  \n Max.   :11.200   Max.   :3.00   Max.   :5.00   Max.   :5.00   Max.   :3.00  \n     item_5         item_6         item_7         item_8        item_9    \n Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.0   Min.   :1.00  \n 1st Qu.:2.00   1st Qu.:2.00   1st Qu.:1.00   1st Qu.:2.0   1st Qu.:2.00  \n Median :2.00   Median :3.00   Median :2.00   Median :2.5   Median :3.00  \n Mean   :2.36   Mean   :2.78   Mean   :2.04   Mean   :2.5   Mean   :2.96  \n 3rd Qu.:3.00   3rd Qu.:4.00   3rd Qu.:3.00   3rd Qu.:3.0   3rd Qu.:4.00  \n Max.   :4.00   Max.   :5.00   Max.   :4.00   Max.   :4.0   Max.   :5.00  \n    item_10    \n Min.   :1.00  \n 1st Qu.:2.00  \n Median :3.00  \n Mean   :2.54  \n 3rd Qu.:3.00  \n Max.   :5.00  \n\n\nTo reverse the items, we can simply do 6 minus the score:\n\nsleepdtf &lt;- \n  sleepdtf |&gt; mutate(\n    item_4=6-item_4,\n    item_5=6-item_5,\n    item_6=6-item_6\n  ) \n\n\n\n\n\n\nSolution Part 2 - Creating a scale score\n\n\n\nNow we can use rowSums(), and subtract the sum scores from from 50 (the max score):\n\nsleepdtf$dtf = 50-rowSums(sleepdtf[, 2:11])\n\nAn alternative way to do this would be:\n\nsleepdtf |&gt; \n  mutate(\n    dtf = 50 - (item_1 + item_2 + item_3 + item_4 + item_5 + item_6 + item_7 + item_8 + item_9 + item_10)\n  )\n\n\n\n\n\nQuestion 3\n\n\nCalculate the correlation between the total sleep time (TST) and the overall daytime functioning score calculated in the previous question.\nConduct a test to establish the probability of observing a correlation this strong in a sample of this size assuming the true correlation to be 0.\nWrite a sentence or two summarising the results.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou can do this all with one function, see 5A #correlation-test.\n\n\n\n\n\n\n\n\ncor.test(sleepdtf$TST, sleepdtf$dtf)\n\n\n    Pearson's product-moment correlation\n\ndata:  sleepdtf$TST and sleepdtf$dtf\nt = 6.244, df = 48, p-value = 1.062e-07\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.4807039 0.7989417\nsample estimates:\n      cor \n0.6694741 \n\n\n\nThere was a strong positive correlation between total sleep time and self-reported daytime functioning score (\\(r\\) = 0.67, \\(t(48)\\) = 6.24, \\(p &lt; .001\\)) in the current sample. As total sleep time increased, levels of self-reported daytime functioning increased.\n\n\n\n\n\nQuestion 4 (open-ended)\n\n\nThink about this relationship in terms of causation.\n Claim: Less sleep causes poorer daytime functioning.\n Why might it be inappropriate to make the claim above based on these data alone? Think about what sort of study could provide stronger evidence for such a claim.\n\n\n\n\n\n\nThings to think about:\n\n\n\n\n\n\ncomparison groups.\n\nrandom allocation.\n\nmeasures of daytime functioning.\n\nmeasures of sleep time.\n\nother (unmeasured) explanatory variables."
  },
  {
    "objectID": "05_ex.html#attendance-and-attainment",
    "href": "05_ex.html#attendance-and-attainment",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "",
    "text": "Data: Education SIMD Indicators\nThe Scottish Government regularly collates data across a wide range of societal, geographic, and health indicators for every “datazone” (small area) in Scotland.\nThe dataset at https://uoepsy.github.io/data/simd20_educ.csv contains some of the education indicators (see Table 2).\n\n\n\n\n\n\nTable 2:  Education indicators from the 2020 SIMD data \n  \n    \n      variable\n      description\n    \n  \n  \n    intermediate_zone\nAreas of scotland containing populations of between 2.5k-6k household residents\n    attendance\nAverage School pupil attendance\n    attainment\nAverage attainment score of School leavers (based on Scottish Credit and Qualifications Framework (SCQF))\n    university\nProportion of 17-21 year olds entering university\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 5\n\n\nConduct a test of whether there is a correlation between school attendance and school attainment in Scotland.\nPresent and write up the results.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThe readings have not included an example write-up for you to follow. Try to follow the logic of those for t-tests and \\(\\chi^2\\)-tests.\n\ndescribe the relevant data\nexplain what test was conducted and why\npresent the relevant statistic, degrees of freedom (if applicable), statement on p-value, etc.\nstate the conclusion.\n\nBe careful figuring out how many observations your test is conducted on. cor.test() includes only the complete observations.\n\n\n\n\n\n\n\n\nsimd &lt;- read_csv(\"https://uoepsy.github.io/data/simd20_educ.csv\")\n\nHere are the means of the two variables. We should remember that these calculations will include some observations which have missing data on the other variable.\n\nsimd |&gt; \n  summarise(\n    m_attendance = mean(attendance, na.rm = TRUE),\n    m_attainment = mean(attainment, na.rm = TRUE)\n)\n\n# A tibble: 1 × 2\n  m_attendance m_attainment\n         &lt;dbl&gt;        &lt;dbl&gt;\n1        0.811         5.53\n\n\nInstead, to match with our analysis, we might be inclined to filter our data to complete data:\n\nsimd_comp &lt;- simd |&gt; \n  filter(!is.na(attendance) & !is.na(attainment))\n\nsimd_comp |&gt;\n  summarise(\n    m_attendance = mean(attendance),\n    m_attainment = mean(attainment),\n    sd_attendance = sd(attendance),\n    sd_attainment = sd(attainment)\n)\n\n# A tibble: 1 × 4\n  m_attendance m_attainment sd_attendance sd_attainment\n         &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1        0.811         5.53        0.0696         0.386\n\n\n\ncor.test(simd_comp$attendance, simd_comp$attainment)\n\n\n    Pearson's product-moment correlation\n\ndata:  simd_comp$attendance and simd_comp$attainment\nt = 51.495, df = 1242, p-value &lt; 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.8066637 0.8421951\nsample estimates:\n      cor \n0.8252442 \n\n\n\nA correlation test was conducted to assess whether there is a relationship between an area’s average school attendance, and its average school attainment level. A total of 1244 geographical areas were included in the analysis, with a mean school attendance of 0.81 (SD = 0.07) and a mean school attainment score of 5.53 (SD = 0.39).\nThere was a strong positive correlation between a geographical area’s level of school attendance and its school attainment (\\(r\\) = 0.83, \\(t(1242)\\) = 51.5, \\(p &lt; 0.001\\)). We therefore reject the null hypothesis that there is no correlation between an area’s school attendance and attainment. Figure 1 provides a visualisation of the relationship.\n\n\nCode\nggplot(simd_comp, aes(x=attendance, y=attainment)) + \n  geom_point() + \n  labs(x = \"School attendance\",\n       y = \"School attainment\")\n\n\n\n\n\nFigure 1: Positive relationship between geographical areas’ level of school attendance and school attainment\n\n\n\n\n\n\n\n\n\n\n\nOptional: some extra plotting bits\n\n\n\n\n\nSometimes we may want to highlight certain parts of a plot. We can do that using the gghighlight package, and giving it a set of conditions (like we do for filter()) in order for it to decide which points to highlight.\nYou can see an example below.\nWe have also created the title by referring to the cor() function, and ’paste’ing it together to “r =”\n\nlibrary(gghighlight)\n\nggplot(simd_comp, aes(x=attendance, y=attainment)) + \n  geom_point() + \n  gghighlight( (attainment&gt;6 & attendance&lt;.75) | \n               attendance &gt; .95 | \n               (attendance &gt; .82 & attainment&lt;5),\n               label_key = intermediate_zone) + \n  labs(x = \"School attendance\",\n       y = \"School attainment\",\n       title = paste0(\"r = \",\n                       round(\n                         cor(simd_comp$attendance,\n                                  simd_comp$attainment),\n                         2)\n                       ))"
  },
  {
    "objectID": "05_ex.html#monkey-exploration",
    "href": "05_ex.html#monkey-exploration",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "Monkey Exploration",
    "text": "Monkey Exploration\n\nData: monkeyexplorers.csv\nLiu, Hajnosz & Li (2023)1 have conducted a study on monkeys! They were interested in whether younger monkeys tend to be more inquisitive about new things than older monkeys do. They sampled 108 monkeys ranging from 1 to 24 years old. Each monkey was given a novel object, the researchers recorded the time (in minutes) that each monkey spent exploring the object.\nFor this week, we’re going to be investigating the research question:\n\nDo older monkeys spend more/less time exploring novel objects?\n\nThe data is available at https://uoepsy.github.io/data/monkeyexplorers.csv and contains the variables described in Table 3\n\n\n\n\n\n\nTable 3:  Data dictionary for monkeyexplorers.csv \n  \n    \n      variable\n      description\n    \n  \n  \n    name\nMonkey Name\n    age\nAge of monkey in years\n    exploration_time\nTime (in minutes) spent exploring the object\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 6\n\n\nFor this week, we’re going to be investigating the following research question:\n\nDo older monkeys spend more/less time exploring novel objects?\n\nRead in the data to your R session, then visualise and describe the marginal distributions of those variables which are of interest to us. These are the distribution of each variable (time spent exploring, and monkey age) without reference to the values of the other variables.\n\n\n\n\n\n\nHints\n\n\n\n\n\n\nYou could use, for example, geom_density() for a density plot or geom_histogram() for a histogram.\nLook at the shape, center and spread of the distribution. Is it symmetric or skewed? Is it unimodal or bimodal?\nDo you notice any extreme observations?\n\n\n\n\n\n\n\n\n\nmonkeyexp &lt;- read_csv(\"https://uoepsy.github.io/data/monkeyexplorers.csv\")\nhead(monkeyexp)\n\n# A tibble: 6 × 3\n  name            age exploration_time\n  &lt;chr&gt;         &lt;dbl&gt;            &lt;dbl&gt;\n1 Ed Sheeran        8             13.1\n2 Vince Gill       17              6.8\n3 Jewel            13             12.8\n4 Jaden Smith      18              8.9\n5 Reba McEntire    16              1.1\n6 Metallica        13              5.7\n\n\nWe can plot the marginal distribution of these two continuous variables as density curves, and add a boxplot underneath to check for the presence of outliers. The width of the geom_boxplot() is always quite wide, so I want to make it narrower so that we can see it at the same time as the density plot. Deciding on the exact value for the width here is just trial and error:\n\nlibrary(patchwork)\n# the patchwork library allows us to combine plots together\nggplot(data = monkeyexp, aes(x = age)) +\n  geom_density() +\n  geom_boxplot(width = 1/300) +\n  labs(x = \"Age (in years)\", \n       y = \"Probability density\") +\n\nggplot(data = monkeyexp, aes(x = exploration_time)) +\n  geom_density() +\n  geom_boxplot(width = 1/175) +\n  labs(x = \"Time spent exploring a\\n novel object (in minutes)\", \n       y = \"Probability density\")\n\n\n\n\nFigure 2: Density plot and boxplot of monkey’s age and their time spent exploring novel objects\n\n\n\n\nThe plots suggests that the distributions of monkeys’ ages and the time they spend exploring novel objects are both unimodal. Most of the monkeys are between roughly 8 and 18 years old, and most of them spent between 7 and 12 minutes exploring the objects. The boxplots suggest an outlier in the distribution of exploration-times, with one monkeys spending more than \\(1.5 \\times IQR\\) beyond the 3rd quartile.\nTo further summarize a distribution, it is typical to compute and report numerical summary statistics such as the mean and standard deviation.\nAs we have seen, in earlier weeks, one way to compute these values is to use the summarise()/summarize() function from the tidyverse library:\n\nmonkeyexp |&gt; \n  summarize(\n    mean_age = mean(age), \n    sd_age = sd(age),\n    mean_exptime = mean(exploration_time),\n    sd_exptime = sd(exploration_time)\n    )\n\n# A tibble: 1 × 4\n  mean_age sd_age mean_exptime sd_exptime\n     &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;\n1     13.5   5.92         9.40       4.50\n\n\n\nThe marginal distribution of age is unimodal with a mean of 13.5 years, and a standard deviation of 5.9.\nThe marginal distribution of time-spent-exploring is unimodal with a mean of 9.4 years, and a standard deviation of 4.5.\n\n\n\n\n\nQuestion 7\n\n\nAfter we’ve looked at the marginal distributions of the variables of interest in the analysis, we typically move on to examining relationships between the variables.\nVisualise and describe the relationship between age and exploration-time among the monkeys in the sample.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThink about:\n\nDirection of association\nForm of association (can it be summarised well with a straight line?)\n\nStrength of association (how closely do points fall to a recognizable pattern such as a line?)\nUnusual observations that do not fit the pattern of the rest of the observations and which are worth examining in more detail.\n\n\n\n\n\n\n\n\n\nBecause we are investigating how time-spent-exploring varies with monkeys’ ages, the exploration-time here is the dependent variable (on the y-axis), and age is the independent variable (on the x-axis).\n\nggplot(data = monkeyexp, aes(x = age, y = exploration_time)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"Age (in years)\", \n       y = \"Time spent exploring a\\n novel object (in minutes)\")\n\n\n\n\nFigure 3: The relationship between monkeys’ age and time-spent-exploring.\n\n\n\n\nThere appears to be a moderate negative linear relationship between age and exploration time in these monkeys. Older monkeys appear to spend less time, on average, exploring a novel object. The scatterplot does highlight that there is one one young monkey who is behaving a bit weirdly, and spent quite a long time exploring the object!\nTo comment numerically on the strength of the linear association we might compute the correlation coefficient that we were introduced to in 5A: Covariance & Correlation\n\nmonkeyexp |&gt;\n  select(age, exploration_time) |&gt;\n  cor()\n\n                        age exploration_time\nage               1.0000000       -0.2885495\nexploration_time -0.2885495        1.0000000\n\n\nthat is, \\(r_{\\text{age, exploration-time}} = -0.29\\)\n\n\n\n\nQuestion 8\n\n\nUsing the lm() function, fit a linear model to the sample data, in which time that monkeys spend exploring novel objects is explained by age. Assign it to a name to store it in your environment.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou can see how to fit linear models in R using lm() in 5B #fitting-linear-models-in-r\n\n\n\n\n\n\n\nAs the variables are in the monkeyexp dataframe, we would write:\n\nmodel1 &lt;- lm(exploration_time ~ 1 + age, data = monkeyexp)\n\n\n\n\n\nQuestion 9\n\n\nInterpret the estimated intercept and slope in the context of the question of interest.\n\n\n\n\n\n\nHints\n\n\n\n\n\nWe saw how to extract lots of information on our model using summary() (see 5B #model-summary), but there are lots of other functions too.\nIf we called our linear model object “model1” in the environment, then we can use:\n\ntype model1, i.e. simply invoke the name of the fitted model;\ntype model1$coefficients;\nuse the coef(model1) function;\nuse the coefficients(model1) function;\nuse the summary(model1)$coefficients to extract just that part of the summary.\n\n\n\n\n\n\n\n\n\ncoef(model1)\n\n(Intercept)         age \n   12.36253    -0.21897 \n\n\nFrom this, we get that the fitted line is: \\[\n\\widehat{\\text{ExplorationTime}} = 12.36 - 0.22 \\cdot \\text{Age} \\\\\n\\]\nWe can interpret the estimated intercept as:\n\nThe estimated average time spent exploring novel objects for a monkey of age zero is 12.36 minutes.\n\nFor the estimated slope we get:\n:::int A one year increase in age is associated with an estimated decrease of -0.22 minutes (or -13 seconds) that a monkey will spend exploring a novel object.\n\n\n\n\nQuestion 10\n\n\nTest the hypothesis that the population slope is zero — that is, that there is no linear association between exploration time and age in the population.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou don’t need to do anything for this, you can find all the necessary information in summary() of your model.\nSee 5B #inference-for-regression-coefficients.\n\n\n\n\n\n\n\nThe information is already contained in the row corresponding to the variable “age” in the output of summary(), which reports the t-statistic under t value and the p-value under Pr(&gt;|t|):\n\nsummary(model1)\n\n\nCall:\nlm(formula = exploration_time ~ 1 + age, data = monkeyexp)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-11.3056  -2.3461   0.3841   2.1936  21.8323 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 12.36253    1.04263  11.857  &lt; 2e-16 ***\nage         -0.21897    0.07057  -3.103  0.00246 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.324 on 106 degrees of freedom\nMultiple R-squared:  0.08326,   Adjusted R-squared:  0.07461 \nF-statistic: 9.627 on 1 and 106 DF,  p-value: 0.002458\n\n\nRecall that very small p-values such as the one for the intercept 2e-16 in the Pr(&gt;|t|) column simply means \\(2 \\times 10^{-16}\\), or 0.0000000000000002. Conventions such as the APA guidelines give rules on how to report these numbers (see, e.g. APA’s number and stats guide). For the p-values in this summary (the one for the intercept and the one for the slope) we could report them as “&lt;.001” and “0.003” respectively.\n\nA significant association was found between age (in years) and time spent exploring novel objects, with exploration time decreasing on average by -0.22 minutes (or -13 seconds) for every additional year of age (\\(b = -0.22\\), \\(SE = 0.071\\), \\(t(106)=-3.103\\), \\(p=.003\\)).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 13\n\n\nCreate a visualisation of the estimated association between age and exploration time.\n\n\n\n\n\n\nHints\n\n\n\n\n\nFor our simple regression model, there is a really easy way to do this with geom_smooth(). Check 5B #example, which shows an example.\n\n\n\n\n\n\n\n\nggplot(data = monkeyexp, aes(x = age, y = exploration_time)) +\n  geom_point(alpha = 0.5) +\n  geom_smooth(method=lm) +\n  labs(x = \"Age (in years)\", \n       y = \"Time spent exploring a\\n novel object (in minutes)\")\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 14 - Optional\n\n\nConsider the following:\n\nIn fitting a linear regression model, we make the assumption that the errors around the line are normally distributed around zero (this is the \\(\\epsilon \\sim N(0, \\sigma)\\) bit.)\n\nAbout 95% of values from a normal distribution fall within two standard deviations of the centre.\n\nWe can obtain the estimated standard deviation of the errors (\\(\\hat \\sigma\\)) from the fitted model using sigma() and giving it the name of our model.\nWhat does this tell us?\n\n\n\n\n\n\nHints\n\n\n\n\n\nSee 5B #the-error.\n\n\n\n\n\n\n\nThe estimated standard deviation of the errors can be obtained by:\n\nsigma(model1)\n\n[1] 4.324399\n\n\nFor any particular age, the time monkeys spend exploring novel objects is estimated as being distributed above and below the regression line with a standard deviation of \\(\\hat \\sigma = 4.32\\). Since \\(1.96 \\hat \\sigma = 1.96 \\times 4.32 = \\text{approx} 8.6\\), we would expect most (about 95%) of the monkeys’ exploration times to be within about 8.6 minutes from the regression line.\n\n\n\n\nQuestion 15 - Optional\n\n\nCompute the model-predicted exploration-time for a monkey that is 1 year old.\n\n\n\n\n\n\nHints\n\n\n\n\n\nGiven that you know the intercept and slope, you can calculate this algebraically. However, try to also use the predict() function (see 5B #model-predictions).\n\n\n\n\n\n\n\nUsing predict(), we need to give it our model, plus some new data which contains a monkey that has 1 in the age column. First we make a new dataframe with an age variable, with one entry which has the value 1, and then we give that to predict():\n\nage_query &lt;- data.frame(age = c(1))\npredict(model1, newdata = age_query)\n\n       1 \n12.14356 \n\n\nGiven that our fitted model takes the form:\n\\[\n\\widehat{\\text{ExplorationTime}} = 12.36 - 0.22 \\cdot \\text{Age}\n\\]\nWe are asking what the predicted exploration time is for a monkey with 1 year of age. So we can substitute in “1” for the Age variable: \\[\n\\begin{align}\n\\text{ExplorationTime} &= 12.36 - 0.22 \\cdot \\text{Age} \\\\\n\\text{ExplorationTime} &= 12.36 - 0.22 \\cdot 1 \\\\\n\\text{ExplorationTime} &= 12.36 - 0.22\\\\\n\\text{ExplorationTime} &= 12.14\\\\\n\\end{align}\n\\]\n\n\n\n\n\n\n\nInfluential Monkeys\n\nQuestion 16\n\n\nTake a look at the assumption plots (see 5B #assumptions) for your model.\n\nThe trick to looking at assumption plots in linear regression is to look for “things that don’t look random”.\nAs well as looking for patterns, these plots can also higlight individual datapoints that might be skewing the results. Can you figure out if there are any unusual monkeys in our dataset? Can you re-fit the model without that monkey? When you do so, do your conclusions change?\n\n\n\n\n\n\nplot(model1)\n\n\n\n\n\n\n\n\nFrom these plots, we can see that the 57th observation is looking a bit influential. It is the one datapoint that is looking weird in all of the plots.\nLet’s look at them:\n\nmonkeyexp[57, ]\n\n# A tibble: 1 × 3\n  name       age exploration_time\n  &lt;chr&gt;    &lt;dbl&gt;            &lt;dbl&gt;\n1 Lil Fizz     5             33.1\n\n\nThis is a young monkey (5 years old) called “Lil Fizz”, who seems to have spent quite a long time exploring the toy. It’s important to remember that this monkey is a valuable datapoint, despite being a bit different from the general pattern.\nHowever, it would be nice to know how much Lil Fizz is affecting our conclusions, so let’s re-fit the model on everybody except that one monkey\n\nmodel1a &lt;- lm(exploration_time ~ age, data = monkeyexp[-57, ])\nsummary(model1a)\n\n\nCall:\nlm(formula = exploration_time ~ age, data = monkeyexp[-57, ])\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-10.558  -2.321   0.427   2.386   9.884 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 11.46135    0.92155  12.437  &lt; 2e-16 ***\nage         -0.16781    0.06212  -2.701  0.00805 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.769 on 105 degrees of freedom\nMultiple R-squared:  0.06498,   Adjusted R-squared:  0.05608 \nF-statistic: 7.297 on 1 and 105 DF,  p-value: 0.008053\n\n\nOur conclusions haven’t changed - we still have a significant association.\nWhat we have just done is called a “sensitivity analysis” - we’ve asked if our analyses are sensitive to a specific decision we could make (whether or not we include/exclude this monkey).\n\n\nCode\nggplot(monkeyexp, aes(x=age,y=exploration_time))+\n  geom_point()+\n  geom_smooth(method=lm, fullrange=TRUE)+\n  ylim(0,34) + \n  labs(title=\"With monkey 57\") +\n\nggplot(monkeyexp[-57,], aes(x=age,y=exploration_time))+\n  geom_point()+\n  geom_smooth(method=lm, fullrange=TRUE)+\n  ylim(0,34) + \n  labs(title=\"Without monkey 57\")\n\n\n\n\n\n\n\n\n\nWe now have a decision to make. Do we continue with the monkey removed, or do we keep them in? There’s not really a right answer here, but it’s worth noting a practical issue - our assumption plots look considerably better for our model without this monkey.\nWhatever we do, when writing up the analysis we need to mention clearly if and why we exclude any observations, and how that decision has/hasn’t influenced our conclusions.\n\n\n\n\n\nMonkey Exploration in Adulthood\nLet’s suppose instead of having measured monkeys’ ages in years, researchers simply recorded whether each monkey was an adult or a juvenile (species like Capuchins and Rhesus Macaques reach adulthood at about 8 years old).\nThe code below creates a this new variable for us:\n\nmonkeyexp &lt;- monkeyexp |&gt; \n  mutate(\n    isAdult = ifelse(age &gt;= 8, \"yes\",\"no\")\n  )\n\n\nQuestion 17\n\n\nFit the following model, and interpret the coefficients.\n\\[\n\\text{ExplorationTime} = b_0 + b_1 \\cdot \\text{isAdult} + \\varepsilon\n\\]\n\n\n\n\n\n\nHints\n\n\n\n\n\nFor help interpreting the coefficients, see 5B #binary-predictors.\n\n\n\n\n\n\n\n\nmodel2 &lt;- lm(exploration_time ~ 1 + isAdult, data = monkeyexp)\nsummary(model2)\n\n\nCall:\nlm(formula = exploration_time ~ 1 + isAdult, data = monkeyexp)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-11.2556  -2.3694  -0.0444   2.5556  21.4444 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   11.656      1.037  11.239   &lt;2e-16 ***\nisAdultyes    -2.711      1.136  -2.386   0.0188 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.4 on 106 degrees of freedom\nMultiple R-squared:  0.05099,   Adjusted R-squared:  0.04204 \nF-statistic: 5.695 on 1 and 106 DF,  p-value: 0.01878\n\n\n\n(Intercept) = the estimated exploration time of juvenile monkeys (11.7 minutes)\nisAdultyes = the estimated change in exploration time from juvenile monkeys to adult monkeys (-2.7 minutes)\n\n\nggplot(monkeyexp, aes(x = isAdult, y = exploration_time)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 18\n\n\nWe’ve actually already seen a way to analyse questions of this sort (“is the average exploration-time different between juveniles and adults?”)\nRun the following t-test, and consider the statistic, p value etc. How does it compare to the model in the previous question?\n\nt.test(exploration_time ~ isAdult, data = monkeyexp, var.equal = TRUE)\n\n\n\n\n\n\nt.test(exploration_time ~ isAdult, data = monkeyexp, var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  exploration_time by isAdult\nt = 2.3865, df = 106, p-value = 0.01878\nalternative hypothesis: true difference in means between group no and group yes is not equal to 0\n95 percent confidence interval:\n 0.4588049 4.9634174\nsample estimates:\n mean in group no mean in group yes \n        11.655556          8.944444 \n\n\nIt is identical! the \\(t\\)-statistics are the same, the p-values are the same, the degrees of freedom. Everything!\nThe two sample t-test is actually just a special case of the linear model, where we have a numeric outcome variable and a binary predictor!\nAnd… the one-sample t-test is the linear model without any predictors, so just with an intercept.\n\nt.test(monkeyexp$exploration_time, mu = 0)\n\n\n    One Sample t-test\n\ndata:  monkeyexp$exploration_time\nt = 21.722, df = 107, p-value &lt; 2.2e-16\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n  8.538785 10.253807\nsample estimates:\nmean of x \n 9.396296 \n\ninterceptonly_model &lt;- lm(exploration_time ~ 1, data = monkeyexp)\n\nsummary(interceptonly_model)$coefficients\n\n            Estimate Std. Error  t value     Pr(&gt;|t|)\n(Intercept) 9.396296  0.4325657 21.72224 5.060938e-41"
  },
  {
    "objectID": "05_ex.html#footnotes",
    "href": "05_ex.html#footnotes",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNot a real study!↩︎"
  },
  {
    "objectID": "05_exMANGO.html",
    "href": "05_exMANGO.html",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "",
    "text": "Question 1\n\n\nGo to http://guessthecorrelation.com/ and play the “guess the correlation” game for a little while to get an idea of what different strengths and directions of \\(r\\) can look like.\n\n\n\n\n\n\nData: Sleep levels and daytime functioning\nA researcher is interested in the relationship between hours slept per night and self-rated effects of sleep on daytime functioning. She recruited 50 healthy adults, and collected data on the Total Sleep Time (TST) over the course of a seven day period via sleep-tracking devices.\nAt the end of the seven day period, participants completed a Daytime Functioning (DTF) questionnaire. This involved participants rating their agreement with ten statements (see Table 1). Agreement was measured on a scale from 1-5. An overall score of daytime functioning can be calculated by:\n\nreversing the scores for items 4,5 and 6 (because those items reflect agreement with positive statements, whereas the other ones are agreement with negative statement);\nsumming the scores on each item; and\nsubtracting the sum score from 50 (the max possible score). This will make higher scores reflect better perceived daytime functioning.\n\nThe data is available at https://uoepsy.github.io/data/sleepdtf.csv.\n\n\n\n\n\n\nTable 1:  Daytime Functioning Questionnaire \n  \n    \n      Item\n      Statement\n    \n  \n  \n    Item_1\nI often felt an inability to concentrate\n    Item_2\nI frequently forgot things\n    Item_3\nI found thinking clearly required a lot of effort\n    Item_4\nI often felt happy\n    Item_5\nI had lots of energy\n    Item_6\nI worked efficiently\n    Item_7\nI often felt irritable\n    Item_8\nI often felt stressed\n    Item_9\nI often felt sleepy\n    Item_10\nI often felt fatigued\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 2\n\n\nLoad the required libraries (probably just tidyverse for now), and read in the data.\nCalculate the overall daytime functioning score, following the criteria outlined above, and make this a new column in your dataset.\n\n\n\n\n\n\nHints\n\n\n\n\n\nTo reverse items 4, 5 and 6, we we need to make all the scores of 1 become 5, scores of 2 become 4, and so on… What number satisfies all of these equations: ? - 5 = 1, ? - 4 = 2, ? - 3 = 3?\nTo quickly sum across rows, you might find the rowSums() function useful (you don’t have to use it though)\nIf my items were in columns between 4 to 15:\n\ndataframe$sumscore = rowSums(dataframe[, 4:15])\n\n\n\n\n\n\n\n\n\nSolution Part 1 - Reversing Items\n\n\n\n\nsleepdtf &lt;- read_csv(\"https://uoepsy.github.io/data/sleepdtf.csv\")\nsummary(sleepdtf)\n\n      TST             item_1         item_2         item_3         item_4    \n Min.   : 4.900   Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.00  \n 1st Qu.: 7.225   1st Qu.:1.00   1st Qu.:2.00   1st Qu.:1.25   1st Qu.:1.00  \n Median : 7.900   Median :1.00   Median :2.00   Median :2.00   Median :1.00  \n Mean   : 8.004   Mean   :1.58   Mean   :2.46   Mean   :2.38   Mean   :1.26  \n 3rd Qu.: 9.025   3rd Qu.:2.00   3rd Qu.:3.00   3rd Qu.:3.00   3rd Qu.:1.00  \n Max.   :11.200   Max.   :3.00   Max.   :5.00   Max.   :5.00   Max.   :3.00  \n     item_5         item_6         item_7         item_8        item_9    \n Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.0   Min.   :1.00  \n 1st Qu.:2.00   1st Qu.:2.00   1st Qu.:1.00   1st Qu.:2.0   1st Qu.:2.00  \n Median :2.00   Median :3.00   Median :2.00   Median :2.5   Median :3.00  \n Mean   :2.36   Mean   :2.78   Mean   :2.04   Mean   :2.5   Mean   :2.96  \n 3rd Qu.:3.00   3rd Qu.:4.00   3rd Qu.:3.00   3rd Qu.:3.0   3rd Qu.:4.00  \n Max.   :4.00   Max.   :5.00   Max.   :4.00   Max.   :4.0   Max.   :5.00  \n    item_10    \n Min.   :1.00  \n 1st Qu.:2.00  \n Median :3.00  \n Mean   :2.54  \n 3rd Qu.:3.00  \n Max.   :5.00  \n\n\nTo reverse the items, we can simply do 6 minus the score:\n\nsleepdtf &lt;- \n  sleepdtf |&gt; mutate(\n    item_4=6-item_4,\n    item_5=6-item_5,\n    item_6=6-item_6\n  ) \n\n\n\n\n\n\nSolution Part 2 - Creating a scale score\n\n\n\nNow we can use rowSums(), and subtract the sum scores from from 50 (the max score):\n\nsleepdtf$dtf = 50-rowSums(sleepdtf[, 2:11])\n\nAn alternative way to do this would be:\n\nsleepdtf |&gt; \n  mutate(\n    dtf = 50 - (item_1 + item_2 + item_3 + item_4 + item_5 + item_6 + item_7 + item_8 + item_9 + item_10)\n  )\n\n\n\n\n\nQuestion 3\n\n\nCalculate the correlation between the total sleep time (TST) and the overall daytime functioning score calculated in the previous question.\nConduct a test to establish the probability of observing a correlation this strong in a sample of this size assuming the true correlation to be 0.\nWrite a sentence or two summarising the results.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou can do this all with one function, see 5A #correlation-test.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\ncor.test(sleepdtf$TST, sleepdtf$dtf)\n\n\n    Pearson's product-moment correlation\n\ndata:  sleepdtf$TST and sleepdtf$dtf\nt = 6.244, df = 48, p-value = 1.062e-07\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.4807039 0.7989417\nsample estimates:\n      cor \n0.6694741 \n\n\n\nThere was a strong positive correlation between total sleep time and self-reported daytime functioning score (\\(r\\) = 0.67, \\(t(48)\\) = 6.24, \\(p &lt; .001\\)) in the current sample. As total sleep time increased, levels of self-reported daytime functioning increased.\n\n\n\n\n\nQuestion 4 (open-ended)\n\n\nThink about this relationship in terms of causation.\n Claim: Less sleep causes poorer daytime functioning.\n Why might it be inappropriate to make the claim above based on these data alone? Think about what sort of study could provide stronger evidence for such a claim.\n\n\n\n\n\n\nThings to think about:\n\n\n\n\n\n\ncomparison groups.\n\nrandom allocation.\n\nmeasures of daytime functioning.\n\nmeasures of sleep time.\n\nother (unmeasured) explanatory variables.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData: Education SIMD Indicators\nThe Scottish Government regularly collates data across a wide range of societal, geographic, and health indicators for every “datazone” (small area) in Scotland.\nThe dataset at https://uoepsy.github.io/data/simd20_educ.csv contains some of the education indicators (see Table 2).\n\n\n\n\n\n\nTable 2:  Education indicators from the 2020 SIMD data \n  \n    \n      variable\n      description\n    \n  \n  \n    intermediate_zone\nAreas of scotland containing populations of between 2.5k-6k household residents\n    attendance\nAverage School pupil attendance\n    attainment\nAverage attainment score of School leavers (based on Scottish Credit and Qualifications Framework (SCQF))\n    university\nProportion of 17-21 year olds entering university\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 5\n\n\nConduct a test of whether there is a correlation between school attendance and school attainment in Scotland.\nPresent and write up the results.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThe readings have not included an example write-up for you to follow. Try to follow the logic of those for t-tests and \\(\\chi^2\\)-tests.\n\ndescribe the relevant data\nexplain what test was conducted and why\npresent the relevant statistic, degrees of freedom (if applicable), statement on p-value, etc.\nstate the conclusion.\n\nBe careful figuring out how many observations your test is conducted on. cor.test() includes only the complete observations.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nsimd &lt;- read_csv(\"https://uoepsy.github.io/data/simd20_educ.csv\")\n\nHere are the means of the two variables. We should remember that these calculations will include some observations which have missing data on the other variable.\n\nsimd |&gt; \n  summarise(\n    m_attendance = mean(attendance, na.rm = TRUE),\n    m_attainment = mean(attainment, na.rm = TRUE)\n)\n\n# A tibble: 1 × 2\n  m_attendance m_attainment\n         &lt;dbl&gt;        &lt;dbl&gt;\n1        0.811         5.53\n\n\nInstead, to match with our analysis, we might be inclined to filter our data to complete data:\n\nsimd_comp &lt;- simd |&gt; \n  filter(!is.na(attendance) & !is.na(attainment))\n\nsimd_comp |&gt;\n  summarise(\n    m_attendance = mean(attendance),\n    m_attainment = mean(attainment),\n    sd_attendance = sd(attendance),\n    sd_attainment = sd(attainment)\n)\n\n# A tibble: 1 × 4\n  m_attendance m_attainment sd_attendance sd_attainment\n         &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1        0.811         5.53        0.0696         0.386\n\n\n\ncor.test(simd_comp$attendance, simd_comp$attainment)\n\n\n    Pearson's product-moment correlation\n\ndata:  simd_comp$attendance and simd_comp$attainment\nt = 51.495, df = 1242, p-value &lt; 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.8066637 0.8421951\nsample estimates:\n      cor \n0.8252442 \n\n\n\nA correlation test was conducted to assess whether there is a relationship between an area’s average school attendance, and its average school attainment level. A total of 1244 geographical areas were included in the analysis, with a mean school attendance of 0.81 (SD = 0.07) and a mean school attainment score of 5.53 (SD = 0.39).\nThere was a strong positive correlation between a geographical area’s level of school attendance and its school attainment (\\(r\\) = 0.83, \\(t(1242\\) = 51.5, \\(p &lt; 0.001\\)). We therefore reject the null hypothesis that there is no correlation between an area’s school attendance and attainment. Figure 1 provides a visualisation of the relationship.\n\n\nCode\nggplot(simd_comp, aes(x=attendance, y=attainment)) + \n  geom_point() + \n  labs(x = \"School attendance\",\n       y = \"School attainment\")\n\n\n\n\n\nFigure 1: Positive relationship between geographical areas’ level of school attendance and school attainment\n\n\n\n\n\n\n\n\n\n\n\nOptional: some extra plotting bits\n\n\n\n\n\nSometimes we may want to highlight certain parts of a plot. We can do that using the gghighlight package, and giving it a set of conditions (like we do for filter()) in order for it to decide which points to highlight.\nYou can see an example below.\nWe have also created the title by referring to the cor() function, and ’paste’ing it together to “r =”\n\nlibrary(gghighlight)\n\nggplot(simd_comp, aes(x=attendance, y=attainment)) + \n  geom_point() + \n  gghighlight( (attainment&gt;6 & attendance&lt;.75) | \n               attendance &gt; .95 | \n               (attendance &gt; .82 & attainment&lt;5),\n               label_key = intermediate_zone) + \n  labs(x = \"School attendance\",\n       y = \"School attainment\",\n       title = paste0(\"r = \",\n                       round(\n                         cor(simd_comp$attendance,\n                                  simd_comp$attainment),\n                         2)\n                       ))"
  },
  {
    "objectID": "05_exMANGO.html#sleepy-time",
    "href": "05_exMANGO.html#sleepy-time",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "",
    "text": "Data: Sleep levels and daytime functioning\nA researcher is interested in the relationship between hours slept per night and self-rated effects of sleep on daytime functioning. She recruited 50 healthy adults, and collected data on the Total Sleep Time (TST) over the course of a seven day period via sleep-tracking devices.\nAt the end of the seven day period, participants completed a Daytime Functioning (DTF) questionnaire. This involved participants rating their agreement with ten statements (see Table 1). Agreement was measured on a scale from 1-5. An overall score of daytime functioning can be calculated by:\n\nreversing the scores for items 4,5 and 6 (because those items reflect agreement with positive statements, whereas the other ones are agreement with negative statement);\nsumming the scores on each item; and\nsubtracting the sum score from 50 (the max possible score). This will make higher scores reflect better perceived daytime functioning.\n\nThe data is available at https://uoepsy.github.io/data/sleepdtf.csv.\n\n\n\n\n\n\nTable 1:  Daytime Functioning Questionnaire \n  \n    \n      Item\n      Statement\n    \n  \n  \n    Item_1\nI often felt an inability to concentrate\n    Item_2\nI frequently forgot things\n    Item_3\nI found thinking clearly required a lot of effort\n    Item_4\nI often felt happy\n    Item_5\nI had lots of energy\n    Item_6\nI worked efficiently\n    Item_7\nI often felt irritable\n    Item_8\nI often felt stressed\n    Item_9\nI often felt sleepy\n    Item_10\nI often felt fatigued\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 2\n\n\nLoad the required libraries (probably just tidyverse for now), and read in the data.\nCalculate the overall daytime functioning score, following the criteria outlined above, and make this a new column in your dataset.\n\n\n\n\n\n\nHints\n\n\n\n\n\nTo reverse items 4, 5 and 6, we we need to make all the scores of 1 become 5, scores of 2 become 4, and so on… What number satisfies all of these equations: ? - 5 = 1, ? - 4 = 2, ? - 3 = 3?\nTo quickly sum across rows, you might find the rowSums() function useful (you don’t have to use it though)\nIf my items were in columns between 4 to 15:\n\ndataframe$sumscore = rowSums(dataframe[, 4:15])\n\n\n\n\n\n\n\n\n\nSolution Part 1 - Reversing Items\n\n\n\n\nsleepdtf &lt;- read_csv(\"https://uoepsy.github.io/data/sleepdtf.csv\")\nsummary(sleepdtf)\n\n      TST             item_1         item_2         item_3         item_4    \n Min.   : 4.900   Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.00  \n 1st Qu.: 7.225   1st Qu.:1.00   1st Qu.:2.00   1st Qu.:1.25   1st Qu.:1.00  \n Median : 7.900   Median :1.00   Median :2.00   Median :2.00   Median :1.00  \n Mean   : 8.004   Mean   :1.58   Mean   :2.46   Mean   :2.38   Mean   :1.26  \n 3rd Qu.: 9.025   3rd Qu.:2.00   3rd Qu.:3.00   3rd Qu.:3.00   3rd Qu.:1.00  \n Max.   :11.200   Max.   :3.00   Max.   :5.00   Max.   :5.00   Max.   :3.00  \n     item_5         item_6         item_7         item_8        item_9    \n Min.   :1.00   Min.   :1.00   Min.   :1.00   Min.   :1.0   Min.   :1.00  \n 1st Qu.:2.00   1st Qu.:2.00   1st Qu.:1.00   1st Qu.:2.0   1st Qu.:2.00  \n Median :2.00   Median :3.00   Median :2.00   Median :2.5   Median :3.00  \n Mean   :2.36   Mean   :2.78   Mean   :2.04   Mean   :2.5   Mean   :2.96  \n 3rd Qu.:3.00   3rd Qu.:4.00   3rd Qu.:3.00   3rd Qu.:3.0   3rd Qu.:4.00  \n Max.   :4.00   Max.   :5.00   Max.   :4.00   Max.   :4.0   Max.   :5.00  \n    item_10    \n Min.   :1.00  \n 1st Qu.:2.00  \n Median :3.00  \n Mean   :2.54  \n 3rd Qu.:3.00  \n Max.   :5.00  \n\n\nTo reverse the items, we can simply do 6 minus the score:\n\nsleepdtf &lt;- \n  sleepdtf |&gt; mutate(\n    item_4=6-item_4,\n    item_5=6-item_5,\n    item_6=6-item_6\n  ) \n\n\n\n\n\n\nSolution Part 2 - Creating a scale score\n\n\n\nNow we can use rowSums(), and subtract the sum scores from from 50 (the max score):\n\nsleepdtf$dtf = 50-rowSums(sleepdtf[, 2:11])\n\nAn alternative way to do this would be:\n\nsleepdtf |&gt; \n  mutate(\n    dtf = 50 - (item_1 + item_2 + item_3 + item_4 + item_5 + item_6 + item_7 + item_8 + item_9 + item_10)\n  )\n\n\n\n\n\nQuestion 3\n\n\nCalculate the correlation between the total sleep time (TST) and the overall daytime functioning score calculated in the previous question.\nConduct a test to establish the probability of observing a correlation this strong in a sample of this size assuming the true correlation to be 0.\nWrite a sentence or two summarising the results.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou can do this all with one function, see 5A #correlation-test.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\ncor.test(sleepdtf$TST, sleepdtf$dtf)\n\n\n    Pearson's product-moment correlation\n\ndata:  sleepdtf$TST and sleepdtf$dtf\nt = 6.244, df = 48, p-value = 1.062e-07\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.4807039 0.7989417\nsample estimates:\n      cor \n0.6694741 \n\n\n\nThere was a strong positive correlation between total sleep time and self-reported daytime functioning score (\\(r\\) = 0.67, \\(t(48)\\) = 6.24, \\(p &lt; .001\\)) in the current sample. As total sleep time increased, levels of self-reported daytime functioning increased.\n\n\n\n\n\nQuestion 4 (open-ended)\n\n\nThink about this relationship in terms of causation.\n Claim: Less sleep causes poorer daytime functioning.\n Why might it be inappropriate to make the claim above based on these data alone? Think about what sort of study could provide stronger evidence for such a claim.\n\n\n\n\n\n\nThings to think about:\n\n\n\n\n\n\ncomparison groups.\n\nrandom allocation.\n\nmeasures of daytime functioning.\n\nmeasures of sleep time.\n\nother (unmeasured) explanatory variables."
  },
  {
    "objectID": "05_exMANGO.html#attendance-and-attainment",
    "href": "05_exMANGO.html#attendance-and-attainment",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "",
    "text": "Data: Education SIMD Indicators\nThe Scottish Government regularly collates data across a wide range of societal, geographic, and health indicators for every “datazone” (small area) in Scotland.\nThe dataset at https://uoepsy.github.io/data/simd20_educ.csv contains some of the education indicators (see Table 2).\n\n\n\n\n\n\nTable 2:  Education indicators from the 2020 SIMD data \n  \n    \n      variable\n      description\n    \n  \n  \n    intermediate_zone\nAreas of scotland containing populations of between 2.5k-6k household residents\n    attendance\nAverage School pupil attendance\n    attainment\nAverage attainment score of School leavers (based on Scottish Credit and Qualifications Framework (SCQF))\n    university\nProportion of 17-21 year olds entering university\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 5\n\n\nConduct a test of whether there is a correlation between school attendance and school attainment in Scotland.\nPresent and write up the results.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThe readings have not included an example write-up for you to follow. Try to follow the logic of those for t-tests and \\(\\chi^2\\)-tests.\n\ndescribe the relevant data\nexplain what test was conducted and why\npresent the relevant statistic, degrees of freedom (if applicable), statement on p-value, etc.\nstate the conclusion.\n\nBe careful figuring out how many observations your test is conducted on. cor.test() includes only the complete observations.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nsimd &lt;- read_csv(\"https://uoepsy.github.io/data/simd20_educ.csv\")\n\nHere are the means of the two variables. We should remember that these calculations will include some observations which have missing data on the other variable.\n\nsimd |&gt; \n  summarise(\n    m_attendance = mean(attendance, na.rm = TRUE),\n    m_attainment = mean(attainment, na.rm = TRUE)\n)\n\n# A tibble: 1 × 2\n  m_attendance m_attainment\n         &lt;dbl&gt;        &lt;dbl&gt;\n1        0.811         5.53\n\n\nInstead, to match with our analysis, we might be inclined to filter our data to complete data:\n\nsimd_comp &lt;- simd |&gt; \n  filter(!is.na(attendance) & !is.na(attainment))\n\nsimd_comp |&gt;\n  summarise(\n    m_attendance = mean(attendance),\n    m_attainment = mean(attainment),\n    sd_attendance = sd(attendance),\n    sd_attainment = sd(attainment)\n)\n\n# A tibble: 1 × 4\n  m_attendance m_attainment sd_attendance sd_attainment\n         &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1        0.811         5.53        0.0696         0.386\n\n\n\ncor.test(simd_comp$attendance, simd_comp$attainment)\n\n\n    Pearson's product-moment correlation\n\ndata:  simd_comp$attendance and simd_comp$attainment\nt = 51.495, df = 1242, p-value &lt; 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.8066637 0.8421951\nsample estimates:\n      cor \n0.8252442 \n\n\n\nA correlation test was conducted to assess whether there is a relationship between an area’s average school attendance, and its average school attainment level. A total of 1244 geographical areas were included in the analysis, with a mean school attendance of 0.81 (SD = 0.07) and a mean school attainment score of 5.53 (SD = 0.39).\nThere was a strong positive correlation between a geographical area’s level of school attendance and its school attainment (\\(r\\) = 0.83, \\(t(1242\\) = 51.5, \\(p &lt; 0.001\\)). We therefore reject the null hypothesis that there is no correlation between an area’s school attendance and attainment. Figure 1 provides a visualisation of the relationship.\n\n\nCode\nggplot(simd_comp, aes(x=attendance, y=attainment)) + \n  geom_point() + \n  labs(x = \"School attendance\",\n       y = \"School attainment\")\n\n\n\n\n\nFigure 1: Positive relationship between geographical areas’ level of school attendance and school attainment\n\n\n\n\n\n\n\n\n\n\n\nOptional: some extra plotting bits\n\n\n\n\n\nSometimes we may want to highlight certain parts of a plot. We can do that using the gghighlight package, and giving it a set of conditions (like we do for filter()) in order for it to decide which points to highlight.\nYou can see an example below.\nWe have also created the title by referring to the cor() function, and ’paste’ing it together to “r =”\n\nlibrary(gghighlight)\n\nggplot(simd_comp, aes(x=attendance, y=attainment)) + \n  geom_point() + \n  gghighlight( (attainment&gt;6 & attendance&lt;.75) | \n               attendance &gt; .95 | \n               (attendance &gt; .82 & attainment&lt;5),\n               label_key = intermediate_zone) + \n  labs(x = \"School attendance\",\n       y = \"School attainment\",\n       title = paste0(\"r = \",\n                       round(\n                         cor(simd_comp$attendance,\n                                  simd_comp$attainment),\n                         2)\n                       ))"
  },
  {
    "objectID": "05_exMANGO.html#monkey-exploration",
    "href": "05_exMANGO.html#monkey-exploration",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "Monkey Exploration",
    "text": "Monkey Exploration\n\nData: monkeyexplorers.csv\nLiu, Hajnosz & Li (2023)1 have conducted a study on monkeys! They were interested in whether younger monkeys tend to be more inquisitive about new things than older monkeys do. They sampled 108 monkeys ranging from 1 to 24 years old. Each monkey was given a novel object, the researchers recorded the time (in minutes) that each monkey spent exploring the object.\nFor this week, we’re going to be investigating the research question:\n\nDo older monkeys spend more/less time exploring novel objects?\n\nThe data is available at https://uoepsy.github.io/data/monkeyexplorers.csv and contains the variables described in Table 3\n\n\n\n\n\n\nTable 3:  Data dictionary for monkeyexplorers.csv \n  \n    \n      variable\n      description\n    \n  \n  \n    name\nMonkey Name\n    age\nAge of monkey in years\n    exploration_time\nTime (in minutes) spent exploring the object\n  \n  \n  \n\n\n\n\n\n\n\nQuestion 6\n\n\nFor this week, we’re going to be investigating the following research question:\n\nDo older monkeys spend more/less time exploring novel objects?\n\nRead in the data to your R session, then visualise and describe the marginal distributions of those variables which are of interest to us. These are the distribution of each variable (time spent exploring, and monkey age) without reference to the values of the other variables.\n\n\n\n\n\n\nHints\n\n\n\n\n\n\nYou could use, for example, geom_density() for a density plot or geom_histogram() for a histogram.\nLook at the shape, center and spread of the distribution. Is it symmetric or skewed? Is it unimodal or bimodal?\nDo you notice any extreme observations?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nmonkeyexp &lt;- read_csv(\"https://uoepsy.github.io/data/monkeyexplorers.csv\")\nhead(monkeyexp)\n\n# A tibble: 6 × 3\n  name            age exploration_time\n  &lt;chr&gt;         &lt;dbl&gt;            &lt;dbl&gt;\n1 Ed Sheeran        8             13.1\n2 Vince Gill       17              6.8\n3 Jewel            13             12.8\n4 Jaden Smith      18              8.9\n5 Reba McEntire    16              1.1\n6 Metallica        13              5.7\n\n\nWe can plot the marginal distribution of these two continuous variables as density curves, and add a boxplot underneath to check for the presence of outliers. The width of the geom_boxplot() is always quite wide, so I want to make it narrower so that we can see it at the same time as the density plot. Deciding on the exact value for the width here is just trial and error:\n\nlibrary(patchwork)\n# the patchwork library allows us to combine plots together\nggplot(data = monkeyexp, aes(x = age)) +\n  geom_density() +\n  geom_boxplot(width = 1/300) +\n  labs(x = \"Age (in years)\", \n       y = \"Probability density\") +\n\nggplot(data = monkeyexp, aes(x = exploration_time)) +\n  geom_density() +\n  geom_boxplot(width = 1/175) +\n  labs(x = \"Time spent exploring a\\n novel object (in minutes)\", \n       y = \"Probability density\")\n\n\n\n\nFigure 2: Density plot and boxplot of monkey’s age and their time spent exploring novel objects\n\n\n\n\nThe plots suggests that the distributions of monkeys’ ages and the time they spend exploring novel objects are both unimodal. Most of the monkeys are between roughly 8 and 18 years old, and most of them spent between 7 and 12 minutes exploring the objects. The boxplots suggest an outlier in the distribution of exploration-times, with one monkeys spending more than \\(1.5 \\times IQR\\) beyond the 3rd quartile.\nTo further summarize a distribution, it is typical to compute and report numerical summary statistics such as the mean and standard deviation.\nAs we have seen, in earlier weeks, one way to compute these values is to use the summarise()/summarize() function from the tidyverse library:\n\nmonkeyexp |&gt; \n  summarize(\n    mean_age = mean(age), \n    sd_age = sd(age),\n    mean_exptime = mean(exploration_time),\n    sd_exptime = sd(exploration_time)\n    )\n\n# A tibble: 1 × 4\n  mean_age sd_age mean_exptime sd_exptime\n     &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;\n1     13.5   5.92         9.40       4.50\n\n\n\nThe marginal distribution of age is unimodal with a mean of 13.5 years, and a standard deviation of 5.9.\nThe marginal distribution of time-spent-exploring is unimodal with a mean of 9.4 years, and a standard deviation of 4.5.\n\n\n\n\n\nQuestion 7\n\n\nAfter we’ve looked at the marginal distributions of the variables of interest in the analysis, we typically move on to examining relationships between the variables.\nVisualise and describe the relationship between age and exploration-time among the monkeys in the sample.\n\n\n\n\n\n\nHints\n\n\n\n\n\nThink about:\n\nDirection of association\nForm of association (can it be summarised well with a straight line?)\n\nStrength of association (how closely do points fall to a recognizable pattern such as a line?)\nUnusual observations that do not fit the pattern of the rest of the observations and which are worth examining in more detail.\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\nBecause we are investigating how time-spent-exploring varies with monkeys’ ages, the exploration-time here is the dependent variable (on the y-axis), and age is the independent variable (on the x-axis).\n\nggplot(data = monkeyexp, aes(x = age, y = exploration_time)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"Age (in years)\", \n       y = \"Time spent exploring a\\n novel object (in minutes)\")\n\n\n\n\nFigure 3: The relationship between monkeys’ age and time-spent-exploring.\n\n\n\n\nThere appears to be a moderate negative linear relationship between age and exploration time in these monkeys. Older monkeys appear to spend less time, on average, exploring a novel object. The scatterplot does highlight that there is one one young monkey who is behaving a bit weirdly, and spent quite a long time exploring the object!\nTo comment numerically on the strength of the linear association we might compute the correlation coefficient that we were introduced to in 5A: Covariance & Correlation\n\nmonkeyexp |&gt;\n  select(age, exploration_time) |&gt;\n  cor()\n\n                        age exploration_time\nage               1.0000000       -0.2885495\nexploration_time -0.2885495        1.0000000\n\n\nthat is, \\(r_{\\text{age, exploration-time}} = -0.29\\)\n\n\n\n\nQuestion 8\n\n\nUsing the lm() function, fit a linear model to the sample data, in which time that monkeys spend exploring novel objects is explained by age. Assign it to a name to store it in your environment.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou can see how to fit linear models in R using lm() in 5B #fitting-linear-models-in-r\n\n\n\n\n\n\n\n\nSolution\n\n\n\nAs the variables are in the monkeyexp dataframe, we would write:\n\nmodel1 &lt;- lm(exploration_time ~ 1 + age, data = monkeyexp)\n\n\n\n\n\nQuestion 9\n\n\nInterpret the estimated intercept and slope in the context of the question of interest.\n\n\n\n\n\n\nHints\n\n\n\n\n\nWe saw how to extract lots of information on our model using summary() (see 5B #model-summary), but there are lots of other functions too.\nIf we called our linear model object “model1” in the environment, then we can use:\n\ntype model1, i.e. simply invoke the name of the fitted model;\ntype model1$coefficients;\nuse the coef(model1) function;\nuse the coefficients(model1) function;\nuse the summary(model1)$coefficients to extract just that part of the summary.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\ncoef(model1)\n\n(Intercept)         age \n   12.36253    -0.21897 \n\n\nFrom this, we get that the fitted line is: \\[\n\\widehat{\\text{ExplorationTime}} = 12.36 - 0.22 \\cdot \\text{Age} \\\\\n\\]\nWe can interpret the estimated intercept as:\n\nThe estimated average time spent exploring novel objects for a monkey of age zero is 12.36 minutes.\n\nFor the estimated slope we get:\n:::int A one year increase in age is associated with an estimated decrease of -0.22 minutes (or -13 seconds) that a monkey will spend exploring a novel object.\n\n\n\n\nQuestion 10\n\n\nTest the hypothesis that the population slope is zero — that is, that there is no linear association between exploration time and age in the population.\n\n\n\n\n\n\nHints\n\n\n\n\n\nYou don’t need to do anything for this, you can find all the necessary information in summary() of your model.\nSee 5B #inference-for-regression-coefficients.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nThe information is already contained in the row corresponding to the variable “age” in the output of summary(), which reports the t-statistic under t value and the p-value under Pr(&gt;|t|):\n\nsummary(model1)\n\n\nCall:\nlm(formula = exploration_time ~ 1 + age, data = monkeyexp)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-11.3056  -2.3461   0.3841   2.1936  21.8323 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 12.36253    1.04263  11.857  &lt; 2e-16 ***\nage         -0.21897    0.07057  -3.103  0.00246 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.324 on 106 degrees of freedom\nMultiple R-squared:  0.08326,   Adjusted R-squared:  0.07461 \nF-statistic: 9.627 on 1 and 106 DF,  p-value: 0.002458\n\n\nRecall that very small p-values such as the one for the intercept 2e-16 in the Pr(&gt;|t|) column simply means \\(2 \\times 10^{-16}\\), or 0.0000000000000002. Conventions such as the APA guidelines give rules on how to report these numbers (see, e.g. APA’s number and stats guide). For the p-values in this summary (the one for the intercept and the one for the slope) we could report them as “&lt;.001” and “0.003” respectively.\n\nA significant association was found between age (in years) and time spent exploring novel objects, with exploration time decreasing on average by -0.22 minutes (or -13 seconds) for every additional year of age (\\(b = -0.22\\), \\(SE = 0.071\\), \\(t(106)=-3.103\\), \\(p=.003\\)).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 13\n\n\nCreate a visualisation of the estimated association between age and exploration time.\n\n\n\n\n\n\nHints\n\n\n\n\n\nFor our simple regression model, there is a really easy way to do this with geom_smooth(). Check 5B #example, which shows an example.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nggplot(data = monkeyexp, aes(x = age, y = exploration_time)) +\n  geom_point(alpha = 0.5) +\n  geom_smooth(method=lm) +\n  labs(x = \"Age (in years)\", \n       y = \"Time spent exploring a\\n novel object (in minutes)\")\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 14 - Optional\n\n\nConsider the following:\n\nIn fitting a linear regression model, we make the assumption that the errors around the line are normally distributed around zero (this is the \\(\\epsilon \\sim N(0, \\sigma)\\) bit.)\n\nAbout 95% of values from a normal distribution fall within two standard deviations of the centre.\n\nWe can obtain the estimated standard deviation of the errors (\\(\\hat \\sigma\\)) from the fitted model using sigma() and giving it the name of our model.\nWhat does this tell us?\n\n\n\n\n\n\nHints\n\n\n\n\n\nSee 5B #the-error.\n\n\n\n\n\n\n\n\nSolution\n\n\n\nThe estimated standard deviation of the errors can be obtained by:\n\nsigma(model1)\n\n[1] 4.324399\n\n\nFor any particular age, the time monkeys spend exploring novel objects is estimated as being distributed above and below the regression line with a standard deviation of \\(\\hat \\sigma = 4.32\\). Since \\(1.96 \\hat \\sigma = 1.96 \\times 4.32 = \\text{approx} 8.6\\), we would expect most (about 95%) of the monkeys’ exploration times to be within about 8.6 minutes from the regression line.\n\n\n\n\nQuestion 15 - Optional\n\n\nCompute the model-predicted exploration-time for a monkey that is 1 year old.\n\n\n\n\n\n\nHints\n\n\n\n\n\nGiven that you know the intercept and slope, you can calculate this algebraically. However, try to also use the predict() function (see 5B #model-predictions).\n\n\n\n\n\n\n\n\nSolution\n\n\n\nUsing predict(), we need to give it our model, plus some new data which contains a monkey that has 1 in the age column. First we make a new dataframe with an age variable, with one entry which has the value 1, and then we give that to predict():\n\nage_query &lt;- data.frame(age = c(1))\npredict(model1, newdata = age_query)\n\n       1 \n12.14356 \n\n\nGiven that our fitted model takes the form:\n\\[\n\\widehat{\\text{ExplorationTime}} = 12.36 - 0.22 \\cdot \\text{Age}\n\\]\nWe are asking what the predicted exploration time is for a monkey with 1 year of age. So we can substitute in “1” for the Age variable: \\[\n\\begin{align}\n\\text{ExplorationTime} &= 12.36 - 0.22 \\cdot \\text{Age} \\\\\n\\text{ExplorationTime} &= 12.36 - 0.22 \\cdot 1 \\\\\n\\text{ExplorationTime} &= 12.36 - 0.22\\\\\n\\text{ExplorationTime} &= 12.14\\\\\n\\end{align}\n\\]\n\n\n\n\n\n\n\nInfluential Monkeys\n\nQuestion 16\n\n\nTake a look at the assumption plots (see 5B #assumptions) for your model.\n\nThe trick to looking at assumption plots in linear regression is to look for “things that don’t look random”.\nAs well as looking for patterns, these plots can also higlight individual datapoints that might be skewing the results. Can you figure out if there are any unusual monkeys in our dataset? Can you re-fit the model without that monkey? When you do so, do your conclusions change?\n\n\n\n\n\n\nSolution\n\n\n\n\nplot(model1)\n\n\n\n\n\n\n\n\nFrom these plots, we can see that the 57th observation is looking a bit influential. It is the one datapoint that is looking weird in all of the plots.\nLet’s look at them:\n\nmonkeyexp[57, ]\n\n# A tibble: 1 × 3\n  name       age exploration_time\n  &lt;chr&gt;    &lt;dbl&gt;            &lt;dbl&gt;\n1 Lil Fizz     5             33.1\n\n\nThis is a young monkey (5 years old) called “Lil Fizz”, who seems to have spent quite a long time exploring the toy. It’s important to remember that this monkey is a valuable datapoint, despite being a bit different from the general pattern.\nHowever, it would be nice to know how much Lil Fizz is affecting our conclusions, so let’s re-fit the model on everybody except that one monkey\n\nmodel1a &lt;- lm(exploration_time ~ age, data = monkeyexp[-57, ])\nsummary(model1a)\n\n\nCall:\nlm(formula = exploration_time ~ age, data = monkeyexp[-57, ])\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-10.558  -2.321   0.427   2.386   9.884 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 11.46135    0.92155  12.437  &lt; 2e-16 ***\nage         -0.16781    0.06212  -2.701  0.00805 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.769 on 105 degrees of freedom\nMultiple R-squared:  0.06498,   Adjusted R-squared:  0.05608 \nF-statistic: 7.297 on 1 and 105 DF,  p-value: 0.008053\n\n\nOur conclusions haven’t changed - we still have a significant association.\nWhat we have just done is called a “sensitivity analysis” - we’ve asked if our analyses are sensitive to a specific decision we could make (whether or not we include/exclude this monkey).\n\n\nCode\nggplot(monkeyexp, aes(x=age,y=exploration_time))+\n  geom_point()+\n  geom_smooth(method=lm, fullrange=TRUE)+\n  ylim(0,34) + \n  labs(title=\"With monkey 57\") +\n\nggplot(monkeyexp[-57,], aes(x=age,y=exploration_time))+\n  geom_point()+\n  geom_smooth(method=lm, fullrange=TRUE)+\n  ylim(0,34) + \n  labs(title=\"Without monkey 57\")\n\n\n\n\n\n\n\n\n\nWe now have a decision to make. Do we continue with the monkey removed, or do we keep them in? There’s not really a right answer here, but it’s worth noting a practical issue - our assumption plots look considerably better for our model without this monkey.\nWhatever we do, when writing up the analysis we need to mention clearly if and why we exclude any observations, and how that decision has/hasn’t influenced our conclusions.\n\n\n\n\n\nMonkey Exploration in Adulthood\nLet’s suppose instead of having measured monkeys’ ages in years, researchers simply recorded whether each monkey was an adult or a juvenile (species like Capuchins and Rhesus Macaques reach adulthood at about 8 years old).\nThe code below creates a this new variable for us:\n\nmonkeyexp &lt;- monkeyexp |&gt; \n  mutate(\n    isAdult = ifelse(age &gt;= 8, \"yes\",\"no\")\n  )\n\n\nQuestion 17\n\n\nFit the following model, and interpret the coefficients.\n\\[\n\\text{ExplorationTime} = b_0 + b_1 \\cdot \\text{isAdult} + \\varepsilon\n\\]\n\n\n\n\n\n\nHints\n\n\n\n\n\nFor help interpreting the coefficients, see 5B #binary-predictors.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\nmodel2 &lt;- lm(exploration_time ~ 1 + isAdult, data = monkeyexp)\nsummary(model2)\n\n\nCall:\nlm(formula = exploration_time ~ 1 + isAdult, data = monkeyexp)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-11.2556  -2.3694  -0.0444   2.5556  21.4444 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   11.656      1.037  11.239   &lt;2e-16 ***\nisAdultyes    -2.711      1.136  -2.386   0.0188 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.4 on 106 degrees of freedom\nMultiple R-squared:  0.05099,   Adjusted R-squared:  0.04204 \nF-statistic: 5.695 on 1 and 106 DF,  p-value: 0.01878\n\n\n\n(Intercept) = the estimated exploration time of juvenile monkeys (11.7 minutes)\nisAdultyes = the estimated change in exploration time from juvenile monkeys to adult monkeys (-2.7 minutes)\n\n\nggplot(monkeyexp, aes(x = isAdult, y = exploration_time)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 18\n\n\nWe’ve actually already seen a way to analyse questions of this sort (“is the average exploration-time different between juveniles and adults?”)\nRun the following t-test, and consider the statistic, p value etc. How does it compare to the model in the previous question?\n\nt.test(exploration_time ~ isAdult, data = monkeyexp, var.equal = TRUE)\n\n\n\n\n\n\nSolution\n\n\n\n\nt.test(exploration_time ~ isAdult, data = monkeyexp, var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  exploration_time by isAdult\nt = 2.3865, df = 106, p-value = 0.01878\nalternative hypothesis: true difference in means between group no and group yes is not equal to 0\n95 percent confidence interval:\n 0.4588049 4.9634174\nsample estimates:\n mean in group no mean in group yes \n        11.655556          8.944444 \n\n\nIt is identical! the \\(t\\)-statistics are the same, the p-values are the same, the degrees of freedom. Everything!\nThe two sample t-test is actually just a special case of the linear model, where we have a numeric outcome variable and a binary predictor!\nAnd… the one-sample t-test is the linear model without any predictors, so just with an intercept.\n\nt.test(monkeyexp$exploration_time, mu = 0)\n\n\n    One Sample t-test\n\ndata:  monkeyexp$exploration_time\nt = 21.722, df = 107, p-value &lt; 2.2e-16\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n  8.538785 10.253807\nsample estimates:\nmean of x \n 9.396296 \n\ninterceptonly_model &lt;- lm(exploration_time ~ 1, data = monkeyexp)\n\nsummary(interceptonly_model)$coefficients\n\n            Estimate Std. Error  t value     Pr(&gt;|t|)\n(Intercept) 9.396296  0.4325657 21.72224 5.060938e-41"
  },
  {
    "objectID": "05_exMANGO.html#footnotes",
    "href": "05_exMANGO.html#footnotes",
    "title": "Exercises: Covariance, Correlation & Linear Regression",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNot a real study!↩︎"
  },
  {
    "objectID": "05a_covcor.html",
    "href": "05a_covcor.html",
    "title": "5A: Covariance and Correlation",
    "section": "",
    "text": "This reading:\n\nHow can we describe the relationship between two continuous variables?\n\nHow can we test the relationship between two continuous variables?\n\n\nIn the last couple of weeks we have covered a range of the basic statistical tests that can be conducted when we have a single outcome variable, and sometimes also a single explanatory variable. Our outcome variables have been both continuous (\\(t\\)-tests) and categorical (\\(\\chi^2\\)-tests). We’re going to look at one more relationship now, which is that between two continuous variables. This will also provide us with our starting point for the second block of the course.\n\n\n\n\n\noutcome\nexplanatory\ntest\nexamines\n\n\n\n\ncontinuous\n\nt.test(y, mu = ?)\nis the mean of y different from [specified value]?\n\n\ncontinuous\nbinary\nt.test(y ~ x)\nis the mean of y different between the two groups?\n\n\ncategorical\n\nchisq.test(table(y), prob = c(?,...,?))\nis the distribution of categories of y different from [specified proportions]?\n\n\ncategorical\ncategorical\nchisq.test(table(y,x))\nis the distribution of categories of y dependent on the category of x?\n\n\ncontinuous\ncontinuous\n???\n???\n\n\n\n\n\n\n\n\n\nResearch Question: Is there a correlation between accuracy and self-perceived confidence of memory recall?\n\nOur data for this walkthrough is from a (hypothetical) study on memory. Twenty participants studied passages of text (c500 words long), and were tested a week later. The testing phase presented participants with 100 statements about the text. They had to answer whether each statement was true or false, as well as rate their confidence in each answer (on a sliding scale from 0 to 100). The dataset contains, for each participant, the percentage of items correctly answered, and the average confidence rating. Participants’ ages were also recorded.\nThe data are available at “https://uoepsy.github.io/data/recalldata.csv.\n\nLet’s take a look visually at the relationships between the percentage of items answered correctly (recall_accuracy) and participants’ average self-rating of confidence in their answers (recall_confidence). Let’s also look at the relationship between accuracy and age.\n\nlibrary(tidyverse)\nlibrary(patchwork)\n\nrecalldata &lt;- read_csv('https://uoepsy.github.io/data/recalldata.csv')\n\nggplot(recalldata, aes(x=recall_confidence, recall_accuracy))+\n  geom_point() + \nggplot(recalldata, aes(x=age, recall_accuracy))+\n  geom_point()\n\n\n\n\n\n\n\n\nThese two relationships look quite different.\n\nFor participants who tended to be more confident in their answers, the percentage of items they correctly answered tends to be higher.\n\nThe older participants were, the lower the percentage of items they correctly answered tended to be.\n\nWhich relationship should we be more confident in and why?\nIdeally, we would have some means of quantifying the strength and direction of these sorts of relationship. This is where we come to the two summary statistics which we can use to talk about the association between two numeric variables: Covariance and Correlation.\n\nCovariance\nCovariance is the measure of how two variables vary together. It is the change in one variable associated with the change in another variable.\nCovariance is calculated using the following formula:\n\\[\\mathrm{cov}(x,y)=\\frac{\\sum_{i=1}^n (x_{i}-\\bar{x})(y_{i}-\\bar{y})}{n-1}\\] where:\n\n\\(x\\) and \\(y\\) are two variables; e.g., age and recall_accuracy;\n\\(i\\) denotes the observational unit, such that \\(x_i\\) is value that the \\(x\\) variable takes on the \\(i\\)th observational unit, and similarly for \\(y_i\\);\n\\(n\\) is the sample size.\n\nThis can initially look like quite a big equation, so let’s break it down.\n\nCovariance explained visually\nConsider the following scatterplot:\n\n\n\n\n\n\n\n\n\n Now let’s superimpose a vertical dashed line at the mean of \\(x\\) (\\(\\bar{x}\\)) and a horizontal dashed line at the mean of \\(y\\) (\\(\\bar{y}\\)):\n\n\n\n\n\n\n\n\n\n Now let’s pick one of the points, call it \\(x_i\\), and show \\((x_{i}-\\bar{x})\\) and \\((y_{i}-\\bar{y})\\).\nNotice that this makes a rectangle.\n\n\n\n\n\n\n\n\n\nAs \\((x_{i}-\\bar{x})\\) and \\((y_{i}-\\bar{y})\\) are both positive values, their product — \\((x_{i}-\\bar{x})(y_{i}-\\bar{y})\\) — is positive.\nIn fact, for any pair of values \\(x_i\\) and \\(y_i\\) where both values are above their respective means, or both are below, then product \\((x_{i}-\\bar{x})(y_{i}-\\bar{y})\\) will be positive (remember that a negative multiplied by a negative gives a positive):\n\n\n\n\n\n\n\n\n\nAnd for all those other points (in blue) the product \\((x_{i}-\\bar{x})(y_{i}-\\bar{y})\\) is negative:\n\n\n\n\n\n\n\n\n\n Now let’s take another look at the formula for covariance:\n\\[\\mathrm{cov}(x,y)=\\frac{\\sum_{i=1}^n (x_{i}-\\bar{x})(y_{i}-\\bar{y})}{n-1}\\]\nIt is the sum of all these products divided by \\(n-1\\). It is the average of the products! You can almost think of this as the average area of all the rectangles!\nSo for plots like this where we have been colouring them in blue or red, the measure of covariance moves up and down depending upon how much blue vs how much red there is! It will be zero when there is the same amount of blue as there is red.\n\n\n\n\n\n\n\n\n\n\n\nCovariance in R\nWe can calculate covariance in R using the cov() function.\ncov() can take two variables cov(x = , y = ).\n\ncov(x = recalldata$recall_accuracy, y = recalldata$recall_confidence)\n\n[1] 118.0768\n\n\nIf necessary, we can choose use only the complete observations (i.e. ignoring all rows where either value is an NA) by specifying:\n\ncov(x = ..., y = ..., use = \"complete.obs\")\n\n\n\n\n\n\n\n\nStep-by-step calculations of covariance\n\n\n\n\n\n\nCreate 2 new columns in the memory recall data, one of which is the mean recall accuracy, and one which is the mean recall confidence.\n\n\nrecalldata &lt;-\n  recalldata |&gt; mutate(\n    maccuracy = mean(recall_accuracy),\n    mconfidence = mean(recall_confidence)\n  )\n\n\nNow create three new columns which are:\n\nrecall accuracy minus the mean recall accuracy - this is the \\((x_i - \\bar{x})\\) part.\n\nconfidence minus the mean confidence - and this is the \\((y_i - \\bar{y})\\) part.\n\nthe product of i. and ii. - this is calculating \\((x_i - \\bar{x})\\)\\((y_i - \\bar{y})\\).\n\n\n\nrecalldata &lt;- \n  recalldata |&gt; \n    mutate(\n      acc_minus_mean_acc = recall_accuracy - maccuracy,\n      conf_minus_mean_conf = recall_confidence - mconfidence,\n      prod_acc_conf = acc_minus_mean_acc * conf_minus_mean_conf\n    )\n\nrecalldata\n\n# A tibble: 20 × 9\n   ppt    recall_accuracy recall_confidence   age maccuracy mconfidence\n   &lt;chr&gt;            &lt;dbl&gt;             &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 ppt_1               72              66.6    72      69.2        55.4\n 2 ppt_2               66              47.1    35      69.2        55.4\n 3 ppt_3               47              43.8    48      69.2        55.4\n 4 ppt_4               84              58.9    52      69.2        55.4\n 5 ppt_5               84              75.1    46      69.2        55.4\n 6 ppt_6               58              53.5    41      69.2        55.4\n 7 ppt_7               52              48.5    86      69.2        55.4\n 8 ppt_8               76              67.1    58      69.2        55.4\n 9 ppt_9               41              40.4    59      69.2        55.4\n10 ppt_10              67              46.8    22      69.2        55.4\n11 ppt_11              60              50.6    62      69.2        55.4\n12 ppt_12              67              28.7    40      69.2        55.4\n13 ppt_13              76              69.0    47      69.2        55.4\n14 ppt_14              93              67.9    51      69.2        55.4\n15 ppt_15              71              54.5    34      69.2        55.4\n16 ppt_16              71              64.6    37      69.2        55.4\n17 ppt_17              99              66.3    37      69.2        55.4\n18 ppt_18              66              49.0    51      69.2        55.4\n19 ppt_19              77              58.5    41      69.2        55.4\n20 ppt_20              58              51.4    57      69.2        55.4\n# ℹ 3 more variables: acc_minus_mean_acc &lt;dbl&gt;, conf_minus_mean_conf &lt;dbl&gt;,\n#   prod_acc_conf &lt;dbl&gt;\n\n\n\nFinally, sum the products, and divide by \\(n-1\\)\n\n\nrecalldata |&gt;\n  summarise(\n    prod_sum = sum(prod_acc_conf),\n    n = n()\n  )\n\n# A tibble: 1 × 2\n  prod_sum     n\n     &lt;dbl&gt; &lt;int&gt;\n1    2243.    20\n\n2243.46 / (20-1)\n\n[1] 118.0768\n\n\nWhich is the same result as using cov():\n\ncov(x = recalldata$recall_accuracy, y = recalldata$recall_confidence)\n\n[1] 118.0768\n\n\n\n\n\n\n\nCorrelation\nOne thing to note with covariance is that it is sensitive to the units of measurement. The covariance between height-in-centimeters and weight-in-grams will be a much bigger number than the covariance between height-in-meters and weight-in-kilograms.\nCorrelation solves this issue, and you can think of correlation as a standardised covariance. It has a scale from negative one to one, on which the distance from zero indicates the strength of the relationship.\nJust like covariance, positive/negative values reflect the nature of the relationship.\nThe correlation coefficient is a standardised number which quantifies the strength and direction of the linear relationship between two variables. In a population it is denoted by \\(\\rho\\), and in a sample it is denoted by \\(r\\).\nWe can calculate \\(r\\) using the following formula:\n\\[\nr_{(x,y)}=\\frac{\\mathrm{cov}(x,y)}{s_xs_y}\n\\]\nWe can actually rearrange this formula to show that the correlation is simply the covariance, but with the values \\((x_i - \\bar{x})\\) divided by the standard deviation (\\(s_x\\)), and the values \\((y_i - \\bar{y})\\) divided by \\(s_y\\): \\[\nr_{(x,y)}=\\frac{1}{n-1} \\sum_{i=1}^n \\left( \\frac{x_{i}-\\bar{x}}{s_x} \\right) \\left( \\frac{y_{i}-\\bar{y}}{s_y} \\right)\n\\]  The correlation is the simply the covariance of standardised variables (variables expressed as the distance in standard deviations from the mean).\n\n\n\n\n\n\n\n\n\n\nProperties of correlation coefficients\n\n\\(-1 \\leq r \\leq 1\\)\nThe sign indicates the direction of association\n\npositive association (\\(r &gt; 0\\)) means that values of one variable tend to be higher when values of the other variable are higher\nnegative association (\\(r &lt; 0\\)) means that values of one variable tend to be lower when values of the other variable are higher\nno linear association (\\(r \\approx 0\\)) means that higher/lower values of one variable do not tend to occur with higher/lower values of the other variable\n\nThe closer \\(r\\) is to \\(\\pm 1\\), the stronger the linear association\n\\(r\\) has no units and does not depend on the units of measurement\nThe correlation between \\(x\\) and \\(y\\) is the same as the correlation between \\(y\\) and \\(x\\)\n\n\n\nCorrelation in R\nJust like R has a cov() function for calculating covariance, there is a cor() function for calculating correlation:\n\ncor(x = recalldata$recall_accuracy, y = recalldata$recall_confidence)\n\n[1] 0.6993654\n\n\nIf necessary, we can choose use only the complete observations (i.e. ignoring all rows where either value is an NA) by specifying:\n\ncor(x = ..., y = ..., use = \"complete.obs\")\n\n\n\n\n\n\n\n\nStep-by-step calculations\n\n\n\n\n\nWe calculated above that \\(\\text{cov}(\\text{recall-accuracy}, \\text{recall-confidence})\\) = 118.077.\nTo calculate the correlation, we can simply divide this by the standard deviations of the two variables \\(s_{\\text{recall-accuracy}} \\times s_{\\text{recall-confidence}}\\)\n\nrecalldata |&gt; summarise(\n  s_ra = sd(recall_accuracy),\n  s_rc = sd(recall_confidence)\n)\n\n# A tibble: 1 × 2\n   s_ra  s_rc\n  &lt;dbl&gt; &lt;dbl&gt;\n1  14.5  11.6\n\n118.08 / (14.527 * 11.622)\n\n[1] 0.6993902\n\n\nWhich is the same result as using cor():\n\ncor(x = recalldata$recall_accuracy, y = recalldata$recall_confidence)\n\n[1] 0.6993654\n\n\n\n\n\n\n\n\n\n\nCorrelation Tests\nNow that we’ve seen the formulae for covariance and correlation, as well as how to quickly calculate them in R using cov() and cor(), we can use a statistical test to establish the probability of finding an association this strong by chance alone.\n\nHypotheses:\nThe hypotheses of the correlation test are, as always, statements about the population parameter (in this case the correlation between the two variables in the population - i.e., \\(\\rho\\)).\nIf we are conducting a two tailed test, then\n\n\\(H_0: \\rho = 0\\). There is not a linear relationship between \\(x\\) and \\(y\\) in the population.\n\n\\(H_1: \\rho \\neq 0\\) There is a linear relationship between \\(x\\) and \\(y\\).\n\nIf we instead conduct a one-tailed test, then we are testing either\n\n\\(H_0: \\rho \\leq 0\\) There is a negative or no linear relationship between \\(x\\) and \\(y\\)\nvs\n\\(H_1: \\rho &gt; 0\\) There is a positive linear relationship between \\(x\\) and \\(y\\).\n\\(H_0: \\rho \\geq 0\\) There is a positive or no linear relationship between \\(x\\) and \\(y\\)\nvs\n\\(H_1: \\rho &lt; 0\\) There is a negative linear relationship between \\(x\\) and \\(y\\).\n\nTest Statistic\nThe test statistic for this test here is another \\(t\\) statistic, the formula for which depends on both the observed correlation (\\(r\\)) and the sample size (\\(n\\)):\n\\[t = r \\sqrt{\\frac{n-2}{1-r^2}}\\]\np-value\nWe calculate the p-value for our \\(t\\)-statistic as the long-run probability of a \\(t\\)-statistic with \\(n-2\\) degrees of freedom being less than, greater than, or more extreme in either direction (depending on the direction of our alternative hypothesis) than our observed \\(t\\)-statistic.\nAssumptions\nFor a test of Pearson’s correlation coefficient \\(r\\), we need to make sure a few conditions are met:\n\nBoth variables are quantitative\nBoth variables should be drawn from normally distributed populations.\nThe relationship between the two variables should be linear.\n\n\n\n\n\n\n\n\nQuick and easy cor.test()\n\n\n\n\n\nWe can test the significance of the correlation coefficient really easily with the function cor.test():\n\ncor.test(recalldata$recall_accuracy, recalldata$recall_confidence)\n\n\n    Pearson's product-moment correlation\n\ndata:  recalldata$recall_accuracy and recalldata$recall_confidence\nt = 4.1512, df = 18, p-value = 0.0005998\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.3719603 0.8720125\nsample estimates:\n      cor \n0.6993654 \n\n\nby default, cor.test() will include only observations that have no missing data on either variable.\ne.g., running cor.test() on x and y in the dataframe below will include only the yellow rows:\n\n\n\n\n\nx\ny\n\n\n\n\n1\nNA\n\n\n2\n6\n\n\nNA\n8\n\n\n4\n7\n\n\n5\n9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStep-by-step calculations\n\n\n\n\n\nOr, if we want to calculate our test statistic manually:\n\n#calculate r\nr = cor(recalldata$recall_accuracy, recalldata$recall_confidence)\n\n#get n\nn = nrow(recalldata)\n\n#calculate t    \ntstat = r * sqrt((n - 2) / (1 - r^2))\n\n#calculate p-value for t, with df = n-2 \n2*(1-pt(tstat, df=n-2))\n\n[1] 0.0005998222\n\n\n\n\n\n\n\n\n\n\n\noptional: (completely optional!) why t?\n\n\n\n\n\nWhy exactly do we have a \\(t\\) statistic? We’re calculating \\(r\\), not \\(t\\)??\nRemember that in hypothesis testing, we need a distribution against which to compare a statistic. But \\(r\\) is bounded (it can only be between -1 and 1). This means the distributions of “\\(r\\)’s that we would expect if under repeated sampling” is not easily defined in a standard way. Consider how the shape changes when our sample size changes:\n\n\n\n\n\n\n\n\n\nSo what we do is convert the \\(r\\) statistic to a \\(t\\) statistic, and then we can compare that to a \\(t\\) distribution!\n\\(t\\) statistics are generally calculated by using \\(\\frac{estimate - 0}{standard\\, error}\\).\nThe standard error for a correlation \\(r\\) is quantifiable as \\(\\sqrt{\\frac{(1-r^2)}{(n-2)}}\\).\nWe can think of this as what variance gets left-over (\\(1-r^2\\)) in relation to how much data is free to vary (\\(n-2\\) because we have calculated 2 means in the process of getting \\(r\\)). This logic maps to how our standard error of the mean was calculated \\(\\frac{\\sigma}{\\sqrt{n}}\\), in that it is looking at \\(\\frac{\\text{leftover variation}}{\\text{free datapoints}}\\).\nWhat this means is we can convert \\(r\\) into a \\(t\\) that we can then test!\n\\[\nt = \\, \\, \\frac{r}{SE_r} \\,\\,=\\,\\, \\frac{r}{\\sqrt{\\frac{(1-r^2)}{(n-2)}}} \\,\\,=\\,\\, r \\sqrt{\\frac{n-2}{1-r^2}}\n\\]\n\n\n\n\n\n\n\n\nCautions!\nCorrelation is an invaluable tool for quantifying relationships between variables, but must be used with care.\nBelow are a few things to be aware of when we talk about correlation.\n\nCorrelation can be heavily affected by outliers. Always plot your data!\nThe two plots below only differ with respect to the inclusion of one observation. However, the correlation coefficient for the two sets of observations is markedly different.\n\n\n\n\n\n\n\n\n\n\n\nr = 0 means no linear association. The variables could still be otherwise associated. Always plot your data!\nThe correlation coefficient in Figure 1 below is negligible, suggesting no linear association. The word “linear” here is crucial - the data are very clearly related.\n\n\n\n\n\nFigure 1: Unrelated data?\n\n\n\n\nSimilarly, take look at all the sets of data in Figure 2 below. The summary statistics (means and standard deviations of each variable, and the correlation) are almost identical, but the visualisations suggest that the data are very different from one another.\n\n\n\n\n\nFigure 2: Datasaurus! From Matejka, J., & Fitzmaurice, G. (2017, May): Same stats, different graphs: generating datasets with varied appearance and identical statistics through simulated annealing.\n\n\n\n\n\n\nCorrelation does not imply causation!\n\n\n\n\n\nFigure 3: https://twitter.com/quantitudepod/status/1309135514839248896\n\n\n\n\nYou will have likely heard the phrase “correlation does not imply causation”. There is even a whole wikipedia entry devoted to the topic.\nJust because you observe an association between x and y, we should not deduce that x causes y\nAn often cited paper which appears to fall foul of this error took a correlation between a country’s chocolate consumption and its number of nobel prize winners (see Figure 4) to suggest a causal relationship between the two (“chocolate intake provides the abundant fertile ground needed for the sprouting of Nobel laureates”):\n\n\n\n\n\nFigure 4: Chocolate consumption causes more Nobel Laureates?"
  },
  {
    "objectID": "05b_slr.html",
    "href": "05b_slr.html",
    "title": "5B: Simple Linear Regression",
    "section": "",
    "text": "This reading:\n\nModelling an outcome variable as a linear function of an explanatory variable (correlation as an intercept and a slope).\n\nTesting the parameters that define our model.\n\nSimple statistical tests as linear models."
  },
  {
    "objectID": "05b_slr.html#the-model",
    "href": "05b_slr.html#the-model",
    "title": "5B: Simple Linear Regression",
    "section": "The Model",
    "text": "The Model\nWhen we fit a simple regression model, the bit we refer to as the ‘model’ is the line that is defined by two numbers, an ‘intercept’ and a ‘slope’ (see Figure 2):\n\nthe intercept, denoted \\(b_0\\), is the point at which the line hits the y-axis (i.e. where \\(x=0\\))\nthe slope, denoted \\(b_1\\), is the angle of the line. It is the amount which the line increases for every 1 increase in \\(x\\).\n\n\n\n\n\n\nFigure 2: Simple linear regression model, with the systematic part of the model in blue\n\n\n\n\nThis line implies some predicted values for our observed \\(x\\) values. For instance, we can see that when \\(x=3\\), the model (the blue line) will predict that \\(y\\) is approximately 4. If we take each of our datapoints, and project them up/down to the line, then we get our fitted values (Figure 3). We often denote these as \\(\\hat y\\) (or “y hat”), with the hat indicating that they are the model-estimated values of \\(y\\).\n\\[\n\\begin{align}\n\\color{red}{Outcome}\\color{black} \\qquad=\\qquad & \\color{blue}{Model}\\color{black}{} & +\\qquad Error\\\\\n\\color{red}{y}\\color{black} \\qquad = \\qquad & \\color{blue}{\\hat y}\\color{black} & +\\qquad \\varepsilon \\quad \\\\\n\\color{red}{y}\\color{black} \\qquad = \\qquad & \\color{blue}{b_0 + b_1 \\cdot x}\\color{black} & +\\qquad \\varepsilon \\quad \\\\\n\\end{align}\n\\]\n\n\n\n\n\nFigure 3: Simple linear regression model, fitted values in blue\n\n\n\n\n\n\n\n\n\n\noptional: Regression Slope vs Covariance\n\n\n\n\n\nWith simple linear regression, the fitted line we are describing is actually a scaled version of our covariance.\nRemember that covariance is the average of the products of \\((x_{i}-\\bar{x})(y_{i}-\\bar{y})\\), which is a bit like the average area of the rectangles in Figure 4. If we think about what the average width of these rectangles is, it is the average of \\((x_{i}-\\bar{x})\\), which is actually just the variance of \\(x\\)!\n\n\n\n\n\nFigure 4: Covariance\n\n\n\n\nWe can divide the area of the average rectangle (\\(cov(x, y)\\)) by its width (\\(var(x)\\)), thereby scaling it so that the width is 1. What we’re getting from our coefficient is the area of this new rectangle which has width = 1. Because width = 1, the area is also the height (\\(\\text{area} = \\text{width} \\times \\text{height} = 1 \\times \\text{height}\\)). So what we get is the amount that \\(y\\) increases (the height) as \\(x\\) increases by 1 (the width).\nWe can see this working:\n\ncov(my_data$x, my_data$y)\n\n[1] 0.6877738\n\nvar(my_data$x)\n\n[1] 0.8823097\n\n\nThis calculation gives us the same linear regression slope of 0.78 that we see when we fit the model using lm().\n\ncov(my_data$x, my_data$y)/var(my_data$x)\n\n[1] 0.7795152"
  },
  {
    "objectID": "05b_slr.html#the-error",
    "href": "05b_slr.html#the-error",
    "title": "5B: Simple Linear Regression",
    "section": "The Error",
    "text": "The Error\nOur model is not perfect. It is a model - i.e. it is a simplification of the world, and so is inherently going to be inaccurate for individuals. This inaccuracy can be seen in our plots so far - some points are higher than the model predicts, some lower. These deviations from the model (shown by the black dotted lines in Figure 5) from the model are the random error component \\(\\hat \\varepsilon\\), or “residuals”.\n\\[\n\\begin{align}\nError &= \\color{red}{Outcome}\\color{black}-\\color{blue}{Model} \\\\\n\\hat{\\varepsilon} &= \\color{red}{y}\\color{black}- \\color{blue}{\\hat{y}}\n\\end{align}\n\\]\n\n\n\n\n\nFigure 5: Simple linear regression model, with the systematic part of the model in blue, and residuals in red\n\n\n\n\nIn full, we should really write our linear regression model out as:\n\\[\n\\begin{align}\n& y = b_0 + b_1 \\cdot x + \\varepsilon \\quad \\\\\n& \\text{where} \\\\\n& \\varepsilon \\sim N(0, \\sigma) \\text{ independently}\n\\end{align}\n\\]\nThe new bit here: “\\(\\varepsilon \\sim N(0, \\sigma) \\text{ independently}\\)” means that the errors around the line have mean zero and constant spread as x varies (we’ll read more about what this means later on when we discuss the assumptions underlying regression). You can think of \\(\\sim N(0, \\sigma)\\) as meaning “normally distributed with a mean of zero and a standard deviation of \\(\\sigma\\)”.\nThe standard deviation of the errors, denoted by \\(\\sigma\\), is an important quantity that our model estimates. It measures how much individual data points tend to deviate above and below the regression line. A small \\(\\sigma\\) indicates that the points hug the line closely and we should expect fairly accurate predictions, while a large \\(\\sigma\\) suggests that, even if we estimate the line perfectly, we can expect individual values to deviate from it by substantial amounts.\n\\(\\sigma\\) is estimated by essentially averaging squared residuals (giving the variance) and taking the square-root:\n\\[\n\\begin{align}\n& \\hat \\sigma = \\sqrt{\\frac{SS_{Residual}}{n - 2}} \\\\\n\\qquad \\\\\n& \\text{where} \\\\\n& SS_{Residual} = \\textrm{Sum of Squared Residuals} = \\sum_{i=1}^n{(\\varepsilon_i)^2}\n\\end{align}\n\\]"
  },
  {
    "objectID": "05b_slr.html#lm",
    "href": "05b_slr.html#lm",
    "title": "5B: Simple Linear Regression",
    "section": "lm()",
    "text": "lm()\nIn R it is very easy to fit linear models, we just need to use the lm() function.\nThe syntax of the lm() function is:\nmodel_name &lt;- lm(outcome ~ 1 + predictor, data = dataframe)\nWe don’t have to include the 1 + when we specify the model, as this will be included by default, so we can also simply write:\nmodel_name &lt;- lm(outcome ~ predictor, data = dataframe)\n\n\n\n\n\n\nWhat is the ~1 + doing?\n\n\n\n\n\nThe fitted model can be written as \\[\n\\hat y = \\hat b_0 + \\hat b_1 \\cdot x\n\\] The predicted values for the outcome are equal to our intercept, \\(\\hat b_0\\), plus our slope \\(\\hat b_1\\) multiplied by the value on our explanatory variable \\(x\\).\nThe intercept is a constant. That is, we could write it as multiplied by 1: \\[\n\\hat y = \\color{blue}{\\hat b_0}\\color{black}{}\\cdot\\color{orange}{1}\\color{blue}{ + \\hat b_1 }\\color{black}{}\\cdot\\color{orange}{x}\\color{black}{}\n\\]\nWhen we specify the linear model in R, we include after the tilde sign ~ all the things which appear to the right of each of the \\(\\hat b\\)s (the bits in green in the equation above). That’s why the 1 is included. It is just saying “we want the intercept, \\(b_0\\), to be estimated”."
  },
  {
    "objectID": "05b_slr.html#model-summary",
    "href": "05b_slr.html#model-summary",
    "title": "5B: Simple Linear Regression",
    "section": "Model Summary",
    "text": "Model Summary\nWe can then view lots of information by giving our model to the summary() function:\n\nmy_model &lt;- lm(y ~ x, data = my_data)\nsummary(my_model)\n\n\n\n\n\n\nFigure 6: Output of lm() for a simple regression in R\n\n\n\n\nThe intercept \\(b_0\\) is the point at which the line hits the y-axis (i.e. where \\(x=0\\)), and the slope \\(b_1\\) is the amount which the line increases for every 1 increase in \\(x\\). We can see the estimated values of these in Figure 6, and these provide us with our fitted lin:\n\\[\n\\begin{align}\ny =& 1.54 + 0.78 \\cdot x + \\varepsilon \\\\\n\\end{align}\n\\] We also see that the standard deviation of the residuals, \\(\\sigma\\), is 0.93, which means we consider the actual observed values of Y to vary randomly around this line with a standard deviation of 0.93.\n\n\n\n\n\nFigure 7: Simple linear regression model, estimated intercept and slope included"
  },
  {
    "objectID": "05b_slr.html#model-predictions",
    "href": "05b_slr.html#model-predictions",
    "title": "5B: Simple Linear Regression",
    "section": "Model Predictions",
    "text": "Model Predictions\nWe can get out the model predicted values for \\(y\\), the “y hats” (\\(\\hat y\\)), using functions such as:\n\npredict(my_model)\nfitted(my_model)\nfitted.values(my_model)\nmy_model$fitted.values\n\nA nice package which will come in handy is the broom package. It allows us to use the function augment(), which gives us out lots of information, such as the model predicted values, the residuals, and many more:\n\nlibrary(broom)\naugment(my_model)\n\n# A tibble: 100 × 8\n       y     x .fitted .resid   .hat .sigma  .cooksd .std.resid\n   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n 1  4.42  3.19    4.03  0.388 0.0102  0.935 0.000903      0.420\n 2  4.48  2.57    3.54  0.941 0.0130  0.931 0.00681       1.02 \n 3  2.72  3.91    4.59 -1.87  0.0180  0.916 0.0378       -2.03 \n 4  5.39  4.79    5.28  0.107 0.0438  0.935 0.000319      0.118\n 5  3.85  4.00    4.66 -0.809 0.0197  0.932 0.00776      -0.878\n 6  4.42  4.11    4.74 -0.327 0.0222  0.935 0.00143      -0.355\n 7  4.30  2.72    3.66  0.638 0.0114  0.933 0.00274       0.689\n 8  5.94  4.02    4.68  1.26  0.0202  0.927 0.0193        1.37 \n 9  1.70  3.05    3.92 -2.22  0.0100  0.908 0.0291       -2.40 \n10  4.79  4.58    5.11 -0.318 0.0358  0.935 0.00224      -0.348\n# ℹ 90 more rows\n\n\nWe can also compute model-predicted values for other (unobserved) data. For instance, what about for an observation where \\(x=10\\), or \\(20\\)?\n\n# make a dataframe with values for the predictor:\nsome_newdata &lt;- data.frame(x=c(10, 20))\n# model predicted values of y, for the values of x inside the 'some_newdata' object:\npredict(my_model, newdata = some_newdata)\n\n       1        2 \n 9.33792 17.13307 \n\n\nGiven that our fitted model takes the form below, we can work this out ourselves as well:\n\\[\n\\begin{align}\ny &= 1.54 + 0.78\\cdot x \\\\\ny &= 1.54 + 0.78\\cdot 10 \\\\\ny &= 1.54 + 7.80\\\\\ny &= 9.34 \\\\\n\\end{align}\n\\]"
  },
  {
    "objectID": "05b_slr.html#footnotes",
    "href": "05b_slr.html#footnotes",
    "title": "5B: Simple Linear Regression",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nRecall that a standard error gives a numerical answer to the question of how variable a statistic will be because of random sampling.↩︎\nWhy \\(n-2\\)? The most intuitive answer is that we have already used up 2 pieces of information in estimating the intercept and the slope. Once these things are fixed, \\(n-2\\) of the datapoints could be wherever they like around that line, but the remaining 2 must be placed in such a way that results in that line↩︎"
  },
  {
    "objectID": "csstests.html",
    "href": "csstests.html",
    "title": "Tests",
    "section": "",
    "text": "Notes for Wizards\n\n\n\n\n\nhere’s a note!\n\n\n\n\n\n\n\n\n\nHints\n\n\n\n\n\n\n\n\n\n\nlearning obj\n\n\nimportant\n\n\nsticky\n\n\n\n\n\nr tips\n\n\nstatbox\n\n\ninterprtation interprtation interprtation\n\n\nQuestion\n\n\nquestion\nwhat is your name?\nwhat is your favourite colour?\n\n\n\n\n\nSolution\n\n\n\nsolution\nhello\n\n2+2\n\n[1] 4\n\n\n\n\n\n\n\nOptional hello my optional friend\n\n\n\nit’s nice to see you again\n\n\n\n\n\nthis is not a panel\n\n\nthis is a panel\n\n\nthis is a panel"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Univariate Statistics and Methodology in R",
    "section": "",
    "text": "Univariate Statistics and Methodology in R (USMR) is a semester long crash-course aimed at providing Masters students in psychology with a competence in standard statistical methodologies and data analysis using R. Typically the analyses taught in this course are relevant for when there is just one source of variation - i.e. when we are interested in a single outcome measured across a set of independent observations. The first half of the course covers the fundamentals of statistical inference using a simulation-based approach, and introduces students to working with R & RStudio. The latter half of the course focuses on the general linear model, emphasising the fact that many statistical methods are simply special cases of this approach. This course introduces students to statistical modelling and empowers them with tools to analyse richer data and answer a broader set of research questions."
  },
  {
    "objectID": "lvp.html",
    "href": "lvp.html",
    "title": "Likelihood vs Probability",
    "section": "",
    "text": "Upon hearing the terms “probability” and “likelihood”, people will often tend to interpret them as synonymous. In statistics, however, the distinction between these two concepts is very important (and often misunderstood)."
  },
  {
    "objectID": "lvp.html#setup",
    "href": "lvp.html#setup",
    "title": "Likelihood vs Probability",
    "section": "Setup",
    "text": "Setup\nLet’s consider a coin flip. For a fair coin, the chance of getting a heads/tails for any given flip is 0.5.\nWe can simulate the number of “heads” in a single fair coin flip with the following code (because it is a single flip, it’s just going to return 0 or 1):\n\nrbinom(n = 1, size = 1, prob = 0.5)\n\n[1] 1\n\n\nWe can simulate the number of “heads” in 8 fair coin flips with the following code:\n\nrbinom(n = 1, size = 8, prob = 0.5)\n\n[1] 5\n\n\nAs the coin is fair, what number of heads would we expect to see out of 8 coin flips? Answer: 4! Doing another 8 flips:\n\nrbinom(n = 1, size = 8, prob = 0.5)\n\n[1] 3\n\n\nand another 8:\n\nrbinom(n = 1, size = 8, prob = 0.5)\n\n[1] 4\n\n\nWe see that they tend to be around our intuition expected number of 4 heads. We can change n = 1 to ask rbinom() to not just do 1 set of 8 coin flips, but to do 1000 sets of 8 flips:\n\ntable(rbinom(n = 1000, size = 8, prob = 0.5))\n\n\n  0   1   2   3   4   5   6   7   8 \n  3  29 121 201 286 214 112  31   3"
  },
  {
    "objectID": "lvp.html#probability",
    "href": "lvp.html#probability",
    "title": "Likelihood vs Probability",
    "section": "Probability",
    "text": "Probability\nSo what is the probability of observing \\(k\\) heads in \\(n\\) flips of a fair coin?\nAs coin flips are independent, we can calculate probability using the product rule (\\(P(AB) = P(A)\\cdot P(B)\\) where \\(A\\) and \\(B\\) are independent).\nSo the probability of observing 2 heads in 2 flips is \\(0.5 \\cdot 0.5 = 0.25\\)\nWe can get to this probability using dbinom():\n\ndbinom(2, size=2, prob=0.5)\n\n[1] 0.25\n\n\nIn 8 flips, those two heads could occur in various ways:\n\n\n\n\n\n\n  \n    \n      Ways to get 2 heads in 8 flips\n    \n  \n  \n    HTTTTHTT\n    TTTHHTTT\n    THTHTTTT\n    TTTTTHTH\n    TTTHTTHT\n    TTTTHHTT\n    HTTHTTTT\n    HTTTTTTH\n    THTTTTHT\n    ...\n  \n  \n  \n\n\n\n\nAs it happens, there are 28 different ways this could happen.2\nThe probability of getting 2 heads in 8 flips of a fair coin is, therefore:\n\n28 * (0.5^8)\n\n[1] 0.109375\n\n\nOr, using dbinom()\n\ndbinom(2, size = 8, prob = 0.5)\n\n[1] 0.109375\n\n\n\nThe important thing here is that when we are computing the probability, two things are fixed:\n\nthe number of coin flips (8)\nthe value(s) that govern the coin’s behaviour (0.5 chance of landing on heads for any given flip)\n\nWe can then can compute the probabilities for observing various numbers of heads:\n\ndbinom(0:8, 8, prob = 0.5)\n\n[1] 0.00390625 0.03125000 0.10937500 0.21875000 0.27343750 0.21875000 0.10937500\n[8] 0.03125000 0.00390625\n\n\n\n\n\n\n\n\n\n\n\nNote that the probability of observing 10 heads in 8 coin flips is 0, as we would hope!\n\ndbinom(10, 8, prob = 0.5)\n\n[1] 0"
  },
  {
    "objectID": "lvp.html#likelihood",
    "href": "lvp.html#likelihood",
    "title": "Likelihood vs Probability",
    "section": "Likelihood",
    "text": "Likelihood\nSo how does likelihood differ?\nFor likelihood, we are interested in hypotheses about or models of our coin. Do we think it is a fair coin (for which the probability of heads is 0.5?). Do we think it is biased to land on heads 60% of the time? or 30% of the time? All of these are different ‘models’.\nTo consider these hypotheses, we need to observe some data - we need to have a given number of flips, and the resulting number of heads.\nWhereas when discussing probability, we varied the number of heads, and fixed the parameter that designates the true chance of landing on heads for any given flip, for the likelihood we are fixing the number of heads observed, and can make statements about different possible parameters that might govern the coin’s behaviour.\nFor example, let’s suppose we did observe 2 heads in 8 flips, what is the probability of seeing this data given various parameters?\nHere, our parameter (the probability that we think the coin lands on heads) can take any real number between from 0 to 1, but let’s do it for a selection:\n\npossible_parameters = seq(from = 0, to = 1, by = 0.05)\ndbinom(2, 8, possible_parameters)\n\n [1] 0.000000e+00 5.145643e-02 1.488035e-01 2.376042e-01 2.936013e-01\n [6] 3.114624e-01 2.964755e-01 2.586868e-01 2.090189e-01 1.569492e-01\n[11] 1.093750e-01 7.033289e-02 4.128768e-02 2.174668e-02 1.000188e-02\n[16] 3.845215e-03 1.146880e-03 2.304323e-04 2.268000e-05 3.948437e-07\n[21] 0.000000e+00\n\n\nSo what we are doing here is considering the possible parameters that govern our coin. Given that we observed 2 heads in 8 coin flips, it seems very unlikely that the coin weighted such that it lands on heads 80% of the time (e.g., the parameter of 0.8 is not likely). The idea that the coin is fair (0.5 probability) is more likely. The most likely parameter is 0.25 (because \\(\\frac{2}{8}=0.25\\)).\nYou can visualise this below:"
  },
  {
    "objectID": "lvp.html#a-slightly-more-formal-approach",
    "href": "lvp.html#a-slightly-more-formal-approach",
    "title": "Likelihood vs Probability",
    "section": "A slightly more formal approach",
    "text": "A slightly more formal approach\nLet \\(d\\) be our data (our observed outcome), and let \\(\\theta\\) be the parameters that govern the data generating process.\nWhen talking about “probability” we are talking about \\(P(d | \\theta)\\) for a given value of \\(\\theta\\).\nE.g. above we were talking about \\(P(\\text{2 heads in 8 flips}\\vert \\text{fair coin})\\).\nIn reality, we don’t actually know what \\(\\theta\\) is, but we do observe some data \\(d\\).\nGiven that we know that if we have a specific value for \\(\\theta\\), then \\(P(d \\vert \\theta)\\) will give us the probability of observing \\(d\\), we can ask “what value of \\(\\theta)\\) will maximise the probability of observing \\(d\\)?”.\nThis will sometimes get written as \\(\\mathcal{L}(\\theta \\vert d)\\) as the “likelihood function” of our unknown parameters \\(\\theta\\), conditioned upon our observed data \\(d\\)."
  },
  {
    "objectID": "lvp.html#footnotes",
    "href": "lvp.html#footnotes",
    "title": "Likelihood vs Probability",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis is the typical frequentist stats view. There are other ways to do statistics (not covered in this course) - e.g., in Bayesian statistics, probability relates to the reasonable expectation (or “plausibility”) of a belief↩︎\nIf you really want to see them all, try running combn(8, 2) in your console.↩︎"
  }
]